// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`a_array_expr 1`] = `"ARRAY[namesplaceholder1, namesplaceholder2]"`;

exports[`a_const 1`] = `"'aconst'"`;

exports[`a_const int 1`] = `"2"`;

exports[`a_const str 1`] = `"'astring'"`;

exports[`a_expr 0-4 1`] = `"(<lexpr placeholder> = <rexpr placeholder>)"`;

exports[`a_expr 0-4 2`] = `"<lexpr placeholder> = ANY( <rexpr placeholder> )"`;

exports[`a_expr 0-4 3`] = `"<lexpr placeholder> = ALL( <rexpr placeholder> )"`;

exports[`a_expr 0-4 4`] = `"<lexpr placeholder> IS DISTINCT FROM <rexpr placeholder>"`;

exports[`a_expr 0-4 5`] = `"NULLIF(<lexpr placeholder>, <rexpr placeholder>)"`;

exports[`a_expr 0-4 name 1`] = `"(<lexpr placeholder> OPERATOR(\\"<name1 placeholder>\\".<name2 placeholder>) <rexpr placeholder>)"`;

exports[`a_expr 0-4 name 2`] = `"<lexpr placeholder> <name1 placeholder> ANY( <rexpr placeholder> )"`;

exports[`a_expr 0-4 name 3`] = `"<lexpr placeholder> <name1 placeholder> ALL( <rexpr placeholder> )"`;

exports[`a_expr 0-4 name 4`] = `"<lexpr placeholder> IS DISTINCT FROM <rexpr placeholder>"`;

exports[`a_expr 0-4 name 5`] = `"NULLIF(<lexpr placeholder>, <rexpr placeholder>)"`;

exports[`a_expr 1`] = `"(a = b)"`;

exports[`a_expr 2`] = `"(<lexpr placeholder> = <rexpr placeholder>)"`;

exports[`a_expr 5  1`] = `"<lexpr placeholder> IS OF ( <rexpr placeholder> )"`;

exports[`a_expr 6-7  1`] = `"<lexpr placeholder> IN ( <rexpr placeholder> )"`;

exports[`a_expr 6-7  2`] = `"<lexpr placeholder> IN ( <rexpr placeholder> )"`;

exports[`a_expr 8-9 1`] = `"<lexpr placeholder> LIKE ( <rexpr placeholder> )"`;

exports[`a_expr 8-9 2`] = `"<lexpr placeholder> ILIKE ( <rexpr placeholder> )"`;

exports[`a_expr 10 1`] = `"<lexpr placeholder> SIMILAR TO arg1 ESCAPE arg2"`;

exports[`a_expr 11-12 1`] = `"<lexpr placeholder> BETWEEN arg1 AND arg2"`;

exports[`a_expr 11-12 2`] = `"<lexpr placeholder> NOT BETWEEN arg1 AND arg2"`;

exports[`a_indices 1`] = `"[2]"`;

exports[`a_indices 2`] = `"[2:2]"`;

exports[`a_indirection 1`] = `".namesplaceholder1.namesplaceholder2"`;

exports[`a_star 1`] = `"*"`;

exports[`alias 1`] = `"AS myrule (namesplaceholder)"`;

exports[`alias 2`] = `"AS myrule"`;

exports[`bit_string 1`] = `"m'ystring'"`;

exports[`bool_expr 1`] = `"(namesplaceholder1 AND namesplaceholder2)"`;

exports[`bool_expr 2`] = `"(namesplaceholder1 OR namesplaceholder2)"`;

exports[`bool_expr 3`] = `"NOT IN (namesplaceholder1)"`;

exports[`boolean_test 1`] = `"<booltest placeholder> IS TRUE"`;

exports[`boolean_test 2`] = `"<booltest placeholder> IS NOT TRUE"`;

exports[`boolean_test 3`] = `"<booltest placeholder> IS FALSE"`;

exports[`boolean_test 4`] = `"<booltest placeholder> IS NOT FALSE"`;

exports[`boolean_test 5`] = `"<booltest placeholder> IS UNKNOWN"`;

exports[`boolean_test 6`] = `"<booltest placeholder> IS NOT UNKNOWN"`;

exports[`case_expr 1`] = `"CASE <arg placeholder> <arg1> <arg2> ELSE <defresult placeholder> END"`;

exports[`case_expr 2`] = `"CASE <arg placeholder> ELSE <defresult placeholder> END"`;

exports[`coalesce_expr 1`] = `"COALESCE(<arg1>, <arg2>)"`;

exports[`collate_clause 1`] = `"<arg1> COLLATE \\"<arg1>\\", \\"<arg2>\\""`;

exports[`column_def 1`] = `"mycol text USING <arg3> <arg1> <arg2> COLLATE"`;

exports[`column_def 2`] = `"mycol text <arg1> <arg2>"`;

exports[`column_def 3`] = `"\\"my-col\\" text"`;

exports[`column_ref 1`] = `"\\"<arg1>\\".\\"<arg2>\\""`;

exports[`column_ref 2`] = `"arg1.arg2"`;

exports[`comment_stmt 1`] = `"COMMENT ON COLUMN <object> (arg1, arg2) IS E'my comment'"`;

exports[`common_table_expr 1`] = `"ctename (arg1, arg2) AS (<ctequery>)"`;

exports[`composite_type_stmt 1`] = `"CREATE TYPE <arg1> AS (<arg1>,<arg2>)"`;

exports[`def_elem 1`] = `"thing=<arg>"`;

exports[`def_elem 2`] = `"ISOLATION LEVEL MYLEVEL"`;

exports[`do_stmt 1`] = `
"DO $CODEZ$
 RUN MY CODEZ $CODEZ$"
`;

exports[`float 1`] = `"0.1234"`;

exports[`float 2`] = `"3234.234235234"`;

exports[`float 3`] = `"3.145"`;

exports[`float 4`] = `"234.2342432"`;

exports[`func_call 1`] = `"dan()"`;

exports[`func_call 2`] = `"name1.name2(DISTINCT arg1, VARIADIC arg2)"`;

exports[`func_call 3`] = `"name1.name2(DISTINCT arg1, arg2, VARIADIC *) WITHIN GROUP (ORDER BY arg1, arg2) FILTER (WHERE arg2) OVER arg2"`;

exports[`func_call 4`] = `"name1.name2(arg1, arg2 ORDER BY arg1, arg2 ) FILTER (WHERE arg2) OVER arg2"`;

exports[`grouping_func 1`] = `"GROUPING(name1, name2)"`;

exports[`grouping_set 1`] = `"()"`;

exports[`grouping_set 2`] = `"ROLLUP (name1, name2)"`;

exports[`grouping_set 3`] = `"CUBE (name1, name2)"`;

exports[`grouping_set 4`] = `"GROUPING SETS (name1, name2)"`;

exports[`index_elem 1`] = `"indexname"`;

exports[`index_stmt 1`] = `"CREATE INDEX ON <relation>"`;

exports[`index_stmt 2`] = `"CREATE INDEX ON <relation> (name1, name2)"`;

exports[`index_stmt 3`] = `"CREATE UNIQUE INDEX CONCURRENTLY idxname ON <relation> (name1, name2)"`;

exports[`insert_stmt 1`] = `"INSERT INTO <relation> DEFAULT VALUES"`;

exports[`insert_stmt 2`] = `"INSERT INTO <relation> (id, name) DEFAULT VALUES"`;

exports[`insert_stmt 3`] = `"INSERT INTO objects.object (name, val, active, hash) VALUES ('name', 'val', 't'::boolean, 'abcdefg'), ('name', 'val', 't'::boolean, 'abcdefg'), ('name', 'val', 't'::boolean, 'abcdefg')"`;

exports[`insert_stmt 4`] = `"INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name"`;

exports[`insert_stmt 5`] = `"INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name WHERE (prop = 1)"`;

exports[`insert_stmt 6`] = `"INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO NOTHING"`;

exports[`insert_stmt 7`] = `"INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ON CONSTRAINT customers_name_key DO NOTHING"`;

exports[`insert_stmt 8`] = `"INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT (name) DO UPDATE SET email = ((EXCLUDED.email || ';') || customers.email)"`;

exports[`insert_stmt 9`] = `"INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT (name) DO UPDATE SET email = ((EXCLUDED.email || ';') || customers.email), level = (customers.level + 1), other = EXCLUDED.other"`;

exports[`insert_stmt 10`] = `"INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT (id, project_id) DO UPDATE SET email = ((EXCLUDED.email || ';') || customers.email), level = (customers.level + 1), other = EXCLUDED.other RETURNING *"`;

exports[`raw_stmt 1`] = `"NULL::text[]"`;

exports[`rename_stmt 1`] = `"ALTER TABLE <arg1> RENAME COLUMN subname TO newname"`;

exports[`rule_stmt 1`] = `"CREATE RULE \\"my-rule\\" AS ON INSERT TO <relation placeholder> WHERE <whereClause placeholder> DO <actions placeholder>"`;

exports[`sql_value_function 1`] = `"CURRENT_DATE"`;

exports[`sql_value_function 2`] = `"CURRENT_TIMESTAMP"`;

exports[`sql_value_function 3`] = `"CURRENT_USER"`;

exports[`sql_value_function 4`] = `"SESSION_USER"`;

exports[`type_cast 1`] = `"NULL::text[]"`;

exports[`type_name 1`] = `"text"`;
