// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`a_expr 1`] = `
"CREATE VIEW superschema.app_authorized_grants AS SELECT COALESCE(NULLIF((s)[1], ''), 'PUBLIC') AS grantee,
relname AS table_name,
nspname AS table_schema,
string_agg((s)[2], ', ') AS privileges,
relkind AS table_type FROM pg_class AS c INNER JOIN pg_namespace AS n ON n.oid = relnamespace INNER JOIN pg_roles AS r ON r.oid = relowner,
unnest(COALESCE(relacl::text[], format('{%%s=arwdDxt/%%s}', rolname, rolname)::text[])) AS acl,
regexp_split_to_array(acl, '=|/') AS s WHERE ((s)[1] = 'authenticated' OR (s)[1] IS NULL) AND nspname NOT IN ( 'pg_catalog', 'information_schema', 'pg_toast' ) GROUP BY grantee,
table_name,
table_schema,
relkind ORDER BY relkind <> 'r',
relkind <> 'v',
relkind <> 'm',
relkind <> 'i',
relkind,
nspname,
relname;
SELECT a = b;
SELECT foo = ANY( x ) FROM vtable;
SELECT foo = ALL( x ) FROM vtable;
SELECT foo,
bar FROM vtable WHERE foo IS DISTINCT FROM bar;
SELECT foo,
bar FROM vtable WHERE foo IS NOT DISTINCT FROM bar;
SELECT t1.foo,
t1.bar,
t1.baz FROM t1 LEFT OUTER JOIN t2 ON t1.foo IS NOT DISTINCT FROM t2.foo AND t1.bar IS NOT DISTINCT FROM t2.bar AND t1.baz IS NOT DISTINCT FROM t2.baz WHERE t2.foo IS NULL;
SELECT NULLIF(NULL, '');
SELECT x,
x IS OF ( text ) AS is_text FROM q;
SELECT x,
x IS NOT OF ( text ) AS is_text FROM q;
SELECT COALESCE(4::domainint4, 7::domainint4) IS OF ( domainint4 ) AS t;
SELECT value IN (SELECT column_name FROM table_name);
SELECT NOT (value IN (SELECT column_name FROM table_name));
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id IN ( 1, 2 ) ORDER BY return_date DESC;
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id NOT IN ( 1, 2 );
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id <> 1 AND customer_id <> 2;
SELECT * FROM employees WHERE name IN ( 'James John', 'Mercy Bush', 'Kate Joel' );
SELECT * FROM employees WHERE name NOT IN ( 'James John', 'Mercy Bush', 'Kate Joel' );
SELECT customer_id FROM rental WHERE return_date::date = '2005-05-27' ORDER BY customer_id;
SELECT customer_id,
first_name,
last_name FROM customer WHERE customer_id IN (SELECT customer_id FROM rental WHERE return_date::date = '2005-05-27') ORDER BY customer_id;
SELECT * FROM student WHERE name LIKE ( 'a%' );
SELECT * FROM student WHERE name NOT LIKE ( 'a%' );
SELECT 'foo' LIKE ( 'foo' ),
'foo' LIKE ( 'f%' ),
'foo' LIKE ( '_o_' ),
'bar' LIKE ( 'b_' );
SELECT * FROM student WHERE name ILIKE ( 'a%' );
SELECT * FROM student WHERE name NOT ILIKE ( 'a%' );
SELECT 'xyz' SIMILAR TO 'xyz' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO 'x' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO '%(y|a)%' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO '(y|z)%' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO 'xyz' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO 'x' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO '%(y|a)%' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO '(y|z)%' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO 'xyz' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO 'x' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO '%(y|a)%' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO '(y|z)%' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO 'xyz' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO 'x' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO '%(y|a)%' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO '(y|z)%' ESCAPE 'x';
SELECT * FROM generate_series(1, 10) AS numbers (a) WHERE numbers.a BETWEEN SYMMETRIC 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers (a) WHERE numbers.a BETWEEN 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers (a) WHERE numbers.a NOT BETWEEN SYMMETRIC 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers (a) WHERE numbers.a NOT BETWEEN 6 AND 3;"
`;

exports[`a_expr 2`] = `
"CREATE VIEW superschema.app_authorized_grants AS SELECT COALESCE(NULLIF((s)[1], ''), 'PUBLIC') AS grantee,
relname AS table_name,
nspname AS table_schema,
string_agg((s)[2], ', ') AS privileges,
relkind AS table_type FROM pg_class AS c INNER JOIN pg_namespace AS n ON n.oid = relnamespace INNER JOIN pg_roles AS r ON r.oid = relowner,
unnest(COALESCE(relacl::text[], format('{%%s=arwdDxt/%%s}', rolname, rolname)::text[])) AS acl,
regexp_split_to_array(acl, '=|/') AS s WHERE ((s)[1] = 'authenticated' OR (s)[1] IS NULL) AND nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast') GROUP BY grantee,
table_name,
table_schema,
relkind ORDER BY relkind <> 'r',
relkind <> 'v',
relkind <> 'm',
relkind <> 'i',
relkind,
nspname,
relname;
SELECT a = b;
SELECT foo = ANY (x) FROM vtable;
SELECT foo = ALL (x) FROM vtable;
SELECT foo,
bar FROM vtable WHERE foo IS DISTINCT FROM bar;
SELECT foo,
bar FROM vtable WHERE foo IS NOT DISTINCT FROM bar;
SELECT t1.foo,
t1.bar,
t1.baz FROM t1 LEFT OUTER JOIN t2 ON t1.foo IS NOT DISTINCT FROM t2.foo AND t1.bar IS NOT DISTINCT FROM t2.bar AND t1.baz IS NOT DISTINCT FROM t2.baz WHERE t2.foo IS NULL;
SELECT NULLIF(NULL, '');
SELECT x,
x IS OF (text) AS is_text FROM q;
SELECT x,
x IS NOT OF (text) AS is_text FROM q;
SELECT COALESCE(4::domainint4, 7::domainint4) IS OF (domainint4) AS t;
SELECT value IN (SELECT column_name FROM table_name);
SELECT NOT (value IN (SELECT column_name FROM table_name));
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id IN (1, 2) ORDER BY return_date DESC;
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id NOT IN (1, 2);
SELECT customer_id,
rental_id,
return_date FROM rental WHERE customer_id <> 1 AND customer_id <> 2;
SELECT * FROM employees WHERE name IN ('James John', 'Mercy Bush', 'Kate Joel');
SELECT * FROM employees WHERE name NOT IN ('James John', 'Mercy Bush', 'Kate Joel');
SELECT customer_id FROM rental WHERE return_date::date = '2005-05-27' ORDER BY customer_id;
SELECT customer_id,
first_name,
last_name FROM customer WHERE customer_id IN (SELECT customer_id FROM rental WHERE return_date::date = '2005-05-27') ORDER BY customer_id;
SELECT * FROM student WHERE name LIKE ('a%');
SELECT * FROM student WHERE name NOT LIKE ('a%');
SELECT 'foo' LIKE ('foo'),
'foo' LIKE ('f%'),
'foo' LIKE ('_o_'),
'bar' LIKE ('b_');
SELECT * FROM student WHERE name ILIKE ('a%');
SELECT * FROM student WHERE name NOT ILIKE ('a%');
SELECT 'xyz' SIMILAR TO 'xyz' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO 'x' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO '%(y|a)%' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO '(y|z)%' ESCAPE NULL;
SELECT 'xyz' SIMILAR TO 'xyz' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO 'x' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO '%(y|a)%' ESCAPE 'x';
SELECT 'xyz' SIMILAR TO '(y|z)%' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO 'xyz' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO 'x' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO '%(y|a)%' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO '(y|z)%' ESCAPE NULL;
SELECT 'xyz' NOT SIMILAR TO 'xyz' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO 'x' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO '%(y|a)%' ESCAPE 'x';
SELECT 'xyz' NOT SIMILAR TO '(y|z)%' ESCAPE 'x';
SELECT * FROM generate_series(1, 10) AS numbers(a) WHERE numbers.a BETWEEN SYMMETRIC 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers(a) WHERE numbers.a BETWEEN 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers(a) WHERE numbers.a NOT BETWEEN SYMMETRIC 6 AND 3;
SELECT * FROM generate_series(1, 10) AS numbers(a) WHERE numbers.a NOT BETWEEN 6 AND 3;"
`;

exports[`drops 1`] = `
"DROP POLICY policy_name ON schema_name.table_name;
DROP POLICY policy_name ON table_name;
REVOKE DELETE ON TABLE schema_name.table_name FROM authenticated;
REVOKE DELETE ON TABLE table_name FROM authenticated;
DROP TABLE table_name;
DROP TABLE schema_name.table_name;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".\\"aa-bdd\\" DROP COLUMN \\"sdf-sdf\\";
ALTER TABLE \\"table-name\\" DROP COLUMN column_name;
ALTER TABLE table_name DROP COLUMN column_name;
DROP SEQUENCE IF EXISTS hsseq;
DROP SEQUENCE IF EXISTS \\"some-thing\\".hsseq;
ALTER TABLE schemaname.table_name RENAME COLUMN column_name1 TO new_column_name1;
ALTER TABLE table_name RENAME COLUMN column_name1 TO new_column_name1;
DROP TYPE test_type;
DROP TYPE schema_name.test_type;
DROP TYPE \\"schema-name\\".test_type;
DROP TYPE \\"schema-name\\".\\"test-type\\";
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE IF EXISTS \\"aa-bb\\".test_type_exists;
DROP TYPE eitype CASCADE;
DROP DOMAIN testdomain2b;
DROP DOMAIN schema_name.testdomain2b;
DROP FUNCTION testfunc5b ( testdomain1 );
DROP FUNCTION \\"my-schema\\".testfunc5b ( testdomain1 );
DROP FUNCTION testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".\\"test-func6b\\" ( int );
DROP FUNCTION testfunc7777;
DROP FUNCTION \\"my-schema\\".testfunc7777;
DROP TRIGGER trigger_name ON table_name;
DROP TRIGGER IF EXISTS trigger_name ON table_name;
DROP TRIGGER trigger_name ON schema_name.table_name;
DROP TRIGGER IF EXISTS trigger_name ON schema_name.table_name;
DROP RULE rule_name ON table_name;
DROP RULE IF EXISTS rule_name ON table_name;
DROP RULE rule_name ON schema_name.table_name;
DROP RULE IF EXISTS rule_name ON schema_name.table_name;
DROP VIEW IF EXISTS test_view_exists;
DROP VIEW test_view_exists;
DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP AGGREGATE IF EXISTS no_such_schema.foo ( int );
DROP AGGREGATE IF EXISTS foo ( no_such_type );
DROP AGGREGATE IF EXISTS foo ( no_such_schema.no_such_type );
DROP CAST IF EXISTS ( int AS no_such_type2 );
DROP CAST IF EXISTS ( no_such_type1 AS int );
DROP CAST IF EXISTS ( int AS no_such_schema.bar );
DROP CAST IF EXISTS ( no_such_schema.foo AS int );
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP INDEX IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;"
`;

exports[`drops 2`] = `
"DROP POLICY policy_name ON schema_name.table_name;
DROP POLICY policy_name ON table_name;
REVOKE DELETE ON TABLE schema_name.table_name FROM authenticated;
REVOKE DELETE ON TABLE table_name FROM authenticated;
DROP TABLE table_name;
DROP TABLE schema_name.table_name;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".\\"aa-bdd\\" DROP COLUMN \\"sdf-sdf\\";
ALTER TABLE \\"table-name\\" DROP COLUMN column_name;
ALTER TABLE table_name DROP COLUMN column_name;
DROP SEQUENCE IF EXISTS hsseq;
DROP SEQUENCE IF EXISTS \\"some-thing\\".hsseq;
ALTER TABLE schemaname.table_name RENAME column_name1 TO new_column_name1;
ALTER TABLE table_name RENAME column_name1 TO new_column_name1;
DROP TYPE test_type;
DROP TYPE schema_name.test_type;
DROP TYPE \\"schema-name\\".test_type;
DROP TYPE \\"schema-name\\".\\"test-type\\";
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE IF EXISTS \\"aa-bb\\".test_type_exists;
DROP TYPE eitype CASCADE;
DROP DOMAIN testdomain2b;
DROP DOMAIN schema_name.testdomain2b;
DROP FUNCTION testfunc5b ( testdomain1 );
DROP FUNCTION \\"my-schema\\".testfunc5b ( testdomain1 );
DROP FUNCTION testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".\\"test-func6b\\" ( int );
DROP FUNCTION testfunc7777;
DROP FUNCTION \\"my-schema\\".testfunc7777;
DROP TRIGGER trigger_name ON table_name;
DROP TRIGGER IF EXISTS trigger_name ON table_name;
DROP TRIGGER trigger_name ON schema_name.table_name;
DROP TRIGGER IF EXISTS trigger_name ON schema_name.table_name;
DROP RULE rule_name ON table_name;
DROP RULE IF EXISTS rule_name ON table_name;
DROP RULE rule_name ON schema_name.table_name;
DROP RULE IF EXISTS rule_name ON schema_name.table_name;
DROP VIEW IF EXISTS test_view_exists;
DROP VIEW test_view_exists;
DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP AGGREGATE IF EXISTS no_such_schema.foo ( int );
DROP AGGREGATE IF EXISTS foo ( no_such_type );
DROP AGGREGATE IF EXISTS foo ( no_such_schema.no_such_type );
DROP CAST IF EXISTS ( int AS no_such_type2 );
DROP CAST IF EXISTS ( no_such_type1 AS int );
DROP CAST IF EXISTS ( int AS no_such_schema.bar );
DROP CAST IF EXISTS ( no_such_schema.foo AS int );
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP INDEX IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;"
`;

exports[`kitchen sink alias 1`] = `
"SELECT * FROM generate_series(1, 1) AS \\"a#b\\";
SELECT * FROM generate_series(1, 1) AS \\"a#b\\" (\\"c#d\\");
SELECT * FROM generate_series(1, 1) AS aba;
SELECT * FROM generate_series(1, 1) AS aba (ccd);"
`;

exports[`kitchen sink alias 2`] = `
"SELECT * FROM generate_series(1, 1) AS \\"a#b\\";
SELECT * FROM generate_series(1, 1) AS \\"a#b\\"(\\"c#d\\");
SELECT * FROM generate_series(1, 1) AS aba;
SELECT * FROM generate_series(1, 1) AS aba(ccd);"
`;

exports[`kitchen sink alter 1`] = `
"CREATE SCHEMA IF NOT EXISTS app_jobs;
CREATE TABLE app_jobs.job_queues (
queue_name varchar NOT NULL PRIMARY KEY,
job_count int DEFAULT (0) NOT NULL,
locked_at pg_catalog.timestamptz,
locked_by varchar
);
ALTER TABLE app_jobs.job_queues ENABLE ROW LEVEL SECURITY;
CREATE TABLE foo (
name text,
foo_timestamp timestampz DEFAULT (CURRENT_DATE)
);
ALTER TABLE foo RENAME COLUMN name TO city;
ALTER TABLE foo ALTER COLUMN foo_timestamp DROP DEFAULT, ALTER COLUMN foo_timestamp TYPE pg_catalog.timestamptz USING 'epoch'::pg_catalog.timestamptz + (foo_timestamp * '1 second'::interval), ALTER COLUMN foo_timestamp SET DEFAULT now();
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE CASCADE ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE RESTRICT ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE SET NULL ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE SET NULL ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (a, b) REFERENCES othr.orders (c, d)   MATCH FULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (a, b) REFERENCES othr.orders (c, d)  ;
ALTER TABLE ONLY collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);
ALTER TABLE collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ADD COLUMN column_name column_type;
ALTER TABLE schema_name.table_name ADD COLUMN column_name geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN \\"column-name\\" geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN column_name int;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE mytable OWNER TO regtest_alter_user2;
ALTER FUNCTION alt_func3 ( int ) RENAME TO alt_func4;
ALTER FUNCTION alt_func1 ( int ) RENAME TO alt_func4;
ALTER FUNCTION alt_func3 ( int ) OWNER TO regtest_alter_user2;
ALTER FUNCTION alt_func2 ( int ) OWNER TO regtest_alter_user3;
ALTER FUNCTION alt_func3 ( int ) SET SCHEMA alt_nsp2;
ALTER FUNCTION alt_func2 ( int ) SET SCHEMA alt_nsp2;
ALTER TABLE old_schema_name.table_name SET SCHEMA new_schema_name;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;
ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;
ALTER TYPE test_type2 ADD ATTRIBUTE c text;
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ALTER TYPE test_type2 DROP ATTRIBUTE b;
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
CREATE TYPE tt_t0 AS (z inet,x int,y numeric(8, 2));
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
CREATE TABLE tt7 (
x int,
q text,
y numeric(8, 2)
) WITH OIDS;
ALTER TABLE tt7 DROP COLUMN q;
ALTER TABLE tt1 OF tt_t0;
ALTER TABLE tt7 NOT OF;
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT test_drop_constr_parent_c_check;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY (f);
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY (f);
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ALTER TABLE comment_test ALTER COLUMN indexed_col TYPE int;
ALTER TABLE comment_test ALTER COLUMN indexed_col TYPE text;
ALTER TABLE test_add_column ADD COLUMN IF NOT EXISTS c2 int, ADD COLUMN IF NOT EXISTS c3 int, ADD COLUMN c4 int;
ALTER TYPE bogus ADD VALUE 'good';
ALTER TYPE schemaname.bogus ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".bogus ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".\\"bog-us\\" ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".\\"bog-us\\" ADD VALUE 'goo''d';
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE test8b ADD ATTRIBUTE c testdomain1;
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE testdomain1;
REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (value < 11);
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (value < 11) NOT VALID;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
ALTER DOMAIN con ADD CONSTRAINT t CHECK (value < 1);
ALTER DOMAIN con ADD CONSTRAINT t CHECK (value < 34);
ALTER DOMAIN con ADD CHECK (value > 0);
CREATE DOMAIN dinter AS vchar4 CHECK (pg_catalog.\\"substring\\"(value, 1, 1) = 'x');
CREATE DOMAIN dtop AS dinter CHECK (pg_catalog.\\"substring\\"(value, 2, 1) = '1');
ALTER DOMAIN testdomain1 RENAME TO testdomain2;
ALTER TYPE testdomain2 RENAME TO testdomain3;
CREATE DOMAIN testdomain1 AS int CONSTRAINT unsigned CHECK (value > 0);
ALTER DOMAIN testdomain1 RENAME CONSTRAINT unsigned TO unsigned_foo;
ALTER DOMAIN testdomain1 DROP CONSTRAINT unsigned_foo;
DROP DOMAIN testdomain1;"
`;

exports[`kitchen sink alter 2`] = `
"CREATE SCHEMA IF NOT EXISTS app_jobs;
CREATE TABLE app_jobs.job_queues (
queue_name varchar NOT NULL PRIMARY KEY,
job_count int DEFAULT ( 0 ) NOT NULL,
locked_at pg_catalog.timestamptz,
locked_by varchar
);
ALTER TABLE app_jobs.job_queues ENABLE ROW LEVEL SECURITY;
CREATE TABLE foo (
name text,
foo_timestamp timestampz DEFAULT ( CURRENT_DATE )
);
ALTER TABLE foo RENAME name TO city;
ALTER TABLE foo ALTER COLUMN foo_timestamp DROP DEFAULT, ALTER COLUMN foo_timestamp TYPE pg_catalog.timestamptz USING 'epoch'::pg_catalog.timestamptz + (foo_timestamp * '1 second'::interval), ALTER COLUMN foo_timestamp SET DEFAULT now();
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE SET NULL ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( a, b ) REFERENCES othr.orders ( c, d ) MATCH FULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( a, b ) REFERENCES othr.orders ( c, d );
ALTER TABLE ONLY collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY ( id );
ALTER TABLE collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY ( id );
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ADD COLUMN  column_name column_type;
ALTER TABLE schema_name.table_name ADD COLUMN  column_name geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN  \\"column-name\\" geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN  column_name int;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE mytable OWNER TO regtest_alter_user2;
ALTER FUNCTION alt_func3 ( int ) RENAME TO alt_func4;
ALTER FUNCTION alt_func1 ( int ) RENAME TO alt_func4;
ALTER FUNCTION alt_func3 ( int ) OWNER TO regtest_alter_user2;
ALTER FUNCTION alt_func2 ( int ) OWNER TO regtest_alter_user3;
ALTER FUNCTION alt_func3 ( int ) SET SCHEMA alt_nsp2;
ALTER FUNCTION alt_func2 ( int ) SET SCHEMA alt_nsp2;
ALTER TABLE old_schema_name.table_name SET SCHEMA new_schema_name;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;
ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;
ALTER TYPE test_type2 ADD ATTRIBUTE  c text;
ALTER TYPE test_type2 ADD ATTRIBUTE  c text CASCADE;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar;
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ALTER TYPE test_type2 DROP ATTRIBUTE b;
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa;
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE  b int;
CREATE TYPE tt_t0 AS ( 	z inet,
x int,
y numeric(8, 2) );
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
CREATE TABLE tt7 (
x int,
q text,
y numeric(8, 2)
) WITH OIDS;
ALTER TABLE tt7 DROP COLUMN q;
ALTER TABLE tt1 OF tt_t0;
ALTER TABLE tt7 NOT OF;
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT test_drop_constr_parent_c_check;
ALTER TABLE IF EXISTS tt8 ADD COLUMN  f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY ( f );
ALTER TABLE IF EXISTS tt8 ADD CHECK ( f BETWEEN 0 AND 10 );
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ALTER TABLE IF EXISTS tt8 ADD COLUMN  f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY ( f );
ALTER TABLE IF EXISTS tt8 ADD CHECK ( f BETWEEN 0 AND 10 );
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
ALTER TABLE comment_test ALTER COLUMN indexed_col TYPE int;
ALTER TABLE comment_test ALTER COLUMN indexed_col TYPE text;
ALTER TABLE test_add_column ADD COLUMN IF NOT EXISTS  c2 int, ADD COLUMN IF NOT EXISTS  c3 int, ADD COLUMN  c4 int;
ALTER TYPE bogus ADD VALUE 'good';
ALTER TYPE schemaname.bogus ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".bogus ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".\\"bog-us\\" ADD VALUE 'good';
ALTER TYPE \\"schema-name\\".\\"bog-us\\" ADD VALUE 'goo''d';
ALTER TYPE bogus RENAME TO bogon;
ALTER TYPE test8b ADD ATTRIBUTE  c testdomain1;
ALTER TYPE test8b ALTER ATTRIBUTE b TYPE testdomain1;
REVOKE ALL ON TYPE testtype1 FROM PUBLIC;
ALTER DOMAIN things ADD CONSTRAINT meow CHECK ( value < 11 );
ALTER DOMAIN things ADD CONSTRAINT meow CHECK ( value < 11 ) NOT VALID;
ALTER DOMAIN things VALIDATE CONSTRAINT meow;
ALTER DOMAIN con ADD CONSTRAINT t CHECK ( value < 1 );
ALTER DOMAIN con ADD CONSTRAINT t CHECK ( value < 34 );
ALTER DOMAIN con ADD CHECK ( value > 0 );
CREATE DOMAIN dinter AS vchar4 CHECK ( pg_catalog.substring(value, 1, 1) = 'x' );
CREATE DOMAIN dtop AS dinter CHECK ( pg_catalog.substring(value, 2, 1) = '1' );
ALTER DOMAIN testdomain1 RENAME TO testdomain2;
ALTER TYPE testdomain2 RENAME TO testdomain3;
CREATE DOMAIN testdomain1 AS int CONSTRAINT unsigned CHECK ( value > 0 );
ALTER DOMAIN testdomain1 RENAME CONSTRAINT unsigned TO unsigned_foo;
ALTER DOMAIN testdomain1 DROP CONSTRAINT unsigned_foo;
DROP DOMAIN testdomain1;"
`;

exports[`kitchen sink conflicts 1`] = `
"INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name;
INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name WHERE prop = 1;
INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO NOTHING;
INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ON CONSTRAINT customers_name_key DO NOTHING;
INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT (name) DO UPDATE SET email = (EXCLUDED.email || ';') || customers.email;"
`;

exports[`kitchen sink conflicts 2`] = `
"INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO UPDATE  SET field_name = excluded.field_name;
INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO UPDATE  SET field_name = excluded.field_name WHERE prop = 1;
INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO NOTHING;
INSERT INTO customers ( name, email ) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ON CONSTRAINT customers_name_key DO NOTHING;
INSERT INTO customers ( name, email ) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ( name ) DO UPDATE  SET email = (excluded.email || ';') || customers.email;"
`;

exports[`kitchen sink default privs 1`] = `
"ALTER DEFAULT PRIVILEGES IN SCHEMA objects_public
GRANT EXECUTE ON FUNCTIONS  TO authenticated;
ALTER DEFAULT PRIVILEGES REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT SELECT ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT INSERT ON TABLES  TO webuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE SELECT ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE INSERT ON TABLES  FROM webuser;
ALTER DEFAULT PRIVILEGES FOR ROLE admin
REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;"
`;

exports[`kitchen sink default privs 2`] = `
"ALTER DEFAULT PRIVILEGES IN SCHEMA objects_public
GRANT EXECUTE ON FUNCTIONS  TO authenticated;
ALTER DEFAULT PRIVILEGES REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT SELECT ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT INSERT ON TABLES  TO webuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE SELECT ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE INSERT ON TABLES  FROM webuser;
ALTER DEFAULT PRIVILEGES FOR ROLE admin
REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;"
`;

exports[`kitchen sink delete 1`] = `
"DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test AS dt WHERE delete_test.a > 25;
DELETE FROM delete_test WHERE a > 25;"
`;

exports[`kitchen sink delete 2`] = `
"DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test AS dt WHERE delete_test.a > 25;
DELETE FROM delete_test WHERE a > 25;"
`;

exports[`kitchen sink do stmt 1`] = `
"DO $CODEZ$
BEGIN
IF NOT EXISTS (
SELECT
1
FROM
pg_roles
WHERE
rolname = 'administrator') THEN
CREATE ROLE administrator;
COMMENT ON ROLE administrator IS 'Administration group';
END IF;
END $CODEZ$;"
`;

exports[`kitchen sink do stmt 2`] = `
"DO $$
BEGIN
IF NOT EXISTS (
SELECT
1
FROM
pg_roles
WHERE
rolname = 'administrator') THEN
CREATE ROLE administrator;
COMMENT ON ROLE administrator IS 'Administration group';
END IF;
END $$;"
`;

exports[`kitchen sink domain 1`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK (value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$');"
`;

exports[`kitchen sink domain 2`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK ( value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );"
`;

exports[`kitchen sink domains 1`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK (value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$');"
`;

exports[`kitchen sink domains 2`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK ( value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );"
`;

exports[`kitchen sink enums 1`] = `
"CREATE TYPE myschema.special_type AS ENUM (
'oh',
'yea'
);"
`;

exports[`kitchen sink enums 2`] = `
"CREATE TYPE myschema.special_type AS ENUM (
'oh',
'yea'
);"
`;

exports[`kitchen sink fixtures complex.sql 1`] = `
"SELECT p1.playerid,
f1.playername,
p2.playerid,
f2.playername FROM player AS f1,
player AS f2,
plays AS p1 FULL OUTER JOIN plays AS p2 ON p1.playerid < p2.playerid AND p1.teamid = p2.teamid GROUP BY p1.playerid,
f1.playerid,
p2.playerid,
f2.playerid HAVING count(p1.playerid) = count(*) AND count(p2.playerid) = count(*) AND p1.playerid = f1.playerid AND p2.playerid = f2.playerid;"
`;

exports[`kitchen sink fixtures complex.sql 2`] = `
"SELECT p1.playerid,
f1.playername,
p2.playerid,
f2.playername FROM player AS f1,
player AS f2,
plays AS p1 FULL OUTER JOIN plays AS p2 ON p1.playerid < p2.playerid AND p1.teamid = p2.teamid GROUP BY p1.playerid,
f1.playerid,
p2.playerid,
f2.playerid HAVING count(p1.playerid) = count(*) AND count(p2.playerid) = count(*) AND p1.playerid = f1.playerid AND p2.playerid = f2.playerid;"
`;

exports[`kitchen sink fixtures custom.sql 1`] = `
"SELECT * FROM tab ORDER BY col USING <;
SELECT * FROM tab ORDER BY col USING >;
SELECT * FROM tab ORDER BY col USING =;
SELECT * FROM tab ORDER BY col USING = NULLS FIRST,
col2 USING < NULLS LAST;
SELECT mleast(VARIADIC arr:=ARRAY[10, (-1), 5, 4.4]);
SELECT encode('''123\\\\000\\\\001', 'base64');
SELECT 'слон';
SELECT 'data';
SELECT 3 OPERATOR(pg_catalog.+) 4;
SELECT * FROM ROWS FROM (getfoo6(1) AS (fooid int, foosubid int, fooname text), getfoo7(1) AS (fooid int, foosubid int, fooname text)) AS (fooid int, foosubid int, fooname text);
SELECT a FROM b WHERE a < (SELECT 1);
SELECT a FROM b WHERE a < ALL (SELECT 1);
SELECT a FROM b WHERE a < ANY (SELECT 1);
SELECT a FROM b WHERE EXISTS (SELECT 1);
SELECT a FROM b WHERE a < ARRAY (SELECT DISTINCT (SELECT 1),
(SELECT DISTINCT 1 GROUP BY 7 HAVING 1 < (SELECT 1)));
SELECT 1 WHERE 'abc' SIMILAR TO 'abc' ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE 't';
SELECT 1::bit(1);
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
SHOW client_encoding;"
`;

exports[`kitchen sink fixtures custom.sql 2`] = `
"SELECT * FROM tab ORDER BY col USING <;
SELECT * FROM tab ORDER BY col USING >;
SELECT * FROM tab ORDER BY col USING =;
SELECT * FROM tab ORDER BY col USING = NULLS FIRST,
col2 USING < NULLS LAST;
SELECT mleast(VARIADIC arr := ARRAY[10, (-1), 5, 4.4]);
SELECT encode('''123\\\\000\\\\001', 'base64');
SELECT 'слон';
SELECT 'data';
SELECT 3 OPERATOR(pg_catalog.+) 4;
SELECT * FROM ROWS FROM (getfoo6(1) AS (fooid int, foosubid int, fooname text), getfoo7(1) AS (fooid int, foosubid int, fooname text))  AS (fooid int, foosubid int, fooname text);
SELECT a FROM b WHERE a < (SELECT 1);
SELECT a FROM b WHERE a < ALL (SELECT 1);
SELECT a FROM b WHERE a < ANY (SELECT 1);
SELECT a FROM b WHERE EXISTS (SELECT 1);
SELECT a FROM b WHERE a < ARRAY (SELECT DISTINCT (SELECT 1),
(SELECT DISTINCT 1 GROUP BY 7 HAVING 1 < (SELECT 1)));
SELECT 1 WHERE 'abc' SIMILAR TO 'abc' ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE 't';
SELECT 1::bit(1);
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
SHOW client_encoding;"
`;

exports[`kitchen sink fixtures param-ref.sql 1`] = `
"SELECT * FROM table_name WHERE name = ?;
SELECT * FROM table_name WHERE name = $1;
SELECT $1::text AS name;"
`;

exports[`kitchen sink fixtures param-ref.sql 2`] = `
"SELECT * FROM table_name WHERE name = ?;
SELECT * FROM table_name WHERE name = $1;
SELECT $1::text AS name;"
`;

exports[`kitchen sink fixtures query-001.sql 1`] = `
"SELECT array_agg(players),
player_teams FROM (SELECT DISTINCT t1.t1player AS players_dist,
t1.player_teams FROM (SELECT p.playerid AS t1id,
concat(p.playerid, ':', p.playername, ' ') AS t1player,
array_agg(pl.teamid ORDER BY pl.teamid ) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t1 INNER JOIN (SELECT p.playerid AS t2id,
array_agg(pl.teamid ORDER BY pl.teamid ) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t2 ON t1.player_teams = t2.player_teams AND t1.t1id <> t2.t2id) AS innerquery GROUP BY player_teams;"
`;

exports[`kitchen sink fixtures query-001.sql 2`] = `
"SELECT array_agg(players),
player_teams FROM (SELECT DISTINCT t1.t1player AS players_dist,
t1.player_teams FROM (SELECT p.playerid AS t1id,
concat(p.playerid, ':', p.playername, ' ') AS t1player,
array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t1 INNER JOIN (SELECT p.playerid AS t2id,
array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t2 ON t1.player_teams = t2.player_teams AND t1.t1id <> t2.t2id) AS innerquery GROUP BY player_teams;"
`;

exports[`kitchen sink fixtures query-002.sql 1`] = `"SELECT * FROM \\"Foo\\" AS f1 WHERE f1.\\"FooUID\\" = (SELECT f2.\\"FooUID\\" FROM \\"Foo\\" AS f2 LEFT OUTER JOIN \\"Bar\\" AS b ON f2.\\"BarUID\\" = b.\\"BarUID\\" WHERE f2.\\"BarUID\\" IS NOT NULL AND b.\\"BarUID\\" IS NULL LIMIT 1)"`;

exports[`kitchen sink fixtures query-002.sql 2`] = `"SELECT * FROM \\"Foo\\" AS f1 WHERE f1.\\"FooUID\\" = (SELECT f2.\\"FooUID\\" FROM \\"Foo\\" AS f2 LEFT OUTER JOIN \\"Bar\\" AS b ON f2.\\"BarUID\\" = b.\\"BarUID\\" WHERE f2.\\"BarUID\\" IS NOT NULL AND b.\\"BarUID\\" IS NULL LIMIT 1)"`;

exports[`kitchen sink fixtures query-003.sql 1`] = `"SELECT ((SELECT ROW(1, 1, 1, 1)::test)::test).*;"`;

exports[`kitchen sink fixtures query-003.sql 2`] = `"SELECT ((SELECT ROW(1, 1, 1, 1)::test)::test).*;"`;

exports[`kitchen sink fixtures simple.sql 1`] = `
"SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name LIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT LIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name ILIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT ILIKE ( '%''test''%' );
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name > first_name;
SELECT * FROM table_name WHERE last_name <> first_name;
SELECT * FROM table_name WHERE last_name = ANY( stuff );
SELECT * FROM table_name WHERE last_name = ALL( stuff );
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id = ANY (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE NOT (category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama'));
SELECT title FROM film WHERE length >= ANY (SELECT max(length) FROM film JOIN film_category USING (film_id) GROUP BY category_id);
SELECT * FROM transactions.transaction WHERE transaction_date BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;
SELECT * FROM transactions.transaction WHERE transaction_date NOT BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;"
`;

exports[`kitchen sink fixtures simple.sql 2`] = `
"SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name LIKE ('%''test''%');
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT LIKE ('%''test''%');
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name ILIKE ('%''test''%');
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT ILIKE ('%''test''%');
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name > first_name;
SELECT * FROM table_name WHERE last_name <> first_name;
SELECT * FROM table_name WHERE last_name = ANY (stuff);
SELECT * FROM table_name WHERE last_name = ALL (stuff);
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id = ANY (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE NOT (category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama'));
SELECT title FROM film WHERE length >= ANY (SELECT max(length) FROM film JOIN film_category USING (film_id) GROUP BY category_id);
SELECT * FROM transactions.transaction WHERE transaction_date BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;
SELECT * FROM transactions.transaction WHERE transaction_date NOT BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;"
`;

exports[`kitchen sink functions basic 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS void AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;
$LQLCODEZ$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions basic 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS void AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;$EOFCODE$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_table 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS TABLE ( path text, name int ) AS $LQLCODEZ$
SELECT * FROM
mytable
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_table 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS TABLE ( path text, name int ) AS $EOFCODE$SELECT * FROM
mytable$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_trigger 1`] = `
"CREATE OR REPLACE FUNCTION helpers.some_method ( ) RETURNS TRIGGER AS $LQLCODEZ$
BEGIN
IF tg_op = 'INSERT' THEN
NEW.some_prop = helpers.do_magic (NEW.data);
RETURN NEW;
END IF;
END;
$LQLCODEZ$ LANGUAGE plpgsql;"
`;

exports[`kitchen sink functions returns_trigger 2`] = `
"CREATE OR REPLACE FUNCTION helpers.some_method (  ) RETURNS trigger AS $EOFCODE$BEGIN
IF tg_op = 'INSERT' THEN
NEW.some_prop = helpers.do_magic (NEW.data);
RETURN NEW;
END IF;
END;$EOFCODE$ LANGUAGE plpgsql;"
`;

exports[`kitchen sink functions setof 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS SETOF obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id
$LQLCODEZ$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS SETOF obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions setof 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS SETOF obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id$EOFCODE$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS SETOF obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink grants 1`] = `
"GRANT USAGE ON SCHEMA users TO administrator;
GRANT EXECUTE ON FUNCTION auth.authenticate TO anonymous;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token TO administrator;
REVOKE USAGE ON SCHEMA users FROM administrator;
REVOKE EXECUTE ON FUNCTION auth.authenticate FROM anonymous;
REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token FROM administrator;
GRANT SELECT, INSERT ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2 ), UPDATE ( col2, \\"another-column\\" ), DELETE ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;"
`;

exports[`kitchen sink grants 2`] = `
"GRANT USAGE ON SCHEMA users TO administrator;
GRANT EXECUTE ON FUNCTION auth.authenticate TO anonymous;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token TO administrator;
REVOKE USAGE ON SCHEMA users FROM administrator;
REVOKE EXECUTE ON FUNCTION auth.authenticate FROM anonymous;
REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token FROM administrator;
GRANT SELECT, INSERT ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2 ), UPDATE ( col2, \\"another-column\\" ), DELETE ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;"
`;

exports[`kitchen sink indexes 1`] = `
"CREATE INDEX CONCURRENTLY boom_merkle_tree_tag_created_reference_idx ON boom.merkle_tree (tag, created, reference);
CREATE UNIQUE INDEX databases_database_unique_name_idx ON databases.database (tenant_id, database_name_hash(name));
CREATE UNIQUE INDEX boom_worktree_idx ON boom.worktree (tag, reference, created, decode(md5(lower(path)), 'hex'));
CREATE UNIQUE INDEX uniq_service_when_not_null ON schema2.table3 (uid, svc) WHERE svc IS NOT NULL;"
`;

exports[`kitchen sink indexes 2`] = `
"CREATE INDEX CONCURRENTLY boom_merkle_tree_tag_created_reference_idx ON boom.merkle_tree ( tag, created, reference );
CREATE UNIQUE INDEX databases_database_unique_name_idx ON databases.database ( tenant_id, database_name_hash(name) );
CREATE UNIQUE INDEX boom_worktree_idx ON boom.worktree ( tag, reference, created, decode(md5(lower(path)), 'hex') );
CREATE UNIQUE INDEX uniq_service_when_not_null ON schema2.table3 ( uid, svc ) WHERE svc IS NOT NULL;"
`;

exports[`kitchen sink insert 1`] = `
"INSERT INTO shoelace_data VALUES (1, 2, 3, 'truth', TRUE);
INSERT INTO shoelace_data (id, col1, col2, val1, bl2) VALUES (1, 2, 3, 'truth', TRUE);
INSERT INTO shoelace_data DEFAULT VALUES;
INSERT INTO v8.modules (name, code) VALUES ('ajv', ' (FUNCTION () { var module = { exports: { } };
var exports = module.exports;
/* plv8 bundle begins */
(FUNCTION (f) {if(typeof exports == = \\"object\\" && typeof module != = \\"undefined\\") {module.exports=f()}else IF (typeof define == = \\"function\\" && define.amd) {define([], f) }else{var g;
IF (typeof
WINDOW != = \\"undefined\\") {g=window}else IF (typeof global != = \\"undefined\\") {g=global}else IF (typeof self != = \\"undefined\\") {g=self}else{g=this}g.ajv = f () }})(function(){var define,
module,
exports;
RETURN (FUNCTION e (t, n, r) {function s (o, u) {if(!n[o]){if(!t[o]){var a = typeof require == \\"function\\" && require;
IF (! u && a)
RETURN a (o,
! 0);
IF (i)
RETURN i (o,
! 0);
var f = new Error (\\"Cannot find module ''\\" + o + \\"''\\");
throw f.code = \\"MODULE_NOT_FOUND\\",
f }var l = n[o] = {exports : {}};
t[o][0].CALL (l.exports, FUNCTION (e) {var n = t[o][1][e];
RETURN s (n ? n:e) },
l,
l.exports,
e,
t,
n,
r) }return n[o].exports }var i = typeof require == \\"function\\" && require;
FOR (var o = 0;
o < r.length;
o + +) s (r[o]);
RETURN s })({1 :[FUNCTION (require, module, exports) { (FUNCTION (global) {
/*! https://mths.be/punycode v1.4.1 by @mathias */
;
(FUNCTION (root) {
/** Detect free variables */
var freeExports = typeof exports == ''object'' && exports && ! exports.nodeType && exports;
var freeModule = typeof module == ''object'' && module && ! module.nodeType && module;
var freeGlobal = typeof global == ''object'' && global;
IF (freeGlobal.global == = freeGlobal || freeGlobal.window == = freeGlobal || freeGlobal.self == = freeGlobal) { root = freeGlobal;
}
/**
* The \`punycode\` object.
* @name punycode
* @type Object
*/
var punycode,
/** Highest positive signed 32-bit float value */
maxInt = 2147483647,
/ / aka. 0x7FFFFFFF
OR 2 ^ 31 - 1
/** Bootstring parameters */
base = 36,
tMin = 1,
tMax = 26,
skew = 38,
damp = 700,
initialBias = 72,
initialN = 128,
/ / 0x80 DELIMITER = ''-'',
/ / ''\\\\x2D''
/** Regular expressions */
regexPunycode = / ^ xn --/, regexNonASCII = /[^ x20 - x7E] /,
/ / unprintable ASCII chars + non - ASCII chars regexSeparators = /[x2E u3002 uFF0E uFF61] / g,
/ / RFC 3490 separators
/** Error messages */
errors = { ''overflow'' :''Overflow: input needs wider integers to process'',
''not-basic'' :''Illegal input >= 0x80 (not a basic code point)'',
''invalid-input'' :''Invalid input'' },
/** Convenience shortcuts */
baseMinusTMin = base - tMin,
floor = Math.floor,
stringFromCharCode = String.fromCharCode,
/** Temporary variable */
KEY;
/*--------------------------------------------------------------------------*/
/**
* A generic error utility function.
* @private
* @param {String} type The error type.
* @returns {Error} Throws a \`RangeError\` with the applicable error message.
*/
FUNCTION error (TYPE) { throw new RangeError (errors[TYPE]);
}
/**
* A generic \`Array#map\` utility function.
* @private
* @param {Array} array The array to iterate over.
* @param {Function} callback The function that gets called for every array
* item.
* @returns {Array} A new array of values returned by the callback function.
*/
FUNCTION map (ARRAY, fn) { var length = array.length;
var result =[];
while (length --) { result[length] = fn (ARRAY[length]);
} RETURN result;
}
/**
* A simple \`Array#map\`-like wrapper to work with domain name strings or email
* addresses.
* @private
* @param {String} domain The domain name or email address.
* @param {Function} callback The function that gets called for every
* character.
* @returns {Array} A new string of characters returned by the callback
* function.
*/
FUNCTION mapDomain (string, fn) { var parts = string.split (''@'');
var result = '''';
IF (parts.length > 1) { / / IN email addresses,
ONLY the DOMAIN name should be punycoded. Leave / / the local part (i.e. everything up TO \`@\`) intact. result = parts[0] + ''@'';
string = parts[1];
} / / Avoid \`split(regex)\` FOR IE8 compatibility. See # 17. string = string.replace(regexSeparators, ''\\\\x2E'');
var labels = string.split (''.'');
var encoded = map (labels, fn).
JOIN (''.'');
RETURN result + encoded;
}
/**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see \`punycode.ucs2.encode\`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
FUNCTION ucs2decode (string) { var output =[], counter = 0, length = string.length, value, extra;
while (counter < length) { value = string.charCodeAt (counter + +);
IF (value >= 0xD800 && value <= 0xDBFF && counter < length) { / / high surrogate,
AND there IS a NEXT character extra = string.charCodeAt (counter + +);
IF ((extra & 0xFC00) == 0xDC00) { / / low surrogate output.push (((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
}
ELSE
{ / / unmatched surrogate;
ONLY append this code unit,
IN CASE the NEXT / / code unit IS the high surrogate OF a surrogate pair output.push (value); counter --; } }
ELSE
{ output.push (value); } } RETURN output; }
/**
* Creates a string based on an array of numeric code points.
* @see \`punycode.ucs2.decode\`
* @memberOf punycode.ucs2
* @name encode
* @param {Array} codePoints The array of numeric code points.
* @returns {String} The new Unicode string (UCS-2).
*/
FUNCTION ucs2encode (ARRAY) { RETURN map (ARRAY, FUNCTION (value) { var output = ''''; IF (value > 0xFFFF) { value - = 0x10000; output + = stringFromCharCode (value >> > 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output + = stringFromCharCode (value); RETURN output; }).join(''''); }
/**
* Converts a basic code point into a digit/integer.
* @see \`digitToBasic()\`
* @private
* @param {Number} codePoint The basic numeric code point value.
* @returns {Number} The numeric value of a basic code point (for use in
* representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
* the code point does not represent a value.
*/
FUNCTION basicToDigit (codePoint) { IF (codePoint - 48 < 10) { RETURN codePoint - 22; } IF (codePoint - 65 < 26) { RETURN codePoint - 65; } IF (codePoint - 97 < 26) { RETURN codePoint - 97; } RETURN base; }
/**
* Converts a digit/integer into a basic code point.
* @see \`basicToDigit()\`
* @private
* @param {Number} digit The numeric value of a basic code point.
* @returns {Number} The basic code point whose value (when used for
* representing integers) is \`digit\`, which needs to be in the range
* \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
* used; else, the lowercase form is used. The behavior is undefined
* if \`flag\` is non-zero and \`digit\` has no uppercase form.
*/
FUNCTION digitToBasic (digit, flag) { / / 0..25 map TO ASCII a..z OR A..Z / / 26..35 map TO ASCII 0..9 RETURN digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }
/**
* Bias adaptation function as per section 3.4 of RFC 3492.
* https://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
FUNCTION adapt (delta, numPoints, firstTime) { var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta + = floor(delta / numPoints); FOR (
/* no initialization */
; delta > baseMinusTMin * tMax >> 1; k + = base) { delta = floor(delta / baseMinusTMin); } RETURN floor(k + (baseMinusTMin + 1) * delta / (delta + skew)); }
/**
* Converts a Punycode string of ASCII-only symbols to a string of Unicode
* symbols.
* @memberOf punycode
* @param {String} input The Punycode string of ASCII-only symbols.
* @returns {String} The resulting string of Unicode symbols.
*/
FUNCTION decode(input) { / / Don ''t use UCS-2
var output = [],
inputLength = input.length,
out,
i = 0,
n = initialN,
bias = initialBias,
basic,
j,
index,
oldi,
w,
k,
digit,
t,
/** Cached calculation results */
baseMinusT;
// Handle the basic code points: let \`basic\` be the number of input code
// points before the last delimiter, or \`0\` if there is none, then copy
// the first basic code points to the output.
basic = input.lastIndexOf(delimiter);
if (basic < 0) {
basic = 0;
}
for (j = 0; j < basic; ++j) {
// if it'' s NOT a basic code point IF (input.charCodeAt (j) >= 0x80) { error (''not-basic''); } output.push (input.charCodeAt (j)); } / / Main decoding loop: START just AFTER the LAST DELIMITER IF ANY basic code / / points were copied; START at the beginning otherwise. FOR (INDEX = basic > 0 ? basic + 1 : 0; INDEX < inputLength;
/* no final expression */) { / / \`index\` IS the INDEX OF the NEXT character TO be consumed. / / Decode a generalized variable - length integer INTO \`delta\`, / / which gets added TO \`i\`.The overflow checking IS easier / / IF we increase \`i\` AS we
go, THEN
subtract OFF its starting / / value at the
END TO obtain \`delta\`. FOR (oldi = i, w = 1, k = base;
/* no condition */
;
k + = base) { IF (INDEX >= inputLength) { error (''invalid-input'');
} digit = basicToDigit (input.charCodeAt (INDEX + +));
IF (digit >= base || digit > floor((maxInt - i) / w)) { error (''overflow'');
} i + = digit * w;
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (digit < t) { break;
} baseMinusT = base - t;
IF (w > floor(maxInt / baseMinusT)) { error (''overflow'');
} w *= baseMinusT;
} out = output.length + 1;
bias = adapt (i - oldi, out, oldi == 0);
/ / \`i\` was supposed TO wrap around
FROM
\`out\` TO \`0\`,
/ / incrementing \`n\` EACH time,
so
we ''ll fix that now:
if (floor(i / out) > maxInt - n) {
error('' overflow '');
}
n += floor(i / out);
i %= out;
// Insert \`n\` at position \`i\` of the output
output.splice(i++, 0, n);
}
return ucs2encode(output);
}
/**
* Converts a string of Unicode symbols (e.g. a domain name label) to a
* Punycode string of ASCII-only symbols.
* @memberOf punycode
* @param {String} input The string of Unicode symbols.
* @returns {String} The resulting Punycode string of ASCII-only symbols.
*/
function encode(input) {
var n,
delta,
handledCPCount,
basicLength,
bias,
j,
m,
q,
k,
t,
currentValue,
output = [],
/** \`inputLength\` will hold the number of code points in \`input\`. */
inputLength,
/** Cached calculation results */
handledCPCountPlusOne,
baseMinusT,
qMinusT;
// Convert the input in UCS-2 to Unicode
input = ucs2decode(input);
// Cache the length
inputLength = input.length;
// Initialize the state
n = initialN;
delta = 0;
bias = initialBias;
// Handle the basic code points
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < 0x80) {
output.push(stringFromCharCode(currentValue));
}
}
handledCPCount = basicLength = output.length;
// \`handledCPCount\` is the number of code points that have been handled;
// \`basicLength\` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if (basicLength) {
output.push(delimiter);
}
// Main encoding loop:
while (handledCPCount < inputLength) {
// All non-basic code points < n have been handled already. Find the next
// larger one:
for (m = maxInt, j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue >= n && currentValue < m) {
m = currentValue;
}
}
// Increase \`delta\` enough to advance the decoder'' s < n,
i > state TO < m,
0 >,
/ / but guard against overflow handledCPCountPlusOne = handledCPCount + 1;
IF (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error (''overflow'');
} delta + = (m - n) * handledCPCountPlusOne;
n = m;
FOR (j = 0;
j < inputLength;
+ + j) { currentValue = input[j];
IF (currentValue < n && + + delta > maxInt) { error (''overflow'');
} IF (currentValue == n) { / / Represent delta AS a generalized variable - length integer FOR (q = delta,
k = base;
/* no condition */
;
k + = base) { t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (q < t) { break;
} qMinusT = q - t;
baseMinusT = base - t;
output.push (stringFromCharCode (digitToBasic (t + qMinusT % baseMinusT, 0)));
q = floor(qMinusT / baseMinusT);
} output.push (stringFromCharCode (digitToBasic (q, 0)));
bias = adapt (delta, handledCPCountPlusOne, handledCPCount == basicLength);
delta = 0;
+ + handledCPCount;
} } + + delta;
+ + n;
} RETURN output.join ('''');
}
/**
* Converts a Punycode string representing a domain name or an email address
* to Unicode. Only the Punycoded parts of the input will be converted, i.e.
* it doesn''t matter if you call it on a string that has already been
* converted to Unicode.
* @memberOf punycode
* @param {String} input The Punycoded domain name or email address to
* convert to Unicode.
* @returns {String} The Unicode representation of the given Punycode
* string.
*/
FUNCTION toUnicode (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexPunycode.test (string) ? decode(string.slice (4).toLowerCase ()) : string;
});
}
/**
* Converts a Unicode string representing a domain name or an email address to
* Punycode. Only the non-ASCII parts of the domain name will be converted,
* i.e. it doesn''t matter if you call it with a domain that''s already in
* ASCII.
* @memberOf punycode
* @param {String} input The domain name or email address to convert, as a
* Unicode string.
* @returns {String} The Punycode representation of the given domain name or
* email address.
*/
FUNCTION toASCII (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexNonASCII.test (string) ? ''xn--'' + encode(string) : string;
});
}
/*--------------------------------------------------------------------------*/
/** Define the public API */
punycode = {
/**
* A string representing the current Punycode.js version number.
* @memberOf punycode
* @type String
*/
''version'' :''1.4.1'',
/**
* An object of methods to convert from JavaScript''s internal character
* representation (UCS-2) to Unicode code points, and back.
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode
* @type Object
*/
''ucs2'' : { ''decode'' : ucs2decode,
''encode'' : ucs2encode },
''decode'' : decode,
''encode'' : encode,
''toASCII'' : toASCII,
''toUnicode'' : toUnicode };
/** Expose \`punycode\` */
/ / SOME AMD build optimizers,
LIKE r.js,
CHECK FOR specific condition patterns / / LIKE the following: IF (typeof define == ''function'' && typeof define.amd == ''object'' && define.amd) { define (''punycode'', FUNCTION () { RETURN punycode;
});
}
ELSE
IF (freeExports && freeModule) { IF (module.exports == freeExports) { / / IN Node.js,
io.js,
OR RingoJS v0.8.0 + freeModule.exports = punycode;
}
ELSE
{ / / IN Narwhal
OR RingoJS v0.7.0 - FOR (KEY IN punycode) { punycode.hasOwnProperty (KEY) && (freeExports[KEY] = punycode[KEY]);
} } }
ELSE
{ / / IN Rhino
OR a web browser root.punycode = punycode;
} }(this));
}).call(this,
typeof global != = \\"undefined\\" ? global : typeof self != = \\"undefined\\" ? self : typeof
WINDOW != = \\"undefined\\" ?
WINDOW : {}) },
{}],
2:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
/ / IF obj.hasOwnProperty has been overridden,
THEN
calling / / obj.hasOwnProperty (prop) will break. / / See: https: / / github.com / joyent / node / issues / 1707 FUNCTION hasOwnProperty (obj, prop) { RETURN Object.prototype.hasOwnProperty.call (obj, prop);
} module.exports = FUNCTION (qs, sep, eq, options) { sep = sep || ''&'';
eq = eq || ''='';
var obj = {};
IF (typeof qs != = ''string'' || qs.length == = 0) { RETURN obj;
} var regexp = / + / g;
qs = qs.split (sep);
var maxKeys = 1000;
IF (options && typeof options.maxKeys == = ''number'') { maxKeys = options.maxKeys;
} var len = qs.length;
/ / maxKeys <= 0 means that we should NOT
LIMIT keys count IF (maxKeys > 0 && len > maxKeys) { len = maxKeys;
} FOR (var i = 0;
i < len;
+ + i) { var x = qs[i].replace(regexp, ''%20''),
idx = x.indexOf (eq),
kstr,
vstr,
k,
v;
IF (idx >= 0) { kstr = x.substr(0, idx);
vstr = x.substr(idx + 1);
}
ELSE
{ kstr = x;
vstr = '''';
} k = decodeURIComponent (kstr);
v = decodeURIComponent (vstr);
IF (! hasOwnProperty (obj, k)) { obj[k] = v;
}
ELSE
IF (isArray (obj[k])) { obj[k].push (v);
}
ELSE
{ obj[k] =[obj[k], v];
} } RETURN obj;
};
var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]'';
};
},
{}],
3:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
var stringifyPrimitive = FUNCTION (v) { switch (typeof v) { CASE ''string'' : RETURN v; CASE ''boolean'' : RETURN v ? ''true'' :''false''; CASE ''number'' : RETURN isFinite(v) ? v : ''''; default: RETURN ''''; } }; module.exports = FUNCTION (obj, sep, eq, name) { sep = sep || ''&''; eq = eq || ''=''; IF (obj == = NULL) { obj = undefined; } IF (typeof obj == = ''object'') { RETURN map (objectKeys (obj), FUNCTION (k) { var ks = encodeURIComponent (stringifyPrimitive (k)) + eq; IF (isArray (obj[k])) { RETURN map (obj[k], FUNCTION (v) { RETURN ks + encodeURIComponent (stringifyPrimitive (v)); }).join(sep); }
ELSE
{ RETURN ks + encodeURIComponent (stringifyPrimitive (obj[k])); } }).join(sep); } IF (! name)
RETURN ''''; RETURN encodeURIComponent (stringifyPrimitive (name)) + eq + encodeURIComponent (stringifyPrimitive (obj)); }; var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]''; }; FUNCTION map (xs, f) { IF (xs.map)
RETURN xs.map (f); var res =[]; FOR (var i = 0; i < xs.length; i + +) { res.push (f (xs[i], i)); } RETURN res; } var objectKeys = Object.keys || FUNCTION (obj) { var res =[]; FOR (var KEY IN obj) { IF (Object.prototype.hasOwnProperty.call (obj, KEY)) res.push (KEY); } RETURN res; }; }, {}], 4:[FUNCTION (require, module, exports) { ''use strict''; exports.decode = exports.parse = require (''./decode''); exports.encode = exports.stringify = require (''./encode''); }, {\\". / decode \\":2,\\"./ encode \\":3}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\" Software \\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\" AS IS
\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
''use strict'';
var punycode = require(''punycode'');
var util = require(''./util'');
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
this.protocol = null;
this.slashes = null;
this.auth = null;
this.host = null;
this.port = null;
this.hostname = null;
this.hash = null;
this.search = null;
this.query = null;
this.pathname = null;
this.path = null;
this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
portPattern = /:[0-9]*$/,
// Special case for a simple path URL
simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,
// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = [''<'', ''>'', ''\\" '', '' \`'', '' '', ''\\\\r'', ''\\\\n'', ''\\\\t''],
// RFC 2396: characters not allowed for various reasons.
unwise = [''{'', ''}'', ''|'', ''\\\\\\\\'', ''^'', ''\` ''].concat(delims),
// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['' \\\\'' ''].concat(unwise),
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['' % '', '' / '', '' ? '', ''; '', '' # ''].concat(autoEscape),
hostEndingChars = ['' / '', '' ? '', '' # ''],
hostnameMaxLen = 255,
hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
// protocols that can allow \\"unsafe\\" and \\"unwise\\" chars.
unsafeProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that never have a hostname.
hostlessProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that always contain a // bit.
slashedProtocol = {
'' http '': true,
'' https '': true,
'' ftp '': true,
'' gopher '': true,
'' file '': true,
'' http: '': true,
'' https: '': true,
'' ftp: '': true,
'' gopher: '': true,
'' file: '': true
},
querystring = require('' querystring '');
function urlParse(url, parseQueryString, slashesDenoteHost) {
if (url && util.isObject(url) && url instanceof Url) return url;
var u = new Url;
u.parse(url, parseQueryString, slashesDenoteHost);
return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
if (!util.isString(url)) {
throw new TypeError(\\"Parameter '' url '' must be a string, not \\" + typeof url);
}
// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex = url.indexOf('' ? ''),
splitter =
(queryIndex !== -1 && queryIndex < url.indexOf('' # '')) ? '' ? '' : '' # '',
uSplit = url.split(splitter),
slashRegex = /\\\\\\\\/g;
uSplit[0] = uSplit[0].replace(slashRegex, '' / '');
url = uSplit.join(splitter);
var rest = url;
// trim before proceeding.
// This is to support parse stuff like \\"  http://foo.com  \\\\n\\"
rest = rest.trim();
if (!slashesDenoteHost && url.split('' # '').length === 1) {
// Try fast path regexp
var simplePath = simplePathPattern.exec(rest);
if (simplePath) {
this.path = rest;
this.href = rest;
this.pathname = simplePath[1];
if (simplePath[2]) {
this.search = simplePath[2];
if (parseQueryString) {
this.query = querystring.parse(this.search.substr(1));
} else {
this.query = this.search.substr(1);
}
} else if (parseQueryString) {
this.search = '''';
this.query = {};
}
return this;
}
}
var proto = protocolPattern.exec(rest);
if (proto) {
proto = proto[0];
var lowerProto = proto.toLowerCase();
this.protocol = lowerProto;
rest = rest.substr(proto.length);
}
// figure out if it'' s got a host / / user@server
IS * always * interpreted AS a hostname, AND url / / resolution will treat / / foo / bar AS host = foo, path = bar because that ''s
// how the browser resolves relative URLs.
if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {
var slashes = rest.substr(0, 2) === '' / / '';
if (slashes && !(proto && hostlessProtocol[proto])) {
rest = rest.substr(2);
this.slashes = true;
}
}
if (!hostlessProtocol[proto] &&
(slashes || (proto && !slashedProtocol[proto]))) {
// there'' s a hostname. / / the FIRST instance OF /, ?,;, OR # ends the host. / / / / IF there IS an @ IN the hostname, THEN
non - host chars * are * allowed / / TO the
LEFT OF the LAST @ sign, unless SOME host - ending character / / comes * BEFORE * the @ - sign. / / URLs are obnoxious. / / / / ex: / / http: / / a@b@c / => user:a@b host:c / / http: / / a@b ? @c => user:a host:c path: / ? @c / / v0.12 TODO (isaacs) : This IS NOT quite how Chrome does things. / / Review our test CASE against browsers more comprehensively. / / find the FIRST instance OF ANY hostEndingChars var hostEnd = - 1; FOR (var i = 0; i < hostEndingChars.length; i + +) { var hec = rest.indexOf (hostEndingChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / at this point, either we have an explicit point
WHERE
the / / auth portion cannot go past, OR the LAST @ char IS the decider. var auth, atSign; IF (hostEnd == = - 1) { / / atSign can be anywhere. atSign = rest.lastIndexOf (''@''); }
ELSE
{ / / atSign must be IN auth portion. / / http: / / a@b / c@d => host:b auth:a path: / c@d atSign = rest.lastIndexOf (''@'', hostEnd); } / / Now we have a portion which IS definitely the auth. / / Pull that off. IF (atSign != = - 1) { auth = rest.slice (0, atSign); rest = rest.slice (atSign + 1); this.auth = decodeURIComponent (auth); } / / the host IS the remaining TO the
LEFT OF the FIRST non - host char hostEnd = - 1; FOR (var i = 0; i < nonHostChars.length; i + +) { var hec = rest.indexOf (nonHostChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / IF we still have NOT hit it, THEN
the entire thing IS a host. IF (hostEnd == = - 1) hostEnd = rest.length; this.host = rest.slice (0, hostEnd); rest = rest.slice (hostEnd); / / pull out port. this.parseHost (); / / we ''ve indicated that there is a hostname,
// so even if it'' s empty, it has TO be present. this.hostname = this.hostname || ''''; / / IF hostname begins WITH[ AND ends WITH] / / assume that it ''s an IPv6 address.
var ipv6Hostname = this.hostname[0] === ''['' &&
this.hostname[this.hostname.length - 1] === ''] '';
// validate a little.
if (!ipv6Hostname) {
var hostparts = this.hostname.split(/\\\\./);
for (var i = 0, l = hostparts.length; i < l; i++) {
var part = hostparts[i];
if (!part) continue;
if (!part.match(hostnamePartPattern)) {
var newpart = '''';
for (var j = 0, k = part.length; j < k; j++) {
if (part.charCodeAt(j) > 127) {
// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart += '' x '';
} else {
newpart += part[j];
}
}
// we test again with ASCII char only
if (!newpart.match(hostnamePartPattern)) {
var validParts = hostparts.slice(0, i);
var notHost = hostparts.slice(i + 1);
var bit = part.match(hostnamePartStart);
if (bit) {
validParts.push(bit[1]);
notHost.unshift(bit[2]);
}
if (notHost.length) {
rest = '' / '' + notHost.join(''.'') + rest;
}
this.hostname = validParts.join(''.'');
break;
}
}
}
}
if (this.hostname.length > hostnameMaxLen) {
this.hostname = '''';
} else {
// hostnames are always lower case.
this.hostname = this.hostname.toLowerCase();
}
if (!ipv6Hostname) {
// IDNA Support: Returns a punycoded representation of \\"domain\\".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn'' t matter IF / / you CALL it WITH a DOMAIN that already IS ASCII - only. this.hostname = punycode.toASCII (
this.hostname); } var p = this.port ? '':'' + this.port : ''''; var h = this.hostname || ''''; this.host = h + p; this.href + = this.host; / / strip[ AND] FROM the hostname / / the host field still retains them, though IF (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); IF (rest[0] != = ''/'') { rest = ''/'' + rest; } } } / / now rest IS SET TO the post - host stuff. / / chop OFF ANY delim chars. IF (! unsafeProtocol[lowerProto]) { / / FIRST, make 100 % sure that ANY \\"autoEscape\\" chars get / / escaped, even IF encodeURIComponent doesn ''t think they
// need to be.
for (var i = 0, l = autoEscape.length; i < l; i++) {
var ae = autoEscape[i];
if (rest.indexOf(ae) === -1)
continue;
var esc = encodeURIComponent(ae);
if (esc === ae) {
esc = escape(ae);
}
rest = rest.split(ae).join(esc);
}
}
// chop off from the tail first.
var hash = rest.indexOf('' # '');
if (hash !== -1) {
// got a fragment string.
this.hash = rest.substr(hash);
rest = rest.slice(0, hash);
}
var qm = rest.indexOf('' ? '');
if (qm !== -1) {
this.search = rest.substr(qm);
this.query = rest.substr(qm + 1);
if (parseQueryString) {
this.query = querystring.parse(this.query);
}
rest = rest.slice(0, qm);
} else if (parseQueryString) {
// no query string, but parseQueryString still requested
this.search = '''';
this.query = {};
}
if (rest) this.pathname = rest;
if (slashedProtocol[lowerProto] &&
this.hostname && !this.pathname) {
this.pathname = '' / '';
}
//to support http.request
if (this.pathname || this.search) {
var p = this.pathname || '''';
var s = this.search || '''';
this.path = p + s;
}
// finally, reconstruct the href based on what has been validated.
this.href = this.format();
return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
// ensure it'' s an object, AND NOT a string url. / / IF it ''s an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if (util.isString(obj)) obj = urlParse(obj);
if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
return obj.format();
}
Url.prototype.format = function() {
var auth = this.auth || '''';
if (auth) {
auth = encodeURIComponent(auth);
auth = auth.replace(/%3A/i, '' : '');
auth += '' @ '';
}
var protocol = this.protocol || '''',
pathname = this.pathname || '''',
hash = this.hash || '''',
host = false,
query = '''';
if (this.host) {
host = auth + this.host;
} else if (this.hostname) {
host = auth + (this.hostname.indexOf('' : '') === -1 ?
this.hostname :
''['' + this.hostname + ''] '');
if (this.port) {
host += '' : '' + this.port;
}
}
if (this.query &&
util.isObject(this.query) &&
Object.keys(this.query).length) {
query = querystring.stringify(this.query);
}
var search = this.search || (query && ('' ? '' + query)) || '''';
if (protocol && protocol.substr(-1) !== '' :'') protocol += '' : '';
// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if (this.slashes ||
(!protocol || slashedProtocol[protocol]) && host !== false) {
host = '' / / '' + (host || '''');
if (pathname && pathname.charAt(0) !== '' / '') pathname = '' / '' + pathname;
} else if (!host) {
host = '''';
}
if (hash && hash.charAt(0) !== '' # '') hash = '' # '' + hash;
if (search && search.charAt(0) !== '' ? '') search = '' ? '' + search;
pathname = pathname.replace(/[?#]/g, function(match) {
return encodeURIComponent(match);
});
search = search.replace('' # '', '' % 23 '');
return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
if (!source) return relative;
return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
if (util.isString(relative)) {
var rel = new Url();
rel.parse(relative, false, true);
relative = rel;
}
var result = new Url();
var tkeys = Object.keys(this);
for (var tk = 0; tk < tkeys.length; tk++) {
var tkey = tkeys[tk];
result[tkey] = this[tkey];
}
// hash is always overridden, no matter what.
// even href=\\"\\" will remove it.
result.hash = relative.hash;
// if the relative url is empty, then there'' s NOTHING
LEFT TO DO here. IF (relative.href == = '''') { result.href = result.format(); RETURN result; } / / hrefs LIKE / / foo / bar always cut TO the protocol. IF (relative.slashes && ! relative.protocol) { / / take everything
EXCEPT
the protocol FROM relative var rkeys = Object.keys (relative); FOR (var rk = 0; rk < rkeys.length; rk + +) { var rkey = rkeys[rk]; IF (rkey != = ''protocol'') result[rkey] = relative[rkey]; } / / urlParse appends TRAILING / TO urls LIKE http: / / www.example.com IF (slashedProtocol[result.protocol] && result.hostname && ! result.pathname) { result.path = result.pathname = ''/''; } result.href = result.format(); RETURN result; } IF (relative.protocol && relative.protocol != = result.protocol) { / / IF it ''s a known url protocol, then changing
// the protocol does weird things
// first, if it'' s NOT file:, THEN
we MUST have a host, / /
AND IF there was a path / / TO
BEGIN
WITH,
THEN
we MUST have a path. / / IF it IS file:,
THEN
the host IS dropped,
/ / because that ''s known to be hostless.
// anything else is assumed to be absolute.
if (!slashedProtocol[relative.protocol]) {
var keys = Object.keys(relative);
for (var v = 0; v < keys.length; v++) {
var k = keys[v];
result[k] = relative[k];
}
result.href = result.format();
return result;
}
result.protocol = relative.protocol;
if (!relative.host && !hostlessProtocol[relative.protocol]) {
var relPath = (relative.pathname || '''').split('' / '');
while (relPath.length && !(relative.host = relPath.shift()));
if (!relative.host) relative.host = '''';
if (!relative.hostname) relative.hostname = '''';
if (relPath[0] !== '''') relPath.unshift('''');
if (relPath.length < 2) relPath.unshift('''');
result.pathname = relPath.join('' / '');
} else {
result.pathname = relative.pathname;
}
result.search = relative.search;
result.query = relative.query;
result.host = relative.host || '''';
result.auth = relative.auth;
result.hostname = relative.hostname || relative.host;
result.port = relative.port;
// to support http.request
if (result.pathname || result.search) {
var p = result.pathname || '''';
var s = result.search || '''';
result.path = p + s;
}
result.slashes = result.slashes || relative.slashes;
result.href = result.format();
return result;
}
var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '' / ''),
isRelAbs = (
relative.host ||
relative.pathname && relative.pathname.charAt(0) === '' / ''
),
mustEndAbs = (isRelAbs || isSourceAbs ||
(result.host && relative.pathname)),
removeAllDots = mustEndAbs,
srcPath = result.pathname && result.pathname.split('' / '') || [],
relPath = relative.pathname && relative.pathname.split('' / '') || [],
psychotic = result.protocol && !slashedProtocol[result.protocol];
// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if (psychotic) {
result.hostname = '''';
result.port = null;
if (result.host) {
if (srcPath[0] === '''') srcPath[0] = result.host;
else srcPath.unshift(result.host);
}
result.host = '''';
if (relative.protocol) {
relative.hostname = null;
relative.port = null;
if (relative.host) {
if (relPath[0] === '''') relPath[0] = relative.host;
else relPath.unshift(relative.host);
}
relative.host = null;
}
mustEndAbs = mustEndAbs && (relPath[0] === '''' || srcPath[0] === '''');
}
if (isRelAbs) {
// it'' s absolute. result.host = (
relative.host || relative.host == = '''') ? relative.host : result.host; result.hostname = (relative.hostname || relative.hostname == = '''') ? relative.hostname : result.hostname; result.search = relative.search; result.query = relative.query; srcPath = relPath; / / fall through TO the dot - handling below. }
ELSE
IF (relPath.length) { / / it ''s relative
// throw away the existing file, and take the new path instead.
if (!srcPath) srcPath = [];
srcPath.pop();
srcPath = srcPath.concat(relPath);
result.search = relative.search;
result.query = relative.query;
} else if (!util.isNullOrUndefined(relative.search)) {
// just pull out the search.
// like href='' ? foo ''.
// Put this after the other two cases because it simplifies the booleans
if (psychotic) {
result.hostname = result.host = srcPath.shift();
//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('' mailto:local1@domain1 '', '' local2@domain2 '')
var authInHost = result.host && result.host.indexOf('' @ '') > 0 ?
result.host.split('' @ '') : false;
if (authInHost) {
result.auth = authInHost.shift();
result.host = result.hostname = authInHost.shift();
}
}
result.search = relative.search;
result.query = relative.query;
//to support http.request
if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
result.path = (result.pathname ? result.pathname : '''') +
(result.search ? result.search : '''');
}
result.href = result.format();
return result;
}
if (!srcPath.length) {
// no path at all.  easy.
// we'' ve already handled the other stuff above. result.pathname = NULL; / / TO support http.request IF (result.search) { result.path = ''/'' + result.search; }
ELSE
{ result.path = NULL; } result.href = result.format(); RETURN result; } / / IF a url ENDs IN. OR.., THEN
it must get a TRAILING slash. / / however, IF it ends IN anything
ELSE
non - slashy, / / THEN
it must NOT get a TRAILING slash. var LAST = srcPath.slice (- 1)[0]; var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (LAST == = ''.'' || LAST == = ''..'') || LAST == = ''''); / / strip single dots, resolve double dots TO parent dir / / IF the path tries TO go above the root, \`up\` ends up > 0 var up = 0; FOR (var i = srcPath.length; i >= 0; i --) { LAST = srcPath[i]; IF (LAST == = ''.'') { srcPath.splice (i, 1); }
ELSE
IF (LAST == = ''..'') { srcPath.splice (i, 1); up + +; }
ELSE
IF (up) { srcPath.splice (i, 1); up --; } } / / IF the path IS allowed TO go above the root, restore LEADING..s IF (! mustEndAbs && ! removeAllDots) { FOR (;up --; up) { srcPath.unshift (''..''); } } IF (mustEndAbs && srcPath[0] != = '''' && (! srcPath[0] || srcPath[0].charAt (0) != = ''/'')) { srcPath.unshift (''''); } IF (hasTrailingSlash && (srcPath.join (''/'').substr(- 1) != = ''/'')) { srcPath.push (''''); } var isAbsolute = srcPath[0] == = '''' || (srcPath[0] && srcPath[0].charAt (0) == = ''/''); / / put the host back IF (psychotic) { result.hostname = result.host = isAbsolute ? '''' : srcPath.length ? srcPath.shift () : ''''; / / occationaly the auth can get stuck ONLY IN host / / this especially happens IN cases LIKE / / url.resolveObject (''mailto:local1@domain1'', ''local2@domain2'') var authInHost = result.host && result.host.indexOf (''@'') > 0 ? result.host.split (''@'') : FALSE; IF (authInHost) { result.auth = authInHost.shift (); result.host = result.hostname = authInHost.shift (); } } mustEndAbs = mustEndAbs || (result.host && srcPath.length); IF (mustEndAbs && ! isAbsolute) { srcPath.unshift (''''); } IF (! srcPath.length) { result.pathname = NULL; result.path = NULL; }
ELSE
{ result.pathname = srcPath.join (''/''); } / / TO support request.http IF (! util.isNull (result.pathname) || ! util.isNull (result.search)) { result.path = (result.pathname ? result.pathname : '''') + (result.search ? result.search : ''''); } result.auth = relative.auth || result.auth; result.slashes = result.slashes || relative.slashes; result.href = result.format(); RETURN result; }; Url.prototype.parseHost = FUNCTION () { var host = this.host; var port = portPattern.exec (host); IF (port) { port = port[0]; IF (port != = '':'') { this.port = port.substr(1); } host = host.substr(0, host.length - port.length); } IF (host) this.hostname = host; }; }, {\\". / util \\":6,\\" punycode \\":1,\\" querystring \\":4}],6:[function(require,module,exports){
''use strict'';
module.exports = {
isString: function(arg) {
return typeof(arg) === ''string'';
},
isObject: function(arg) {
return typeof(arg) === ''object'' && arg !== null;
},
isNull: function(arg) {
return arg === null;
},
isNullOrUndefined: function(arg) {
return arg == null;
}
};
},{}],7:[function(require,module,exports){
module.exports = require(''ajv'');
},{\\" ajv \\":9}],8:[function(require,module,exports){
''use strict'';
var KEYWORDS = [
''multipleOf'',
''maximum'',
''exclusiveMaximum'',
''minimum'',
''exclusiveMinimum'',
''maxLength'',
''minLength'',
''pattern'',
''additionalItems'',
''maxItems'',
''minItems'',
''uniqueItems'',
''maxProperties'',
''minProperties'',
''required'',
''additionalProperties'',
''enum'',
''format'',
''const''
];
module.exports = function (metaSchema, keywordsJsonPointers) {
for (var i=0; i<keywordsJsonPointers.length; i++) {
metaSchema = JSON.parse(JSON.stringify(metaSchema));
var segments = keywordsJsonPointers[i].split(''/'');
var keywords = metaSchema;
var j;
for (j=1; j<segments.length; j++)
keywords = keywords[segments[j]];
for (j=0; j<KEYWORDS.length; j++) {
var key = KEYWORDS[j];
var schema = keywords[key];
if (schema) {
keywords[key] = {
anyOf: [
schema,
{ $ref: ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
}
}
return metaSchema;
};
},{}],9:[function(require,module,exports){
''use strict'';
var compileSchema = require(''./compile'')
, resolve = require(''./compile/resolve'')
, Cache = require(''./cache'')
, SchemaObject = require(''./compile/schema_obj'')
, stableStringify = require(''json-stable-stringify'')
, formats = require(''./compile/formats'')
, rules = require(''./compile/rules'')
, $dataMetaSchema = require(''./$data'')
, patternGroups = require(''./patternGroups'')
, util = require(''./compile/util'')
, co = require(''co'');
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require(''./compile/async'');
var customKeyword = require(''./keyword'');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
var errorClasses = require(''./compile/error_classes'');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
var META_IGNORE_OPTIONS = [ ''removeAdditional'', ''useDefaults'', ''coerceTypes'' ];
var META_SUPPORT_DATA = [''/properties''];
/**
* Creates validator instance.
* Usage: \`Ajv(opts)\`
* @param {Object} opts optional options
* @return {Object} ajv instance
*/
function Ajv(opts) {
if (!(this instanceof Ajv)) return new Ajv(opts);
opts = this._opts = util.copy(opts) || {};
this._schemas = {};
this._refs = {};
this._fragments = {};
this._formats = formats(opts.format);
var schemaUriFormat = this._schemaUriFormat = this._formats[''uri-reference''];
this._schemaUriFormatFunc = function (str) { return schemaUriFormat.test(str); };
this._cache = opts.cache || new Cache;
this._loadingSchemas = {};
this._compilations = [];
this.RULES = rules();
this._getId = chooseGetId(opts);
opts.loopRequired = opts.loopRequired || Infinity;
if (opts.errorDataPath == ''property'') opts._errorDataPathProperty = true;
if (opts.serialize === undefined) opts.serialize = stableStringify;
this._metaOpts = getMetaSchemaOptions(this);
if (opts.formats) addInitialFormats(this);
addDraft6MetaSchema(this);
if (typeof opts.meta == ''object'') this.addMetaSchema(opts.meta);
addInitialSchemas(this);
if (opts.patternGroups) patternGroups(this);
}
/**
* Validate data using schema
* Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
* @this   Ajv
* @param  {String|Object} schemaKeyRef key, ref or schema object
* @param  {Any} data to be validated
* @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
*/
function validate(schemaKeyRef, data) {
var v;
if (typeof schemaKeyRef == ''string'') {
v = this.getSchema(schemaKeyRef);
if (!v) throw new Error(''no schema with key or ref \\" '' + schemaKeyRef + '' \\"'');
} else {
var schemaObj = this._addSchema(schemaKeyRef);
v = schemaObj.validate || this._compile(schemaObj);
}
var valid = v(data);
if (v.$async === true)
return this._opts.async == ''*'' ? co(valid) : valid;
this.errors = v.errors;
return valid;
}
/**
* Create validating function for passed schema.
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
* @return {Function} validating function
*/
function compile(schema, _meta) {
var schemaObj = this._addSchema(schema, undefined, _meta);
return schemaObj.validate || this._compile(schemaObj);
}
/**
* Adds schema to the instance.
* @this   Ajv
* @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
* @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
* @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
* @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
*/
function addSchema(schema, key, _skipValidation, _meta) {
if (Array.isArray(schema)){
for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
return;
}
var id = this._getId(schema);
if (id !== undefined && typeof id != ''string'')
throw new Error(''schema id must be string'');
key = resolve.normalizeId(key || id);
checkUnique(this, key);
this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
}
/**
* Add schema that will be used to validate other schemas
* options in META_IGNORE_OPTIONS are alway set to false
* @this   Ajv
* @param {Object} schema schema object
* @param {String} key optional schema key
* @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
*/
function addMetaSchema(schema, key, skipValidation) {
this.addSchema(schema, key, skipValidation, true);
}
/**
* Validate schema
* @this   Ajv
* @param {Object} schema schema to validate
* @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
* @return {Boolean} true if schema is valid
*/
function validateSchema(schema, throwOrLogError) {
var $schema = schema.$schema;
if ($schema !== undefined && typeof $schema != ''string'')
throw new Error(''$schema must be a string'');
$schema = $schema || this._opts.defaultMeta || defaultMeta(this);
if (!$schema) {
console.warn(''meta-schema not available'');
this.errors = null;
return true;
}
var currentUriFormat = this._formats.uri;
this._formats.uri = typeof currentUriFormat == ''function''
? this._schemaUriFormatFunc
: this._schemaUriFormat;
var valid;
try { valid = this.validate($schema, schema); }
finally { this._formats.uri = currentUriFormat; }
if (!valid && throwOrLogError) {
var message = ''schema is invalid: '' + this.errorsText();
if (this._opts.validateSchema == ''log'') console.error(message);
else throw new Error(message);
}
return valid;
}
function defaultMeta(self) {
var meta = self._opts.meta;
self._opts.defaultMeta = typeof meta == ''object''
? self._getId(meta) || meta
: self.getSchema(META_SCHEMA_ID)
? META_SCHEMA_ID
: undefined;
return self._opts.defaultMeta;
}
/**
* Get compiled schema from the instance by \`key\` or \`ref\`.
* @this   Ajv
* @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
* @return {Function} schema validating function (with property \`schema\`).
*/
function getSchema(keyRef) {
var schemaObj = _getSchemaObj(this, keyRef);
switch (typeof schemaObj) {
case ''object'': return schemaObj.validate || this._compile(schemaObj);
case ''string'': return this.getSchema(schemaObj);
case ''undefined'': return _getSchemaFragment(this, keyRef);
}
}
function _getSchemaFragment(self, ref) {
var res = resolve.schema.call(self, { schema: {} }, ref);
if (res) {
var schema = res.schema
, root = res.root
, baseId = res.baseId;
var v = compileSchema.call(self, schema, root, undefined, baseId);
self._fragments[ref] = new SchemaObject({
ref: ref,
fragment: true,
schema: schema,
root: root,
baseId: baseId,
validate: v
});
return v;
}
}
function _getSchemaObj(self, keyRef) {
keyRef = resolve.normalizeId(keyRef);
return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
* Remove cached schema(s).
* If no parameter is passed all schemas but meta-schemas are removed.
* If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
* Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
* @this   Ajv
* @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
*/
function removeSchema(schemaKeyRef) {
if (schemaKeyRef instanceof RegExp) {
_removeAllSchemas(this, this._schemas, schemaKeyRef);
_removeAllSchemas(this, this._refs, schemaKeyRef);
return;
}
switch (typeof schemaKeyRef) {
case ''undefined'':
_removeAllSchemas(this, this._schemas);
_removeAllSchemas(this, this._refs);
this._cache.clear();
return;
case ''string'':
var schemaObj = _getSchemaObj(this, schemaKeyRef);
if (schemaObj) this._cache.del(schemaObj.cacheKey);
delete this._schemas[schemaKeyRef];
delete this._refs[schemaKeyRef];
return;
case ''object'':
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
this._cache.del(cacheKey);
var id = this._getId(schemaKeyRef);
if (id) {
id = resolve.normalizeId(id);
delete this._schemas[id];
delete this._refs[id];
}
}
}
function _removeAllSchemas(self, schemas, regex) {
for (var keyRef in schemas) {
var schemaObj = schemas[keyRef];
if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
self._cache.del(schemaObj.cacheKey);
delete schemas[keyRef];
}
}
}
/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
if (typeof schema != ''object'' && typeof schema != ''boolean'')
throw new Error(''schema should be object or boolean'');
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schema) : schema;
var cached = this._cache.get(cacheKey);
if (cached) return cached;
shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
var id = resolve.normalizeId(this._getId(schema));
if (id && shouldAddSchema) checkUnique(this, id);
var willValidate = this._opts.validateSchema !== false && !skipValidation;
var recursiveMeta;
if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
this.validateSchema(schema, true);
var localRefs = resolve.ids.call(this, schema);
var schemaObj = new SchemaObject({
id: id,
schema: schema,
localRefs: localRefs,
cacheKey: cacheKey,
meta: meta
});
if (id[0] != ''#'' && shouldAddSchema) this._refs[id] = schemaObj;
this._cache.put(cacheKey, schemaObj);
if (willValidate && recursiveMeta) this.validateSchema(schema, true);
return schemaObj;
}
/* @this   Ajv */
function _compile(schemaObj, root) {
if (schemaObj.compiling) {
schemaObj.validate = callValidate;
callValidate.schema = schemaObj.schema;
callValidate.errors = null;
callValidate.root = root ? root : callValidate;
if (schemaObj.schema.$async === true)
callValidate.$async = true;
return callValidate;
}
schemaObj.compiling = true;
var currentOpts;
if (schemaObj.meta) {
currentOpts = this._opts;
this._opts = this._metaOpts;
}
var v;
try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
finally {
schemaObj.compiling = false;
if (schemaObj.meta) this._opts = currentOpts;
}
schemaObj.validate = v;
schemaObj.refs = v.refs;
schemaObj.refVal = v.refVal;
schemaObj.root = v.root;
return v;
function callValidate() {
var _validate = schemaObj.validate;
var result = _validate.apply(null, arguments);
callValidate.errors = _validate.errors;
return result;
}
}
function chooseGetId(opts) {
switch (opts.schemaId) {
case ''$id'': return _get$Id;
case ''id'': return _getId;
default: return _get$IdOrId;
}
}
function _getId(schema) {
if (schema.$id) console.warn(''schema $id ignored'', schema.$id);
return schema.id;
}
function _get$Id(schema) {
if (schema.id) console.warn(''schema id ignored'', schema.id);
return schema.$id;
}
function _get$IdOrId(schema) {
if (schema.$id && schema.id && schema.$id != schema.id)
throw new Error(''schema $id is different from id'');
return schema.$id || schema.id;
}
/**
* Convert array of error message objects to string
* @this   Ajv
* @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
* @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
* @return {String} human readable string with all errors descriptions
*/
function errorsText(errors, options) {
errors = errors || this.errors;
if (!errors) return ''No errors'';
options = options || {};
var separator = options.separator === undefined ? '', '' : options.separator;
var dataVar = options.dataVar === undefined ? ''data'' : options.dataVar;
var text = '''';
for (var i=0; i<errors.length; i++) {
var e = errors[i];
if (e) text += dataVar + e.dataPath + '' '' + e.message + separator;
}
return text.slice(0, -separator.length);
}
/**
* Add custom format
* @this   Ajv
* @param {String} name format name
* @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
*/
function addFormat(name, format) {
if (typeof format == ''string'') format = new RegExp(format);
this._formats[name] = format;
}
function addDraft6MetaSchema(self) {
var $dataSchema;
if (self._opts.$data) {
$dataSchema = require(''./refs/$data.json'');
self.addMetaSchema($dataSchema, $dataSchema.$id, true);
}
if (self._opts.meta === false) return;
var metaSchema = require(''./refs/json-schema-draft-06.json'');
if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
self._refs[''http://json-schema.org/schema''] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
var optsSchemas = self._opts.schemas;
if (!optsSchemas) return;
if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
for (var name in self._opts.formats) {
var format = self._opts.formats[name];
self.addFormat(name, format);
}
}
function checkUnique(self, id) {
if (self._schemas[id] || self._refs[id])
throw new Error(''schema with key or id \\" '' + id + '' \\" already exists'');
}
function getMetaSchemaOptions(self) {
var metaOpts = util.copy(self._opts);
for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
delete metaOpts[META_IGNORE_OPTIONS[i]];
return metaOpts;
}
},{\\"./ $ data \\":8,\\"./
CACHE \\":10,\\"./ compile \\":15,\\"./ compile / async \\":12,\\"./ compile / error_classes \\":13,\\"./ compile / formats \\":14,\\"./ compile / resolve \\":16,\\"./ compile / rules \\":17,\\"./ compile / schema_obj \\":18,\\"./ compile / util \\":20,\\"./ keyword \\":44,\\"./ patternGroups \\":45,\\"./ refs / $ data.json \\":46,\\"./ refs / json - SCHEMA - draft - 06.json \\":47,\\" co \\":48,\\" json - STABLE - stringify \\":51}],10:[function(require,module,exports){
''use strict'';
var Cache = module.exports = function Cache() {
this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
this._cache = {};
};
},{}],11:[function(require,module,exports){
''use strict'';
//all requires must be explicit because browserify won''t work with dynamic requires
module.exports = {
''$ref'': require(''../dotjs/ref''),
allOf: require(''../dotjs/allOf''),
anyOf: require(''../dotjs/anyOf''),
const: require(''../dotjs/const''),
contains: require(''../dotjs/contains''),
dependencies: require(''../dotjs/dependencies''),
''enum'': require(''../dotjs/enum''),
format: require(''../dotjs/format''),
items: require(''../dotjs/items''),
maximum: require(''../dotjs/_limit''),
minimum: require(''../dotjs/_limit''),
maxItems: require(''../dotjs/_limitItems''),
minItems: require(''../dotjs/_limitItems''),
maxLength: require(''../dotjs/_limitLength''),
minLength: require(''../dotjs/_limitLength''),
maxProperties: require(''../dotjs/_limitProperties''),
minProperties: require(''../dotjs/_limitProperties''),
multipleOf: require(''../dotjs/multipleOf''),
not: require(''../dotjs/not''),
oneOf: require(''../dotjs/oneOf''),
pattern: require(''../dotjs/pattern''),
properties: require(''../dotjs/properties''),
propertyNames: require(''../dotjs/propertyNames''),
required: require(''../dotjs/required''),
uniqueItems: require(''../dotjs/uniqueItems''),
validate: require(''../dotjs/validate'')
};
},{\\"../ dotjs / _limit \\":21,\\"../ dotjs / _limitItems \\":22,\\"../ dotjs / _limitLength \\":23,\\"../ dotjs / _limitProperties \\":24,\\"../ dotjs / allOf \\":25,\\"../ dotjs / anyOf \\":26,\\"../ dotjs / const \\":27,\\"../ dotjs / contains \\":28,\\"../ dotjs / dependencies \\":30,\\"../ dotjs / enum \\":31,\\"../ dotjs / format \\":32,\\"../ dotjs / items \\":33,\\"../ dotjs / multipleOf \\":34,\\"../ dotjs / NOT \\":35,\\"../ dotjs / oneOf \\":36,\\"../ dotjs / pattern \\":37,\\"../ dotjs / properties \\":38,\\"../ dotjs / propertyNames \\":39,\\"../ dotjs / ref \\":40,\\"../ dotjs / required \\":41,\\"../ dotjs / uniqueItems \\":42,\\"../ dotjs / validate \\":43}],12:[function(require,module,exports){
''use strict'';
var MissingRefError = require(''./error_classes'').MissingRef;
module.exports = compileAsync;
/**
* Creates validating function for passed schema with asynchronous loading of missing schemas.
* \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
* @this  Ajv
* @param {Object}   schema schema object
* @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
* @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
* @return {Promise} promise that resolves with a validating function.
*/
function compileAsync(schema, meta, callback) {
/* eslint no-shadow: 0 */
/* global Promise */
/* jshint validthis: true */
var self = this;
if (typeof this._opts.loadSchema != ''function'')
throw new Error(''options.loadSchema should be a function'');
if (typeof meta == ''function'') {
callback = meta;
meta = undefined;
}
var p = loadMetaSchemaOf(schema).then(function () {
var schemaObj = self._addSchema(schema, undefined, meta);
return schemaObj.validate || _compileAsync(schemaObj);
});
if (callback) {
p.then(
function(v) { callback(null, v); },
callback
);
}
return p;
function loadMetaSchemaOf(sch) {
var $schema = sch.$schema;
return $schema && !self.getSchema($schema)
? compileAsync.call(self, { $ref: $schema }, true)
: Promise.resolve();
}
function _compileAsync(schemaObj) {
try { return self._compile(schemaObj); }
catch(e) {
if (e instanceof MissingRefError) return loadMissingSchema(e);
throw e;
}
function loadMissingSchema(e) {
var ref = e.missingSchema;
if (added(ref)) throw new Error(''Schema '' + ref + '' is loaded but '' + e.missingRef + '' cannot be resolved'');
var schemaPromise = self._loadingSchemas[ref];
if (!schemaPromise) {
schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
schemaPromise.then(removePromise, removePromise);
}
return schemaPromise.then(function (sch) {
if (!added(ref)) {
return loadMetaSchemaOf(sch).then(function () {
if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
});
}
}).then(function() {
return _compileAsync(schemaObj);
});
function removePromise() {
delete self._loadingSchemas[ref];
}
function added(ref) {
return self._refs[ref] || self._schemas[ref];
}
}
}
}
},{\\"./ error_classes \\":13}],13:[function(require,module,exports){
''use strict'';
var resolve = require(''./resolve'');
module.exports = {
Validation: errorSubclass(ValidationError),
MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
this.message = ''validation failed'';
this.errors = errors;
this.ajv = this.validation = true;
}
MissingRefError.message = function (baseId, ref) {
return ''can\\\\''t resolve reference '' + ref + '' from id '' + baseId;
};
function MissingRefError(baseId, ref, message) {
this.message = message || MissingRefError.message(baseId, ref);
this.missingRef = resolve.url(baseId, ref);
this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
Subclass.prototype = Object.create(Error.prototype);
Subclass.prototype.constructor = Subclass;
return Subclass;
}
},{\\"./ resolve \\":16}],14:[function(require,module,exports){
''use strict'';
var util = require(''./util'');
var DATE = /^\\\\d\\\\d\\\\d\\\\d-(\\\\d\\\\d)-(\\\\d\\\\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)(\\\\.\\\\d+)?(z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\\\\-.]*:)(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''()*+,;=]|%[0-9a-f]{2})*)(?::\\\\d*)?(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\\\?(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\\\-.]*:)?(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''\\" () * +,; =] | %[0 - 9a - f] {2}) *) (?::d *) ? (? : / (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@] | %[0 - 9a - f] {2}) *) *) ? | (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\\\?(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@ / ?] | %[0 - 9a - f] {2}) *) ? (? : # (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\\\x00-\\\\x20\\"'' <> % \\\\\\\\ ^ \`{|}]|%[0-9a-f]{2})|\\\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?)*\\\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\\\/\\\\/)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!10(?:\\\\.\\\\d{1,3}){3})(?!127(?:\\\\.\\\\d{1,3}){3})(?!169\\\\.254(?:\\\\.\\\\d{1,3}){2})(?!192\\\\.168(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)*(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}]{2,})))(?::\\\\d{2,5})?(?:\\\\/[^\\\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\\\u017F]?|ftp):\\\\/\\\\/)(?:(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+(?::(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?@)?(?:(?!10(?:\\\\.[0-9]{1,3}){3})(?!127(?:\\\\.[0-9]{1,3}){3})(?!169\\\\.254(?:\\\\.[0-9]{1,3}){2})(?!192\\\\.168(?:\\\\.[0-9]{1,3}){2})(?!172\\\\.(?:1[6-9]|2[0-9]|3[01])(?:\\\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)(?:\\\\.(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)*(?:\\\\.(?:(?:[KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\\\/(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\\\/(?:[a-z0-9_\\\\-.!$&''()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\\\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
mode = mode == ''full'' ? ''full'' : ''fast'';
return util.copy(formats[mode]);
}
formats.fast = {
// date: http://tools.ietf.org/html/rfc3339#section-5.6
date: /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d$/,
// date-time: http://tools.ietf.org/html/rfc3339#section-5.6
time: /^[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i,
''date-time'': /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d[t\\\\s][0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)$/i,
// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\\\\/)\\\\/?[^\\\\s]*$/i,
''uri-reference'': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\\\/\\\\/)?[^\\\\s]*$/i,
''uri-template'': URITEMPLATE,
url: URL,
// email (sources from jsen validator):
// http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
// http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for ''willful violation'')
email: /^[a-z0-9.!#$%&''*+/=?^_\` {|}~ -] + @[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ? (? :.[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ?) * $ / i, hostname: HOSTNAME, / / optimized https: / / www.safaribooksonline.com / library / VIEW / regular - expressions - cookbook / 9780596802837 / ch07s16.html ipv4: / ^ (? : (? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?).) {3}(? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?) $ /, / / optimized http: / / stackoverflow.com / questions / 53497 / regular - expression - that - matches - valid - ipv6 - addresses ipv6: / ^ s * (? : (? : (? :[0 - 9a - f] {1, 4 } :) {7}(? :[0 - 9a - f] {1, 4 }| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {6}(?::[0 - 9a - f] {1, 4 }|(? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {5}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 2 })| : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {4}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 3 })|(? : (?::[0 - 9a - f] {1, 4 })? : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {3}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 4 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 2 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {2}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 5 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 3 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {1}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 6 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 4 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (?::(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 7 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 5 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :))) (? : %.+) ? s * $ / i, regex: regex, / / uuid: http: / / tools.ietf.org / html / rfc4122 uuid: uuid, / / json - pointer: https: / / tools.ietf.org / html / rfc6901 / / uri fragment: https: / / tools.ietf.org / html / rfc3986 # appendix - A ''json-pointer'' : JSON_POINTER, / / relative json - pointer: http: / / tools.ietf.org / html / draft - luff - relative - json - pointer - 00 ''relative-json-pointer'' : RELATIVE_JSON_POINTER }; formats.full = { date: date, time: time, ''date-time'' : date_time, uri: uri, ''uri-reference'' : URIREF, ''uri-template'' : URITEMPLATE, url: URL, email: / ^[a - z0 - 9 ! # $ % & ''*+/=?^_\`{|}~-]+(?:\\\\.[a-z0-9!#$%&''''*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
hostname: hostname,
ipv4: /^(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$/,
ipv6: /^\\\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:)))(?:%.+)?\\\\s*$/i,
regex: regex,
uuid: UUID,
'' json - pointer '': JSON_POINTER,
'' relative - json - pointer '': RELATIVE_JSON_POINTER
};
function date(str) {
// full-date from http://tools.ietf.org/html/rfc3339#section-5.6
var matches = str.match(DATE);
if (!matches) return false;
var month = +matches[1];
var day = +matches[2];
return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}
function time(str, full) {
var matches = str.match(TIME);
if (!matches) return false;
var hour = matches[1];
var minute = matches[2];
var second = matches[3];
var timeZone = matches[5];
return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\\\\s/i;
function date_time(str) {
// http://tools.ietf.org/html/rfc3339#section-5.6
var dateTime = str.split(DATE_TIME_SEPARATOR);
return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function hostname(str) {
// https://tools.ietf.org/html/rfc1034#section-3.5
// https://tools.ietf.org/html/rfc1123#section-2
return str.length <= 255 && HOSTNAME.test(str);
}
var NOT_URI_FRAGMENT = /\\\\/|:/;
function uri(str) {
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \\".\\"
return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\\\\\\\]\\\\\\\\Z/;
function regex(str) {
if (Z_ANCHOR.test(str)) return false;
try {
new RegExp(str);
return true;
} catch(e) {
return false;
}
}
},{\\"./util\\":20}],15:[function(require,module,exports){
'' use STRICT '';
var resolve = require(''./ resolve '')
, util = require(''./ util '')
, errorClasses = require(''./ error_classes '')
, stableStringify = require('' json - STABLE - stringify '');
var validateGenerator = require(''../ dotjs / validate '');
/**
* Functions below are used inside compiled validations function
*/
var co = require('' co '');
var ucs2length = util.ucs2length;
var equal = require('' fast - deep - equal '');
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
* Compiles schema to validation function
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Object} root object with information about the root schema for this schema
* @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
* @param  {String} baseId base ID for IDs in the schema
* @return {Function} validation function
*/
function compile(schema, root, localRefs, baseId) {
/* jshint validthis: true, evil: true */
/* eslint no-shadow: 0 */
var self = this
, opts = this._opts
, refVal = [ undefined ]
, refs = {}
, patterns = []
, patternsHash = {}
, defaults = []
, defaultsHash = {}
, customRules = [];
root = root || { schema: schema, refVal: refVal, refs: refs };
var c = checkCompiling.call(this, schema, root, baseId);
var compilation = this._compilations[c.index];
if (c.compiling) return (compilation.callValidate = callValidate);
var formats = this._formats;
var RULES = this.RULES;
try {
var v = localCompile(schema, root, localRefs, baseId);
compilation.validate = v;
var cv = compilation.callValidate;
if (cv) {
cv.schema = v.schema;
cv.errors = null;
cv.refs = v.refs;
cv.refVal = v.refVal;
cv.root = v.root;
cv.$async = v.$async;
if (opts.sourceCode) cv.source = v.source;
}
return v;
} finally {
endCompiling.call(this, schema, root, baseId);
}
function callValidate() {
var validate = compilation.validate;
var result = validate.apply(null, arguments);
callValidate.errors = validate.errors;
return result;
}
function localCompile(_schema, _root, localRefs, baseId) {
var isRoot = !_root || (_root && _root.schema == _schema);
if (_root.schema != root.schema)
return compile.call(self, _schema, _root, localRefs, baseId);
var $async = _schema.$async === true;
var sourceCode = validateGenerator({
isTop: true,
schema: _schema,
isRoot: isRoot,
baseId: baseId,
root: _root,
schemaPath: '''',
errSchemaPath: '' # '',
errorPath: '' \\"\\" '',
MissingRefError: errorClasses.MissingRef,
RULES: RULES,
validate: validateGenerator,
util: util,
resolve: resolve,
resolveRef: resolveRef,
usePattern: usePattern,
useDefault: useDefault,
useCustomRule: useCustomRule,
opts: opts,
formats: formats,
self: self
});
sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
+ vars(defaults, defaultCode) + vars(customRules, customRuleCode)
+ sourceCode;
if (opts.processCode) sourceCode = opts.processCode(sourceCode);
// console.log('' n n n * * * n '', JSON.stringify(sourceCode));
var validate;
try {
var makeValidate = new Function(
'' self '',
'' RULES '',
'' formats '',
'' root '',
'' refVal '',
'' defaults '',
'' customRules '',
'' co '',
'' equal '',
'' ucs2length '',
'' ValidationError '',
sourceCode
);
validate = makeValidate(
self,
RULES,
formats,
root,
refVal,
defaults,
customRules,
co,
equal,
ucs2length,
ValidationError
);
refVal[0] = validate;
} catch(e) {
console.error('' Error compiling SCHEMA, FUNCTION code: '', sourceCode);
throw e;
}
validate.schema = _schema;
validate.errors = null;
validate.refs = refs;
validate.refVal = refVal;
validate.root = isRoot ? validate : _root;
if ($async) validate.$async = true;
if (opts.sourceCode === true) {
validate.source = {
code: sourceCode,
patterns: patterns,
defaults: defaults
};
}
return validate;
}
function resolveRef(baseId, ref, isRoot) {
ref = resolve.url(baseId, ref);
var refIndex = refs[ref];
var _refVal, refCode;
if (refIndex !== undefined) {
_refVal = refVal[refIndex];
refCode = '' refVal['' + refIndex + ''] '';
return resolvedRef(_refVal, refCode);
}
if (!isRoot && root.refs) {
var rootRefId = root.refs[ref];
if (rootRefId !== undefined) {
_refVal = root.refVal[rootRefId];
refCode = addLocalRef(ref, _refVal);
return resolvedRef(_refVal, refCode);
}
}
refCode = addLocalRef(ref);
var v = resolve.call(self, localCompile, root, ref);
if (v === undefined) {
var localSchema = localRefs && localRefs[ref];
if (localSchema) {
v = resolve.inlineRef(localSchema, opts.inlineRefs)
? localSchema
: compile.call(self, localSchema, root, localRefs, baseId);
}
}
if (v === undefined) {
removeLocalRef(ref);
} else {
replaceLocalRef(ref, v);
return resolvedRef(v, refCode);
}
}
function addLocalRef(ref, v) {
var refId = refVal.length;
refVal[refId] = v;
refs[ref] = refId;
return '' refVal '' + refId;
}
function removeLocalRef(ref) {
delete refs[ref];
}
function replaceLocalRef(ref, v) {
var refId = refs[ref];
refVal[refId] = v;
}
function resolvedRef(refVal, code) {
return typeof refVal == '' object '' || typeof refVal == '' boolean ''
? { code: code, schema: refVal, inline: true }
: { code: code, $async: refVal && refVal.$async };
}
function usePattern(regexStr) {
var index = patternsHash[regexStr];
if (index === undefined) {
index = patternsHash[regexStr] = patterns.length;
patterns[index] = regexStr;
}
return '' pattern '' + index;
}
function useDefault(value) {
switch (typeof value) {
case '' boolean '':
case '' number '':
return '''' + value;
case '' string '':
return util.toQuotedString(value);
case '' object '':
if (value === null) return '' NULL '';
var valueStr = stableStringify(value);
var index = defaultsHash[valueStr];
if (index === undefined) {
index = defaultsHash[valueStr] = defaults.length;
defaults[index] = value;
}
return '' DEFAULT '' + index;
}
}
function useCustomRule(rule, schema, parentSchema, it) {
var validateSchema = rule.definition.validateSchema;
if (validateSchema && self._opts.validateSchema !== false) {
var valid = validateSchema(schema);
if (!valid) {
var message = '' keyword SCHEMA IS invalid: '' + self.errorsText(validateSchema.errors);
if (self._opts.validateSchema == '' log '') console.error(message);
else throw new Error(message);
}
}
var compile = rule.definition.compile
, inline = rule.definition.inline
, macro = rule.definition.macro;
var validate;
if (compile) {
validate = compile.call(self, schema, parentSchema, it);
} else if (macro) {
validate = macro.call(self, schema, parentSchema, it);
if (opts.validateSchema !== false) self.validateSchema(validate, true);
} else if (inline) {
validate = inline.call(self, it, rule.keyword, schema, parentSchema);
} else {
validate = rule.definition.validate;
if (!validate) return;
}
if (validate === undefined)
throw new Error('' custom keyword \\"'' + rule.keyword + ''\\" failed TO compile '');
var index = customRules.length;
customRules[index] = validate;
return {
code: '' customRule '' + index,
validate: validate
};
}
}
/**
* Checks if the schema is currently compiled
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Object} object with properties \\"index\\" (compilation index) and \\"compiling\\" (boolean)
*/
function checkCompiling(schema, root, baseId) {
/* jshint validthis: true */
var index = compIndex.call(this, schema, root, baseId);
if (index >= 0) return { index: index, compiling: true };
index = this._compilations.length;
this._compilations[index] = {
schema: schema,
root: root,
baseId: baseId
};
return { index: index, compiling: false };
}
/**
* Removes the schema from the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
*/
function endCompiling(schema, root, baseId) {
/* jshint validthis: true */
var i = compIndex.call(this, schema, root, baseId);
if (i >= 0) this._compilations.splice(i, 1);
}
/**
* Index of schema compilation in the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Integer} compilation index
*/
function compIndex(schema, root, baseId) {
/* jshint validthis: true */
for (var i=0; i<this._compilations.length; i++) {
var c = this._compilations[i];
if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
}
return -1;
}
function patternCode(i, patterns) {
return '' var pattern '' + i + '' = new RegExp ('' + util.toQuotedString(patterns[i]) + ''); '';
}
function defaultCode(i) {
return '' var DEFAULT '' + i + '' = defaults['' + i + '']; '';
}
function refValCode(i, refVal) {
return refVal[i] === undefined ? '''' : '' var refVal '' + i + '' = refVal['' + i + '']; '';
}
function customRuleCode(i) {
return '' var customRule '' + i + '' = customRules['' + i + '']; '';
}
function vars(arr, statement) {
if (!arr.length) return '''';
var code = '''';
for (var i=0; i<arr.length; i++)
code += statement(i, arr);
return code;
}
},{\\"../dotjs/validate\\":43,\\"./error_classes\\":13,\\"./resolve\\":16,\\"./util\\":20,\\"co\\":48,\\"fast-deep-equal\\":49,\\"json-stable-stringify\\":51}],16:[function(require,module,exports){
'' use STRICT '';
var url = require('' url '')
, equal = require('' fast - deep - equal '')
, util = require(''./ util '')
, SchemaObject = require(''./ schema_obj '')
, traverse = require('' json - SCHEMA - traverse '');
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
* [resolve and compile the references ($ref)]
* @this   Ajv
* @param  {Function} compile reference to schema compilation funciton (localCompile)
* @param  {Object} root object with information about the root schema for the current schema
* @param  {String} ref reference to resolve
* @return {Object|Function} schema object (if the schema can be inlined) or validation function
*/
function resolve(compile, root, ref) {
/* jshint validthis: true */
var refVal = this._refs[ref];
if (typeof refVal == '' string '') {
if (this._refs[refVal]) refVal = this._refs[refVal];
else return resolve.call(this, compile, root, refVal);
}
refVal = refVal || this._schemas[ref];
if (refVal instanceof SchemaObject) {
return inlineRef(refVal.schema, this._opts.inlineRefs)
? refVal.schema
: refVal.validate || this._compile(refVal);
}
var res = resolveSchema.call(this, root, ref);
var schema, v, baseId;
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
if (schema instanceof SchemaObject) {
v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
} else if (schema !== undefined) {
v = inlineRef(schema, this._opts.inlineRefs)
? schema
: compile.call(this, schema, root, undefined, baseId);
}
return v;
}
/**
* Resolve schema, its root and baseId
* @this Ajv
* @param  {Object} root root object with properties schema, refVal, refs
* @param  {String} ref  reference to resolve
* @return {Object} object with properties schema, root, baseId
*/
function resolveSchema(root, ref) {
/* jshint validthis: true */
var p = url.parse(ref, false, true)
, refPath = _getFullPath(p)
, baseId = getFullPath(this._getId(root.schema));
if (refPath !== baseId) {
var id = normalizeId(refPath);
var refVal = this._refs[id];
if (typeof refVal == '' string '') {
return resolveRecursive.call(this, root, refVal, p);
} else if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
root = refVal;
} else {
refVal = this._schemas[id];
if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
if (id == normalizeId(ref))
return { schema: refVal, root: root, baseId: baseId };
root = refVal;
} else {
return;
}
}
if (!root.schema) return;
baseId = getFullPath(this._getId(root.schema));
}
return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
/* jshint validthis: true */
var res = resolveSchema.call(this, root, ref);
if (res) {
var schema = res.schema;
var baseId = res.baseId;
root = res.root;
var id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
return getJsonPointer.call(this, parsedRef, baseId, schema, root);
}
}
var PREVENT_SCOPE_CHANGE = util.toHash(['' properties '', '' patternProperties '', '' enum '', '' dependencies '', '' definitions '']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
/* jshint validthis: true */
parsedRef.hash = parsedRef.hash || '''';
if (parsedRef.hash.slice(0,2) != '' # / '') return;
var parts = parsedRef.hash.split('' / '');
for (var i = 1; i < parts.length; i++) {
var part = parts[i];
if (part) {
part = util.unescapeFragment(part);
schema = schema[part];
if (schema === undefined) break;
var id;
if (!PREVENT_SCOPE_CHANGE[part]) {
id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
if (schema.$ref) {
var $ref = resolveUrl(baseId, schema.$ref);
var res = resolveSchema.call(this, root, $ref);
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
}
}
}
}
if (schema !== undefined && schema !== root.schema)
return { schema: schema, root: root, baseId: baseId };
}
var SIMPLE_INLINED = util.toHash([
'' TYPE '', '' format '', '' pattern '',
'' maxLength '', '' minLength '',
'' maxProperties '', '' minProperties '',
'' maxItems '', '' minItems '',
'' maximum '', '' minimum '',
'' uniqueItems '', '' multipleOf '',
'' required '', '' enum ''
]);
function inlineRef(schema, limit) {
if (limit === false) return false;
if (limit === undefined || limit === true) return checkNoRef(schema);
else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
var item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return false;
item = schema[key];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
}
return true;
}
function countKeys(schema) {
var count = 0, item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '') count += countKeys(item);
if (count == Infinity) return Infinity;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return Infinity;
if (SIMPLE_INLINED[key]) {
count++;
} else {
item = schema[key];
if (typeof item == '' object '') count += countKeys(item) + 1;
if (count == Infinity) return Infinity;
}
}
}
return count;
}
function getFullPath(id, normalize) {
if (normalize !== false) id = normalizeId(id);
var p = url.parse(id, false, true);
return _getFullPath(p);
}
function _getFullPath(p) {
var protocolSeparator = p.protocol || p.href.slice(0,2) == '' / / '' ? '' / / '' : '''';
return (p.protocol||'''') + protocolSeparator + (p.host||'''') + (p.path||'''')  + '' # '';
}
var TRAILING_SLASH_HASH = /#\\\\/?$/;
function normalizeId(id) {
return id ? id.replace(TRAILING_SLASH_HASH, '''') : '''';
}
function resolveUrl(baseId, id) {
id = normalizeId(id);
return url.resolve(baseId, id);
}
/* @this Ajv */
function resolveIds(schema) {
var schemaId = normalizeId(this._getId(schema));
var baseIds = {'''': schemaId};
var fullPaths = {'''': getFullPath(schemaId, false)};
var localRefs = {};
var self = this;
traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (jsonPtr === '''') return;
var id = self._getId(sch);
var baseId = baseIds[parentJsonPtr];
var fullPath = fullPaths[parentJsonPtr] + '' / '' + parentKeyword;
if (keyIndex !== undefined)
fullPath += '' / '' + (typeof keyIndex == '' number '' ? keyIndex : util.escapeFragment(keyIndex));
if (typeof id == '' string '') {
id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);
var refVal = self._refs[id];
if (typeof refVal == '' string '') refVal = self._refs[refVal];
if (refVal && refVal.schema) {
if (!equal(sch, refVal.schema))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
} else if (id != normalizeId(fullPath)) {
if (id[0] == '' # '') {
if (localRefs[id] && !equal(sch, localRefs[id]))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
localRefs[id] = sch;
} else {
self._refs[id] = fullPath;
}
}
}
baseIds[jsonPtr] = baseId;
fullPaths[jsonPtr] = fullPath;
});
return localRefs;
}
},{\\"./schema_obj\\":18,\\"./util\\":20,\\"fast-deep-equal\\":49,\\"json-schema-traverse\\":50,\\"url\\":5}],17:[function(require,module,exports){
'' use STRICT '';
var ruleModules = require(''./ _rules '')
, toHash = require(''./ util '').toHash;
module.exports = function rules() {
var RULES = [
{ type: '' number '',
rules: [ { '' maximum '': ['' exclusiveMaximum ''] },
{ '' minimum '': ['' exclusiveMinimum ''] }, '' multipleOf '', '' format ''] },
{ type: '' string '',
rules: [ '' maxLength '', '' minLength '', '' pattern '', '' format '' ] },
{ type: '' ARRAY '',
rules: [ '' maxItems '', '' minItems '', '' uniqueItems '', '' contains '', '' items '' ] },
{ type: '' object '',
rules: [ '' maxProperties '', '' minProperties '', '' required '', '' dependencies '', '' propertyNames '',
{ '' properties '': ['' additionalProperties '', '' patternProperties ''] } ] },
{ rules: [ '' $ ref '', '' const '', '' enum '', '' NOT '', '' anyOf '', '' oneOf '', '' allOf '' ] }
];
var ALL = [ '' TYPE '' ];
var KEYWORDS = [
'' additionalItems '', '' $ SCHEMA '', '' id '', '' title '',
'' description '', '' DEFAULT '', '' definitions ''
];
var TYPES = [ '' number '', '' integer '', '' string '', '' ARRAY '', '' object '', '' boolean '', '' NULL '' ];
RULES.all = toHash(ALL);
RULES.types = toHash(TYPES);
RULES.forEach(function (group) {
group.rules = group.rules.map(function (keyword) {
var implKeywords;
if (typeof keyword == '' object '') {
var key = Object.keys(keyword)[0];
implKeywords = keyword[key];
keyword = key;
implKeywords.forEach(function (k) {
ALL.push(k);
RULES.all[k] = true;
});
}
ALL.push(keyword);
var rule = RULES.all[keyword] = {
keyword: keyword,
code: ruleModules[keyword],
implements: implKeywords
};
return rule;
});
if (group.type) RULES.types[group.type] = group;
});
RULES.keywords = toHash(ALL.concat(KEYWORDS));
RULES.custom = {};
return RULES;
};
},{\\"./_rules\\":11,\\"./util\\":20}],18:[function(require,module,exports){
'' use STRICT '';
var util = require(''./ util '');
module.exports = SchemaObject;
function SchemaObject(obj) {
util.copy(obj, this);
}
},{\\"./util\\":20}],19:[function(require,module,exports){
'' use STRICT '';
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
var length = 0
, len = str.length
, pos = 0
, value;
while (pos < len) {
length++;
value = str.charCodeAt(pos++);
if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
// high surrogate, and there is a next character
value = str.charCodeAt(pos);
if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
}
}
return length;
};
},{}],20:[function(require,module,exports){
'' use STRICT '';
module.exports = {
copy: copy,
checkDataType: checkDataType,
checkDataTypes: checkDataTypes,
coerceToTypes: coerceToTypes,
toHash: toHash,
getProperty: getProperty,
escapeQuotes: escapeQuotes,
equal: require('' fast - deep - equal ''),
ucs2length: require(''./ ucs2length ''),
varOccurences: varOccurences,
varReplace: varReplace,
cleanUpCode: cleanUpCode,
finalCleanUpCode: finalCleanUpCode,
schemaHasRules: schemaHasRules,
schemaHasRulesExcept: schemaHasRulesExcept,
toQuotedString: toQuotedString,
getPathExpr: getPathExpr,
getPath: getPath,
getData: getData,
unescapeFragment: unescapeFragment,
unescapeJsonPointer: unescapeJsonPointer,
escapeFragment: escapeFragment,
escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
to = to || {};
for (var key in o) to[key] = o[key];
return to;
}
function checkDataType(dataType, data, negate) {
var EQUAL = negate ? '' != = '' : '' == = ''
, AND = negate ? '' || '' : '' && ''
, OK = negate ? '' ! '' : ''''
, NOT = negate ? '''' : '' ! '';
switch (dataType) {
case '' NULL '': return data + EQUAL + '' NULL '';
case '' ARRAY '': return OK + '' Array.isArray ('' + data + '') '';
case '' object '': return '' ('' + OK + data + AND +
'' typeof '' + data + EQUAL + '' \\"object\\" '' + AND +
NOT + '' Array.isArray ('' + data + '')) '';
case '' integer '': return '' (typeof '' + data + EQUAL + '' \\"number\\" '' + AND +
NOT + '' ('' + data + '' % 1) '' +
AND + data + EQUAL + data + '') '';
default: return '' typeof '' + data + EQUAL + '' \\"'' + dataType + ''\\" '';
}
}
function checkDataTypes(dataTypes, data) {
switch (dataTypes.length) {
case 1: return checkDataType(dataTypes[0], data, true);
default:
var code = '''';
var types = toHash(dataTypes);
if (types.array && types.object) {
code = types.null ? '' ('': '' (! '' + data + '' || '';
code += '' typeof '' + data + '' != = \\"object\\") '';
delete types.null;
delete types.array;
delete types.object;
}
if (types.number) delete types.integer;
for (var t in types)
code += (code ? '' && '' : '''' ) + checkDataType(t, data, true);
return code;
}
}
var COERCE_TO_TYPES = toHash([ '' string '', '' number '', '' integer '', '' boolean '', '' NULL '' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
if (Array.isArray(dataTypes)) {
var types = [];
for (var i=0; i<dataTypes.length; i++) {
var t = dataTypes[i];
if (COERCE_TO_TYPES[t]) types[types.length] = t;
else if (optionCoerceTypes === '' ARRAY '' && t === '' ARRAY '') types[types.length] = t;
}
if (types.length) return types;
} else if (COERCE_TO_TYPES[dataTypes]) {
return [dataTypes];
} else if (optionCoerceTypes === '' ARRAY '' && dataTypes === '' ARRAY '') {
return ['' ARRAY ''];
}
}
function toHash(arr) {
var hash = {};
for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'' | \\\\\\\\ / g; FUNCTION getProperty (KEY) { RETURN typeof KEY == ''number'' ? ''['' + KEY + '']'' : IDENTIFIER.test (KEY) ? ''.'' + KEY :\\"[''\\" + escapeQuotes (KEY) + \\"'']\\"; } FUNCTION escapeQuotes (str) { RETURN str.replace(SINGLE_QUOTE, ''\\\\\\\\$&'').replace(/ n / g, ''\\\\\\\\n'').replace(/ r / g, ''\\\\\\\\r'').replace(/ f / g, ''\\\\\\\\f'').replace(/ t / g, ''\\\\\\\\t''); } FUNCTION varOccurences (str, dataVar) { dataVar + = ''[^0-9]''; var matches = str.match (new RegExp (dataVar, ''g'')); RETURN matches ? matches.length : 0; } FUNCTION varReplace (str, dataVar, expr) { dataVar + = ''([^0-9])''; expr = expr.replace(/ $ / g, ''$$$$''); RETURN str.replace(new RegExp (dataVar, ''g''), expr + ''$1''); } var EMPTY_ELSE = /
ELSE
s * { s * } / g, EMPTY_IF_NO_ELSE = / IF s * ([^)] +) s * { s * }(?! s *
ELSE
) / g, EMPTY_IF_WITH_ELSE = / IF s * (([^)] +)) s * { s * } s *
ELSE
(? ! s * IF) / g; FUNCTION cleanUpCode (out) { RETURN out.replace(EMPTY_ELSE, '''').replace(EMPTY_IF_NO_ELSE, '''').replace(EMPTY_IF_WITH_ELSE, ''if (!($1))''); } var ERRORS_REGEXP = /[^ v.] errors / g, REMOVE_ERRORS = / var errors = 0; | var vErrors = NULL; | validate.errors = vErrors; / g, REMOVE_ERRORS_ASYNC = / var errors = 0; | var vErrors = NULL; / g, RETURN_VALID = ''return errors === 0;'', RETURN_TRUE = ''validate.errors = null; return true;'', RETURN_ASYNC = / IF (errors == = 0)
RETURN data; s *
ELSE
throw new ValidationError (vErrors); /, RETURN_DATA_ASYNC = ''return data;'', ROOTDATA_REGEXP = /[^ A - Za - z_$] rootData[^ A - Za - z0 - 9_$] / g, REMOVE_ROOTDATA = / IF (rootData == = undefined) rootData = data; /; FUNCTION finalCleanUpCode (out, async) { var matches = out.match (ERRORS_REGEXP); IF (matches && matches.length == 2) { out = async ? out.replace(REMOVE_ERRORS_ASYNC, '''').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '''').replace(RETURN_VALID, RETURN_TRUE); } matches = out.match (ROOTDATA_REGEXP); IF (! matches || matches.length != = 3)
RETURN out; RETURN out.replace(REMOVE_ROOTDATA, ''''); } FUNCTION schemaHasRules (SCHEMA, rules) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA; FOR (var KEY IN SCHEMA)
IF (rules[KEY])
RETURN TRUE; } FUNCTION schemaHasRulesExcept (SCHEMA, rules, exceptKeyword) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA && exceptKeyword != ''not''; FOR (var KEY IN SCHEMA)
IF (KEY != exceptKeyword && rules[KEY])
RETURN TRUE; } FUNCTION toQuotedString (str) { RETURN ''\\\\'''' + escapeQuotes (str) + ''\\\\''''; } FUNCTION getPathExpr (currentPath, expr, jsonPointers, isNumber) { var path = jsonPointers / / FALSE BY DEFAULT ? ''\\\\''/\\\\'' + '' + expr + (isNumber ? '''' :''.replace(/~/g, \\\\''~0\\\\'').replace(/\\\\\\\\//g, \\\\''~1\\\\'')'') : (isNumber ? ''\\\\''[\\\\'' + '' + expr + '' + \\\\'']\\\\'''' :''\\\\''[\\\\\\\\\\\\''\\\\'' + '' + expr + '' + \\\\''\\\\\\\\\\\\'']\\\\''''); RETURN joinPaths (currentPath, path); } FUNCTION getPath (currentPath, prop, jsonPointers) { var path = jsonPointers / / FALSE BY DEFAULT ? toQuotedString (''/'' + escapeJsonPointer (prop)) : toQuotedString (getProperty (prop)); RETURN joinPaths (currentPath, path); } var JSON_POINTER = / ^ / (? :[^ ~] | ~ 0 | ~ 1) * $ /; var RELATIVE_JSON_POINTER = / ^ ([0 - 9] +) (# | / (? :[^ ~] | ~ 0 | ~ 1) *) ? $ /; FUNCTION getData ($ data, lvl, paths) { var up, jsonPointer, data, matches; IF ($ data == = '''')
RETURN ''rootData''; IF ($ data[0] == ''/'') { IF (! JSON_POINTER.test ($ data)) throw new Error (''Invalid JSON-pointer: '' + $ data); jsonPointer = $ data; data = ''rootData''; }
ELSE
{ matches = $ data.match (RELATIVE_JSON_POINTER); IF (! matches) throw new Error (''Invalid JSON-pointer: '' + $ data); up = + matches[1]; jsonPointer = matches[2]; IF (jsonPointer == ''#'') { IF (up >= lvl) throw new Error (''Cannot access property/index '' + up + '' levels up, current level is '' + lvl); RETURN paths[lvl - up]; } IF (up > lvl) throw new Error (''Cannot access data '' + up + '' levels up, current level is '' + lvl); data = ''data'' + ((lvl - up) || ''''); IF (! jsonPointer)
RETURN data; } var expr = data; var segments = jsonPointer.split (''/''); FOR (var i = 0; i < segments.length; i + +) { var segment = segments[i]; IF (segment) { data + = getProperty (unescapeJsonPointer (segment)); expr + = '' && '' + data; } } RETURN expr; } FUNCTION joinPaths (a, b) { IF (a == ''\\"\\"'')
RETURN b; RETURN (a + '' + '' + b).replace(/ '' \\\\+ '' / g, ''''); } FUNCTION unescapeFragment (str) { RETURN unescapeJsonPointer (decodeURIComponent (str)); } FUNCTION escapeFragment (str) { RETURN encodeURIComponent (escapeJsonPointer (str)); } FUNCTION escapeJsonPointer (str) { RETURN str.replace(/ ~ / g, ''~0'').replace(/ / / g, ''~1''); } FUNCTION unescapeJsonPointer (str) { RETURN str.replace(/ ~ 1 / g, ''/'').replace(/ ~ 0 / g, ''~''); } }, {\\". / ucs2length \\":19,\\" fast - deep - equal \\":49}],21:[function(require,module,exports){
''use strict'';
module.exports = function generate__limit(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $isMax = $keyword == ''maximum'',
$exclusiveKeyword = $isMax ? ''exclusiveMaximum'' : ''exclusiveMinimum'',
$schemaExcl = it.schema[$exclusiveKeyword],
$isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
$op = $isMax ? ''<'' : ''>'',
$notOp = $isMax ? ''>'' : ''<'',
$errorKeyword = undefined;
if ($isDataExcl) {
var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
$exclusive = ''exclusive'' + $lvl,
$exclType = ''exclType'' + $lvl,
$exclIsNumber = ''exclIsNumber'' + $lvl,
$opExpr = ''op'' + $lvl,
$opStr = ''\\\\'' + '' + $opExpr + '' + \\\\'''';
out += '' var schemaExcl'' + ($lvl) + '' = '' + ($schemaValueExcl) + ''; '';
$schemaValueExcl = ''schemaExcl'' + $lvl;
out += '' var '' + ($exclusive) + ''; var '' + ($exclType) + '' = typeof '' + ($schemaValueExcl) + ''; if ('' + ($exclType) + '' != \\\\''boolean\\\\'' && '' + ($exclType) + '' != \\\\''undefined\\\\'' && '' + ($exclType) + '' != \\\\''number\\\\'') { '';
var $errorKeyword = $exclusiveKeyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_exclusiveLimit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''' + ($exclusiveKeyword) + '' should be boolean\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($exclType) + '' == \\\\''number\\\\'' ? (('' + ($exclusive) + '' = '' + ($schemaValue) + '' === undefined || '' + ($schemaValueExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '') ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValueExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) : (('' + ($exclusive) + '' = '' + ($schemaValueExcl) + '' === true) ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValue) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { var op'' + ($lvl) + '' = '' + ($exclusive) + '' ? \\\\'''' + ($op) + ''\\\\'' : \\\\'''' + ($op) + ''=\\\\'';'';
} else {
var $exclIsNumber = typeof $schemaExcl == ''number'',
$opStr = $op;
if ($exclIsNumber && $isData) {
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' ( '' + ($schemaValue) + '' === undefined || '' + ($schemaExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '' ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { '';
} else {
if ($exclIsNumber && $schema === undefined) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$schemaValue = $schemaExcl;
$notOp += ''='';
} else {
if ($exclIsNumber) $schemaValue = Math[$isMax ? ''min'' : ''max'']($schemaExcl, $schema);
if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$notOp += ''='';
} else {
$exclusive = false;
$opStr += ''='';
}
}
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' || '' + ($data) + '' !== '' + ($data) + '') { '';
}
}
$errorKeyword = $errorKeyword || $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { comparison: '' + ($opExpr) + '', limit: '' + ($schemaValue) + '', exclusive: '' + ($exclusive) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '' + ($opStr) + '' '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],22:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxItems'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + ''.length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxItems'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],23:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxLength'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
if (it.opts.unicode === false) {
out += '' '' + ($data) + ''.length '';
} else {
out += '' ucs2length('' + ($data) + '') '';
}
out += '' '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitLength'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be '';
if ($keyword == ''maxLength'') {
out += ''longer'';
} else {
out += ''shorter'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' characters\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],24:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxProperties'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' Object.keys('' + ($data) + '').length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxProperties'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],25:[function(require,module,exports){
''use strict'';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
var out = '' '';
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $currentBaseId = $it.baseId,
$allSchemasEmpty = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$allSchemasEmpty = false;
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($breakOnError) {
if ($allSchemasEmpty) {
out += '' if (true) { '';
} else {
out += '' '' + ($closingBraces.slice(0, -1)) + '' '';
}
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],26:[function(require,module,exports){
''use strict'';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $noEmptySchema = $schema.every(function($sch) {
return it.util.schemaHasRules($sch, it.RULES.all);
});
if ($noEmptySchema) {
var $currentBaseId = $it.baseId;
out += '' var '' + ($errs) + '' = errors; var '' + ($valid) + '' = false;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' '' + ($valid) + '' = '' + ($valid) + '' || '' + ($nextValid) + ''; if (!'' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''anyOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match some schema in anyOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],27:[function(require,module,exports){
''use strict'';
module.exports = function generate_const(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (!$isData) {
out += '' var schema'' + ($lvl) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '' = equal('' + ($data) + '', schema'' + ($lvl) + ''); if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''const'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to constant\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],28:[function(require,module,exports){
''use strict'';
module.exports = function generate_contains(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId,
$nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($nonEmptySchema) {
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($nextValid) + '' = false; for (var '' + ($idx) + '' = 0; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if ('' + ($nextValid) + '') break; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($nextValid) + '') {'';
} else {
out += '' if ('' + ($data) + ''.length == 0) {'';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''contains'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should contain a valid item\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
if ($nonEmptySchema) {
out += ''  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
}
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],29:[function(require,module,exports){
''use strict'';
module.exports = function generate_custom(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $rule = this,
$definition = ''definition'' + $lvl,
$rDef = $rule.definition,
$closingBraces = '''';
var $compile, $inline, $macro, $ruleValidate, $validateCode;
if ($isData && $rDef.$data) {
$validateCode = ''keywordValidate'' + $lvl;
var $validateSchema = $rDef.validateSchema;
out += '' var '' + ($definition) + '' = RULES.custom[\\\\'''' + ($keyword) + ''\\\\''].definition; var '' + ($validateCode) + '' = '' + ($definition) + ''.validate;'';
} else {
$ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
if (!$ruleValidate) return;
$schemaValue = ''validate.schema'' + $schemaPath;
$validateCode = $ruleValidate.code;
$compile = $rDef.compile;
$inline = $rDef.inline;
$macro = $rDef.macro;
}
var $ruleErrs = $validateCode + ''.errors'',
$i = ''i'' + $lvl,
$ruleErr = ''ruleErr'' + $lvl,
$asyncKeyword = $rDef.async;
if ($asyncKeyword && !it.async) throw new Error(''async keyword in sync schema'');
if (!($inline || $macro)) {
out += '''' + ($ruleErrs) + '' = null;'';
}
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($isData && $rDef.$data) {
$closingBraces += ''}'';
out += '' if ('' + ($schemaValue) + '' === undefined) { '' + ($valid) + '' = true; } else { '';
if ($validateSchema) {
$closingBraces += ''}'';
out += '' '' + ($valid) + '' = '' + ($definition) + ''.validateSchema('' + ($schemaValue) + ''); if ('' + ($valid) + '') { '';
}
}
if ($inline) {
if ($rDef.statements) {
out += '' '' + ($ruleValidate.validate) + '' '';
} else {
out += '' '' + ($valid) + '' = '' + ($ruleValidate.validate) + ''; '';
}
} else if ($macro) {
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $ruleValidate.validate;
$it.schemaPath = '''';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $validateCode);
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($code);
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
out += ''  '' + ($validateCode) + ''.call( '';
if (it.opts.passContext) {
out += ''this'';
} else {
out += ''self'';
}
if ($compile || $rDef.schema === false) {
out += '' , '' + ($data) + '' '';
} else {
out += '' , '' + ($schemaValue) + '' , '' + ($data) + '' , validate.schema'' + (it.schemaPath) + '' '';
}
out += '' , (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '' , rootData )  '';
var def_callRuleValidate = out;
out = $$outStack.pop();
if ($rDef.errors === false) {
out += '' '' + ($valid) + '' = '';
if ($asyncKeyword) {
out += '''' + (it.yieldAwait);
}
out += '''' + (def_callRuleValidate) + ''; '';
} else {
if ($asyncKeyword) {
$ruleErrs = ''customErrors'' + $lvl;
out += '' var '' + ($ruleErrs) + '' = null; try { '' + ($valid) + '' = '' + (it.yieldAwait) + (def_callRuleValidate) + ''; } catch (e) { '' + ($valid) + '' = false; if (e instanceof ValidationError) '' + ($ruleErrs) + '' = e.errors; else throw e; } '';
} else {
out += '' '' + ($ruleErrs) + '' = null; '' + ($valid) + '' = '' + (def_callRuleValidate) + ''; '';
}
}
}
if ($rDef.modifying) {
out += '' if ('' + ($parentData) + '') '' + ($data) + '' = '' + ($parentData) + ''['' + ($parentDataProperty) + ''];'';
}
out += '''' + ($closingBraces);
if ($rDef.valid) {
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
out += '' if ( '';
if ($rDef.valid === undefined) {
out += '' !'';
if ($macro) {
out += '''' + ($nextValid);
} else {
out += '''' + ($valid);
}
} else {
out += '' '' + (!$rDef.valid) + '' '';
}
out += '') { '';
$errorKeyword = $rule.keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
var def_customError = out;
out = $$outStack.pop();
if ($inline) {
if ($rDef.errors) {
if ($rDef.errors != ''full'') {
out += ''  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } '';
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if ('' + ($errs) + '' == errors) { '' + (def_customError) + '' } else {  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } '';
}
}
} else if ($macro) {
out += ''   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if (Array.isArray('' + ($ruleErrs) + '')) { if (vErrors === null) vErrors = '' + ($ruleErrs) + ''; else vErrors = vErrors.concat('' + ($ruleErrs) + ''); errors = vErrors.length;  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '';  '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\";  '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } else { '' + (def_customError) + '' } '';
}
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
}
return out;
}
},{}],30:[function(require,module,exports){
''use strict'';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $schemaDeps = {},
$propertyDeps = {},
$ownProperties = it.opts.ownProperties;
for ($property in $schema) {
var $sch = $schema[$property];
var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
$deps[$property] = $sch;
}
out += ''var '' + ($errs) + '' = errors;'';
var $currentErrorPath = it.errorPath;
out += ''var missing'' + ($lvl) + '';'';
for (var $property in $propertyDeps) {
$deps = $propertyDeps[$property];
if ($deps.length) {
out += '' if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
if ($breakOnError) {
out += '' && ( '';
var arr1 = $deps;
if (arr1) {
var $propertyKey, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$propertyKey = arr1[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '')) {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
out += '' ) { '';
var arr2 = $deps;
if (arr2) {
var $propertyKey, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$propertyKey = arr2[i2 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
out += '' }   '';
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
}
it.errorPath = $currentErrorPath;
var $currentBaseId = $it.baseId;
for (var $property in $schemaDeps) {
var $sch = $schemaDeps[$property];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
out += '') { '';
$it.schema = $sch;
$it.schemaPath = $schemaPath + it.util.getProperty($property);
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($property);
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
if ($breakOnError) {
out += ''   '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],31:[function(require,module,exports){
''use strict'';
module.exports = function generate_enum(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $i = ''i'' + $lvl,
$vSchema = ''schema'' + $lvl;
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '';'';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '''' + ($valid) + '' = false;for (var '' + ($i) + ''=0; '' + ($i) + ''<'' + ($vSchema) + ''.length; '' + ($i) + ''++) if (equal('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + ''])) { '' + ($valid) + '' = true; break; }'';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''enum'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { allowedValues: schema'' + ($lvl) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to one of the allowed values\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],32:[function(require,module,exports){
''use strict'';
module.exports = function generate_format(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
if (it.opts.format === false) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $unknownFormats = it.opts.unknownFormats,
$allowUnknown = Array.isArray($unknownFormats);
if ($isData) {
var $format = ''format'' + $lvl,
$isObject = ''isObject'' + $lvl,
$formatType = ''formatType'' + $lvl;
out += '' var '' + ($format) + '' = formats['' + ($schemaValue) + '']; var '' + ($isObject) + '' = typeof '' + ($format) + '' == \\\\''object\\\\'' && !('' + ($format) + '' instanceof RegExp) && '' + ($format) + ''.validate; var '' + ($formatType) + '' = '' + ($isObject) + '' && '' + ($format) + ''.type || \\\\''string\\\\''; if ('' + ($isObject) + '') { '';
if (it.async) {
out += '' var async'' + ($lvl) + '' = '' + ($format) + ''.async; '';
}
out += '' '' + ($format) + '' = '' + ($format) + ''.validate; } if (  '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' ('';
if ($unknownFormats != ''ignore'') {
out += '' ('' + ($schemaValue) + '' && !'' + ($format) + '' '';
if ($allowUnknown) {
out += '' && self._opts.unknownFormats.indexOf('' + ($schemaValue) + '') == -1 '';
}
out += '') || '';
}
out += '' ('' + ($format) + '' && '' + ($formatType) + '' == \\\\'''' + ($ruleType) + ''\\\\'' && !(typeof '' + ($format) + '' == \\\\''function\\\\'' ? '';
if (it.async) {
out += '' (async'' + ($lvl) + '' ? '' + (it.yieldAwait) + '' '' + ($format) + ''('' + ($data) + '') : '' + ($format) + ''('' + ($data) + '')) '';
} else {
out += '' '' + ($format) + ''('' + ($data) + '') '';
}
out += '' : '' + ($format) + ''.test('' + ($data) + ''))))) {'';
} else {
var $format = it.formats[$schema];
if (!$format) {
if ($unknownFormats == ''ignore'') {
console.warn(''unknown format \\" '' + $schema + '' \\" ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else {
throw new Error(''unknown format \\" '' + $schema + '' \\" is used in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
var $isObject = typeof $format == ''object'' && !($format instanceof RegExp) && $format.validate;
var $formatType = $isObject && $format.type || ''string'';
if ($isObject) {
var $async = $format.async === true;
$format = $format.validate;
}
if ($formatType != $ruleType) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
if ($async) {
if (!it.async) throw new Error(''async format in sync schema'');
var $formatRef = ''formats'' + it.util.getProperty($schema) + ''.validate'';
out += '' if (!('' + (it.yieldAwait) + '' '' + ($formatRef) + ''('' + ($data) + ''))) { '';
} else {
out += '' if (! '';
var $formatRef = ''formats'' + it.util.getProperty($schema);
if ($isObject) $formatRef += ''.validate'';
if (typeof $format == ''function'') {
out += '' '' + ($formatRef) + ''('' + ($data) + '') '';
} else {
out += '' '' + ($formatRef) + ''.test('' + ($data) + '') '';
}
out += '') { '';
}
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''format'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { format:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match format \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],33:[function(require,module,exports){
''use strict'';
module.exports = function generate_items(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId;
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if (Array.isArray($schema)) {
var $additionalItems = it.schema.additionalItems;
if ($additionalItems === false) {
out += '' '' + ($valid) + '' = '' + ($data) + ''.length <= '' + ($schema.length) + ''; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schema.length) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have more than '' + ($schema.length) + '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($i) + '') { '';
var $passData = $data + ''['' + $i + '']'';
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
$it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
$it.dataPathArr[$dataNxt] = $i;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if (typeof $additionalItems == ''object'' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
$it.schema = $additionalItems;
$it.schemaPath = it.schemaPath + ''.additionalItems'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($schema.length) + '') {  for (var '' + ($idx) + '' = '' + ($schema.length) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
} else if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += ''  for (var '' + ($idx) + '' = '' + (0) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],34:[function(require,module,exports){
''use strict'';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
out += ''var division'' + ($lvl) + '';if ('';
if ($isData) {
out += '' '' + ($schemaValue) + '' !== undefined && ( typeof '' + ($schemaValue) + '' != \\\\''number\\\\'' || '';
}
out += '' (division'' + ($lvl) + '' = '' + ($data) + '' / '' + ($schemaValue) + '', '';
if (it.opts.multipleOfPrecision) {
out += '' Math.abs(Math.round(division'' + ($lvl) + '') - division'' + ($lvl) + '') > 1e-'' + (it.opts.multipleOfPrecision) + '' '';
} else {
out += '' division'' + ($lvl) + '' !== parseInt(division'' + ($lvl) + '') '';
}
out += '' ) '';
if ($isData) {
out += ''  )  '';
}
out += '' ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''multipleOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { multipleOf: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be multiple of '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],35:[function(require,module,exports){
''use strict'';
module.exports = function generate_not(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.createErrors = false;
var $allErrorsOption;
if ($it.opts.allErrors) {
$allErrorsOption = $it.opts.allErrors;
$it.opts.allErrors = false;
}
out += '' '' + (it.validate($it)) + '' '';
$it.createErrors = true;
if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if ('' + ($nextValid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
} else {
out += ''  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if ($breakOnError) {
out += '' if (false) { '';
}
}
return out;
}
},{}],36:[function(require,module,exports){
''use strict'';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
out += ''var '' + ($errs) + '' = errors;var prevValid'' + ($lvl) + '' = false;var '' + ($valid) + '' = false;'';
var $currentBaseId = $it.baseId;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
} else {
out += '' var '' + ($nextValid) + '' = true; '';
}
if ($i) {
out += '' if ('' + ($nextValid) + '' && prevValid'' + ($lvl) + '') '' + ($valid) + '' = false; else { '';
$closingBraces += ''}'';
}
out += '' if ('' + ($nextValid) + '') '' + ($valid) + '' = prevValid'' + ($lvl) + '' = true;'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '''' + ($closingBraces) + ''if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''oneOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match exactly one schema in oneOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += ''} else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; }'';
if (it.opts.allErrors) {
out += '' } '';
}
return out;
}
},{}],37:[function(require,module,exports){
''use strict'';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $regexp = $isData ? ''(new RegExp('' + $schemaValue + ''))'' : it.usePattern($schema);
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' !'' + ($regexp) + ''.test('' + ($data) + '') ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''pattern'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { pattern:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match pattern \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],38:[function(require,module,exports){
''use strict'';
module.exports = function generate_properties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl;
var $schemaKeys = Object.keys($schema || {}),
$pProperties = it.schema.patternProperties || {},
$pPropertyKeys = Object.keys($pProperties),
$aProperties = it.schema.additionalProperties,
$someProperties = $schemaKeys.length || $pPropertyKeys.length,
$noAdditional = $aProperties === false,
$additionalIsSchema = typeof $aProperties == ''object'' && Object.keys($aProperties).length,
$removeAdditional = it.opts.removeAdditional,
$checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
var $required = it.schema.required;
if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
if (it.opts.patternGroups) {
var $pgProperties = it.schema.patternGroups || {},
$pgPropertyKeys = Object.keys($pgProperties);
}
out += ''var '' + ($errs) + '' = errors;var '' + ($nextValid) + '' = true;'';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined;'';
}
if ($checkAdditional) {
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
if ($someProperties) {
out += '' var isAdditional'' + ($lvl) + '' = !(false '';
if ($schemaKeys.length) {
if ($schemaKeys.length > 5) {
out += '' || validate.schema'' + ($schemaPath) + ''['' + ($key) + ''] '';
} else {
var arr1 = $schemaKeys;
if (arr1) {
var $propertyKey, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$propertyKey = arr1[i1 += 1];
out += '' || '' + ($key) + '' == '' + (it.util.toQuotedString($propertyKey)) + '' '';
}
}
}
}
if ($pPropertyKeys.length) {
var arr2 = $pPropertyKeys;
if (arr2) {
var $pProperty, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$pProperty = arr2[$i += 1];
out += '' || '' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '') '';
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr3 = $pgPropertyKeys;
if (arr3) {
var $pgProperty, $i = -1,
l3 = arr3.length - 1;
while ($i < l3) {
$pgProperty = arr3[$i += 1];
out += '' || '' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '') '';
}
}
}
out += '' ); if (isAdditional'' + ($lvl) + '') { '';
}
if ($removeAdditional == ''all'') {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
var $currentErrorPath = it.errorPath;
var $additionalProperty = ''\\\\'' + '' + $key + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
}
if ($noAdditional) {
if ($removeAdditional) {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
out += '' '' + ($nextValid) + '' = false; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { additionalProperty: \\\\'''' + ($additionalProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have additional properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' break; '';
}
}
} else if ($additionalIsSchema) {
if ($removeAdditional == ''failing'') {
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if (!'' + ($nextValid) + '') { errors = '' + ($errs) + ''; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete '' + ($data) + ''['' + ($key) + '']; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
} else {
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
}
}
it.errorPath = $currentErrorPath;
}
if ($someProperties) {
out += '' } '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
var $useDefaults = it.opts.useDefaults && !it.compositeRule;
if ($schemaKeys.length) {
var arr4 = $schemaKeys;
if (arr4) {
var $propertyKey, i4 = -1,
l4 = arr4.length - 1;
while (i4 < l4) {
$propertyKey = arr4[i4 += 1];
var $sch = $schema[$propertyKey];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
var $prop = it.util.getProperty($propertyKey),
$passData = $data + $prop,
$hasDefault = $useDefaults && $sch.default !== undefined;
$it.schema = $sch;
$it.schemaPath = $schemaPath + $prop;
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($propertyKey);
$it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
$it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
$code = it.util.varReplace($code, $nextData, $passData);
var $useData = $passData;
} else {
var $useData = $nextData;
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '';
}
if ($hasDefault) {
out += '' '' + ($code) + '' '';
} else {
if ($requiredHash && $requiredHash[$propertyKey]) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = false; '';
var $currentErrorPath = it.errorPath,
$currErrSchemaPath = $errSchemaPath,
$missingProperty = it.util.escapeQuotes($propertyKey);
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
$errSchemaPath = it.errSchemaPath + ''/required'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
it.errorPath = $currentErrorPath;
out += '' } else { '';
} else {
if ($breakOnError) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = true; } else { '';
} else {
out += '' if ('' + ($useData) + '' !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '' ) { '';
}
}
out += '' '' + ($code) + '' } '';
}
}
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($pPropertyKeys.length) {
var arr5 = $pPropertyKeys;
if (arr5) {
var $pProperty, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$pProperty = arr5[i5 += 1];
var $sch = $pProperties[$pProperty];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternProperties'' + it.util.getProperty($pProperty);
$it.errSchemaPath = it.errSchemaPath + ''/patternProperties/'' + it.util.escapeFragment($pProperty);
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '')) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr6 = $pgPropertyKeys;
if (arr6) {
var $pgProperty, i6 = -1,
l6 = arr6.length - 1;
while (i6 < l6) {
$pgProperty = arr6[i6 += 1];
var $pgSchema = $pgProperties[$pgProperty],
$sch = $pgSchema.schema;
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternGroups'' + it.util.getProperty($pgProperty) + ''.schema'';
$it.errSchemaPath = it.errSchemaPath + ''/patternGroups/'' + it.util.escapeFragment($pgProperty) + ''/schema'';
out += '' var pgPropCount'' + ($lvl) + '' = 0;  '';
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '')) { pgPropCount'' + ($lvl) + ''++; '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
var $pgMin = $pgSchema.minimum,
$pgMax = $pgSchema.maximum;
if ($pgMin !== undefined || $pgMax !== undefined) {
out += '' var '' + ($valid) + '' = true; '';
var $currErrSchemaPath = $errSchemaPath;
if ($pgMin !== undefined) {
var $limit = $pgMin,
$reason = ''minimum'',
$moreOrLess = ''less'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' >= '' + ($pgMin) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/minimum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($pgMax !== undefined) {
out += '' else '';
}
}
if ($pgMax !== undefined) {
var $limit = $pgMax,
$reason = ''maximum'',
$moreOrLess = ''more'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' <= '' + ($pgMax) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/maximum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],39:[function(require,module,exports){
''use strict'';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$i = ''i'' + $lvl,
$invalidName = ''\\\\'' + '' + $key + '' + \\\\'''',
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
out += '' var '' + ($errs) + '' = errors; '';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined; '';
}
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' var startErrs'' + ($lvl) + '' = errors; '';
var $passData = $key;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if (!'' + ($nextValid) + '') { for (var '' + ($i) + ''=startErrs'' + ($lvl) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { vErrors['' + ($i) + ''].propertyName = '' + ($key) + ''; }   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''propertyNames'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { propertyName: \\\\'''' + ($invalidName) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''property name \\\\\\\\\\\\'''' + ($invalidName) + ''\\\\\\\\\\\\'' is invalid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
if ($breakOnError) {
out += '' break; '';
}
out += '' } }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],40:[function(require,module,exports){
''use strict'';
module.exports = function generate_ref(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $async, $refCode;
if ($schema == ''#'' || $schema == ''#/'') {
if (it.isRoot) {
$async = it.async;
$refCode = ''validate'';
} else {
$async = it.root.schema.$async === true;
$refCode = ''root.refVal[0]'';
}
} else {
var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
if ($refVal === undefined) {
var $message = it.MissingRefError.message(it.baseId, $schema);
if (it.opts.missingRefs == ''fail'') {
console.error($message);
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''$ref'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { ref: \\\\'''' + (it.util.escapeQuotes($schema)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''can\\\\\\\\\\\\''t resolve reference '' + (it.util.escapeQuotes($schema)) + ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: '' + (it.util.toQuotedString($schema)) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
if ($breakOnError) {
out += '' if (false) { '';
}
} else if (it.opts.missingRefs == ''ignore'') {
console.warn($message);
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
throw new it.MissingRefError(it.baseId, $schema, $message);
}
} else if ($refVal.inline) {
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $refVal.schema;
$it.schemaPath = '''';
$it.errSchemaPath = $schema;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $refVal.code);
out += '' '' + ($code) + '' '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
}
} else {
$async = $refVal.$async === true;
$refCode = $refVal.code;
}
}
if ($refCode) {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
if (it.opts.passContext) {
out += '' '' + ($refCode) + ''.call(this, '';
} else {
out += '' '' + ($refCode) + ''( '';
}
out += '' '' + ($data) + '', (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '', rootData)  '';
var __callValidate = out;
out = $$outStack.pop();
if ($async) {
if (!it.async) throw new Error(''async schema referenced by sync schema'');
if ($breakOnError) {
out += '' var '' + ($valid) + ''; '';
}
out += '' try { '' + (it.yieldAwait) + '' '' + (__callValidate) + ''; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = true; '';
}
out += '' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = false; '';
}
out += '' } '';
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
}
} else {
out += '' if (!'' + (__callValidate) + '') { if (vErrors === null) vErrors = '' + ($refCode) + ''.errors; else vErrors = vErrors.concat('' + ($refCode) + ''.errors); errors = vErrors.length; } '';
if ($breakOnError) {
out += '' else { '';
}
}
}
return out;
}
},{}],41:[function(require,module,exports){
''use strict'';
module.exports = function generate_required(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $vSchema = ''schema'' + $lvl;
if (!$isData) {
if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
var $required = [];
var arr1 = $schema;
if (arr1) {
var $property, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$property = arr1[i1 += 1];
var $propertySch = it.schema.properties[$property];
if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
$required[$required.length] = $property;
}
}
}
} else {
var $required = $schema;
}
}
if ($isData || $required.length) {
var $currentErrorPath = it.errorPath,
$loopRequired = $isData || $required.length >= it.opts.loopRequired,
$ownProperties = it.opts.ownProperties;
if ($breakOnError) {
out += '' var missing'' + ($lvl) + ''; '';
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
out += '' var '' + ($valid) + '' = true; '';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { '' + ($valid) + '' = '' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += ''; if (!'' + ($valid) + '') break; } '';
if ($isData) {
out += ''  }  '';
}
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
} else {
out += '' if ( '';
var arr2 = $required;
if (arr2) {
var $propertyKey, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$propertyKey = arr2[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '') {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
}
} else {
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
if ($isData) {
out += '' if ('' + ($vSchema) + '' && !Array.isArray('' + ($vSchema) + '')) {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ('' + ($vSchema) + '' !== undefined) { '';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { if ('' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } '';
if ($isData) {
out += ''  }  '';
}
} else {
var arr3 = $required;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
}
it.errorPath = $currentErrorPath;
} else if ($breakOnError) {
out += '' if (true) {'';
}
return out;
}
},{}],42:[function(require,module,exports){
''use strict'';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (($schema || $isData) && it.opts.uniqueItems !== false) {
if ($isData) {
out += '' var '' + ($valid) + ''; if ('' + ($schemaValue) + '' === false || '' + ($schemaValue) + '' === undefined) '' + ($valid) + '' = true; else if (typeof '' + ($schemaValue) + '' != \\\\''boolean\\\\'') '' + ($valid) + '' = false; else { '';
}
out += '' var '' + ($valid) + '' = true; if ('' + ($data) + ''.length > 1) { var i = '' + ($data) + ''.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal('' + ($data) + ''[i], '' + ($data) + ''[j])) { '' + ($valid) + '' = false; break outer; } } } } '';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''uniqueItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { i: i, j: j } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have duplicate items (items ## \\\\'' + j + \\\\'' and \\\\'' + i + \\\\'' are identical)\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],43:[function(require,module,exports){
''use strict'';
module.exports = function generate_validate(it, $keyword, $ruleType) {
var out = '''';
var $async = it.schema.$async === true,
$refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, ''$ref''),
$id = it.self._getId(it.schema);
if (it.isTop) {
if ($async) {
it.async = true;
var $es7 = it.opts.async == ''es7'';
it.yieldAwait = $es7 ? ''await'' : ''yield'';
}
out += '' var validate = '';
if ($async) {
if ($es7) {
out += '' (async function '';
} else {
if (it.opts.async != ''*'') {
out += ''co.wrap'';
}
out += ''(function* '';
}
} else {
out += '' (function '';
}
out += '' (data, dataPath, parentData, parentDataProperty, rootData) { \\\\''use strict\\\\''; '';
if ($id && (it.opts.sourceCode || it.opts.processCode)) {
out += '' '' + (''/\\\\*# sourceURL='' + $id + '' */'') + '' '';
}
}
if (typeof it.schema == ''boolean'' || !($refKeywords || it.schema.$ref)) {
var $keyword = ''false schema'';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
if (it.schema === false) {
if (it.isTop) {
$breakOnError = true;
} else {
out += '' var '' + ($valid) + '' = false; '';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''false schema'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''boolean schema is false\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
if (it.isTop) {
if ($async) {
out += '' return data; '';
} else {
out += '' validate.errors = null; return true; '';
}
} else {
out += '' var '' + ($valid) + '' = true; '';
}
}
if (it.isTop) {
out += '' }); return validate; '';
}
return out;
}
if (it.isTop) {
var $top = it.isTop,
$lvl = it.level = 0,
$dataLvl = it.dataLevel = 0,
$data = ''data'';
it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
it.baseId = it.baseId || it.rootId;
delete it.isTop;
it.dataPathArr = [undefined];
out += '' var vErrors = null; '';
out += '' var errors = 0;     '';
out += '' if (rootData === undefined) rootData = data; '';
} else {
var $lvl = it.level,
$dataLvl = it.dataLevel,
$data = ''data'' + ($dataLvl || '''');
if ($id) it.baseId = it.resolve.url(it.baseId, $id);
if ($async && !it.async) throw new Error(''async schema in sync schema'');
out += '' var errs_'' + ($lvl) + '' = errors;'';
}
var $valid = ''valid'' + $lvl,
$breakOnError = !it.opts.allErrors,
$closingBraces1 = '''',
$closingBraces2 = '''';
var $errorKeyword;
var $typeSchema = it.schema.type,
$typeIsArray = Array.isArray($typeSchema);
if ($typeIsArray && $typeSchema.length == 1) {
$typeSchema = $typeSchema[0];
$typeIsArray = false;
}
if (it.schema.$ref && $refKeywords) {
if (it.opts.extendRefs == ''fail'') {
throw new Error(''$ref: validation keywords used in schema at path \\" '' + it.errSchemaPath + '' \\" (see option extendRefs)'');
} else if (it.opts.extendRefs !== true) {
$refKeywords = false;
console.warn(''$ref: keywords ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
if ($typeSchema) {
if (it.opts.coerceTypes) {
var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
}
var $rulesGroup = it.RULES.types[$typeSchema];
if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'',
$method = $typeIsArray ? ''checkDataTypes'' : ''checkDataType'';
out += '' if ('' + (it.util[$method]($typeSchema, $data, true)) + '') { '';
if ($coerceToTypes) {
var $dataType = ''dataType'' + $lvl,
$coerced = ''coerced'' + $lvl;
out += '' var '' + ($dataType) + '' = typeof '' + ($data) + ''; '';
if (it.opts.coerceTypes == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''object\\\\'' && Array.isArray('' + ($data) + '')) '' + ($dataType) + '' = \\\\''array\\\\''; '';
}
out += '' var '' + ($coerced) + '' = undefined; '';
var $bracesCoercion = '''';
var arr1 = $coerceToTypes;
if (arr1) {
var $type, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$type = arr1[$i += 1];
if ($i) {
out += '' if ('' + ($coerced) + '' === undefined) { '';
$bracesCoercion += ''}'';
}
if (it.opts.coerceTypes == ''array'' && $type != ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''array\\\\'' && '' + ($data) + ''.length == 1) { '' + ($coerced) + '' = '' + ($data) + '' = '' + ($data) + ''[0]; '' + ($dataType) + '' = typeof '' + ($data) + '';  } '';
}
if ($type == ''string'') {
out += '' if ('' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'') '' + ($coerced) + '' = \\\\''\\\\'' + '' + ($data) + ''; else if ('' + ($data) + '' === null) '' + ($coerced) + '' = \\\\''\\\\''; '';
} else if ($type == ''number'' || $type == ''integer'') {
out += '' if ('' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' === null || ('' + ($dataType) + '' == \\\\''string\\\\'' && '' + ($data) + '' && '' + ($data) + '' == +'' + ($data) + '' '';
if ($type == ''integer'') {
out += '' && !('' + ($data) + '' % 1)'';
}
out += '')) '' + ($coerced) + '' = +'' + ($data) + ''; '';
} else if ($type == ''boolean'') {
out += '' if ('' + ($data) + '' === \\\\''false\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === null) '' + ($coerced) + '' = false; else if ('' + ($data) + '' === \\\\''true\\\\'' || '' + ($data) + '' === 1) '' + ($coerced) + '' = true; '';
} else if ($type == ''null'') {
out += '' if ('' + ($data) + '' === \\\\''\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === false) '' + ($coerced) + '' = null; '';
} else if (it.opts.coerceTypes == ''array'' && $type == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''string\\\\'' || '' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' == null) '' + ($coerced) + '' = ['' + ($data) + '']; '';
}
}
}
out += '' '' + ($bracesCoercion) + '' if ('' + ($coerced) + '' === undefined) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  '';
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' '' + ($data) + '' = '' + ($coerced) + ''; '';
if (!$dataLvl) {
out += ''if ('' + ($parentData) + '' !== undefined)'';
}
out += '' '' + ($parentData) + ''['' + ($parentDataProperty) + ''] = '' + ($coerced) + ''; } '';
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
}
out += '' } '';
}
}
if (it.schema.$ref && !$refKeywords) {
out += '' '' + (it.RULES.all.$ref.code(it, ''$ref'')) + '' '';
if ($breakOnError) {
out += '' } if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
} else {
if (it.opts.v5 && it.schema.patternGroups) {
console.warn(''keyword \\" patternGroups \\" is deprecated and disabled. Use option patternGroups: true to enable.'');
}
var arr2 = it.RULES;
if (arr2) {
var $rulesGroup, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$rulesGroup = arr2[i2 += 1];
if ($shouldUseGroup($rulesGroup)) {
if ($rulesGroup.type) {
out += '' if ('' + (it.util.checkDataType($rulesGroup.type, $data)) + '') { '';
}
if (it.opts.useDefaults && !it.compositeRule) {
if ($rulesGroup.type == ''object'' && it.schema.properties) {
var $schema = it.schema.properties,
$schemaKeys = Object.keys($schema);
var arr3 = $schemaKeys;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $sch = $schema[$propertyKey];
if ($sch.default !== undefined) {
var $passData = $data + it.util.getProperty($propertyKey);
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
} else if ($rulesGroup.type == ''array'' && Array.isArray(it.schema.items)) {
var arr4 = it.schema.items;
if (arr4) {
var $sch, $i = -1,
l4 = arr4.length - 1;
while ($i < l4) {
$sch = arr4[$i += 1];
if ($sch.default !== undefined) {
var $passData = $data + ''['' + $i + '']'';
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
}
}
var arr5 = $rulesGroup.rules;
if (arr5) {
var $rule, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$rule = arr5[i5 += 1];
if ($shouldUseRule($rule)) {
var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
if ($code) {
out += '' '' + ($code) + '' '';
if ($breakOnError) {
$closingBraces1 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces1) + '' '';
$closingBraces1 = '''';
}
if ($rulesGroup.type) {
out += '' } '';
if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
out += '' else { '';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
}
if ($breakOnError) {
out += '' if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces2) + '' '';
}
if ($top) {
if ($async) {
out += '' if (errors === 0) return data;           '';
out += '' else throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; '';
out += '' return errors === 0;       '';
}
out += '' }); return validate;'';
} else {
out += '' var '' + ($valid) + '' = errors === errs_'' + ($lvl) + '';'';
}
out = it.util.cleanUpCode(out);
if ($top) {
out = it.util.finalCleanUpCode(out, $async);
}
function $shouldUseGroup($rulesGroup) {
var rules = $rulesGroup.rules;
for (var i = 0; i < rules.length; i++)
if ($shouldUseRule(rules[i])) return true;
}
function $shouldUseRule($rule) {
return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImlementsSomeKeyword($rule));
}
function $ruleImlementsSomeKeyword($rule) {
var impl = $rule.implements;
for (var i = 0; i < impl.length; i++)
if (it.schema[impl[i]] !== undefined) return true;
}
return out;
}
},{}],44:[function(require,module,exports){
''use strict'';
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require(''./dotjs/custom'');
module.exports = {
add: addKeyword,
get: getKeyword,
remove: removeKeyword
};
/**
* Define custom keyword
* @this  Ajv
* @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
* @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
*/
function addKeyword(keyword, definition) {
/* jshint validthis: true */
/* eslint no-shadow: 0 */
var RULES = this.RULES;
if (RULES.keywords[keyword])
throw new Error(''Keyword '' + keyword + '' is already defined'');
if (!IDENTIFIER.test(keyword))
throw new Error(''Keyword '' + keyword + '' is not a valid identifier'');
if (definition) {
if (definition.macro && definition.valid !== undefined)
throw new Error(''\\" valid \\" option cannot be used with macro keywords'');
var dataType = definition.type;
if (Array.isArray(dataType)) {
var i, len = dataType.length;
for (i=0; i<len; i++) checkDataType(dataType[i]);
for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
} else {
if (dataType) checkDataType(dataType);
_addRule(keyword, dataType, definition);
}
var $data = definition.$data === true && this._opts.$data;
if ($data && !definition.validate)
throw new Error(''$data support: \\" validate \\" function is not defined'');
var metaSchema = definition.metaSchema;
if (metaSchema) {
if ($data) {
metaSchema = {
anyOf: [
metaSchema,
{ ''$ref'': ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
definition.validateSchema = this.compile(metaSchema, true);
}
}
RULES.keywords[keyword] = RULES.all[keyword] = true;
function _addRule(keyword, dataType, definition) {
var ruleGroup;
for (var i=0; i<RULES.length; i++) {
var rg = RULES[i];
if (rg.type == dataType) {
ruleGroup = rg;
break;
}
}
if (!ruleGroup) {
ruleGroup = { type: dataType, rules: [] };
RULES.push(ruleGroup);
}
var rule = {
keyword: keyword,
definition: definition,
custom: true,
code: customRuleCode,
implements: definition.implements
};
ruleGroup.rules.push(rule);
RULES.custom[keyword] = rule;
}
function checkDataType(dataType) {
if (!RULES.types[dataType]) throw new Error(''Unknown type '' + dataType);
}
}
/**
* Get keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
* @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
*/
function getKeyword(keyword) {
/* jshint validthis: true */
var rule = this.RULES.custom[keyword];
return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
* Remove keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
*/
function removeKeyword(keyword) {
/* jshint validthis: true */
var RULES = this.RULES;
delete RULES.keywords[keyword];
delete RULES.all[keyword];
delete RULES.custom[keyword];
for (var i=0; i<RULES.length; i++) {
var rules = RULES[i].rules;
for (var j=0; j<rules.length; j++) {
if (rules[j].keyword == keyword) {
rules.splice(j, 1);
break;
}
}
}
}
},{\\"./ dotjs / custom \\":29}],45:[function(require,module,exports){
''use strict'';
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
module.exports = function (ajv) {
var defaultMeta = ajv._opts.defaultMeta;
var metaSchemaRef = typeof defaultMeta == ''string''
? { $ref: defaultMeta }
: ajv.getSchema(META_SCHEMA_ID)
? { $ref: META_SCHEMA_ID }
: {};
ajv.addKeyword(''patternGroups'', {
// implemented in properties.jst
metaSchema: {
type: ''object'',
additionalProperties: {
type: ''object'',
required: [ ''schema'' ],
properties: {
maximum: {
type: ''integer'',
minimum: 0
},
minimum: {
type: ''integer'',
minimum: 0
},
schema: metaSchemaRef
},
additionalProperties: false
}
}
});
ajv.RULES.all.properties.implements.push(''patternGroups'');
};
},{}],46:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" https: / / raw.githubusercontent.com / epoberezkin / ajv / master / lib / refs / $ data.json # \\",
\\" description \\": \\" Meta - SCHEMA FOR $ data reference (json - SCHEMA EXTENSION proposal) \\",
\\" TYPE \\": \\" object \\",
\\" required \\": [ \\" $ data \\" ],
\\" properties \\": {
\\" $ data \\": {
\\" TYPE \\": \\" string \\",
\\" anyOf \\": [
{ \\" format \\": \\" relative - json - pointer \\" },
{ \\" format \\": \\" json - pointer \\" }
]
}
},
\\" additionalProperties \\": false
}
},{}],47:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" title \\": \\" Core SCHEMA meta - SCHEMA \\",
\\" definitions \\": {
\\" schemaArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" items \\": { \\" $ ref \\": \\" # \\" }
},
\\" nonNegativeInteger \\": {
\\" TYPE \\": \\" integer \\",
\\" minimum \\": 0
},
\\" nonNegativeIntegerDefault0 \\": {
\\" allOf \\": [
{ \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
{ \\" DEFAULT \\": 0 }
]
},
\\" simpleTypes \\": {
\\" enum \\": [
\\" ARRAY \\",
\\" boolean \\",
\\" integer \\",
\\" NULL \\",
\\" number \\",
\\" object \\",
\\" string \\"
]
},
\\" stringArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" TYPE \\": \\" string \\" },
\\" uniqueItems \\": true,
\\" DEFAULT \\": []
}
},
\\" TYPE \\": [\\" object \\", \\" boolean \\"],
\\" properties \\": {
\\" $ id \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" $ SCHEMA \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri \\"
},
\\" $ ref \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" title \\": {
\\" TYPE \\": \\" string \\"
},
\\" description \\": {
\\" TYPE \\": \\" string \\"
},
\\" DEFAULT \\": {},
\\" multipleOf \\": {
\\" TYPE \\": \\" number \\",
\\" exclusiveMinimum \\": 0
},
\\" maximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMaximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" minimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMinimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" maxLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" pattern \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" regex \\"
},
\\" additionalItems \\": { \\" $ ref \\": \\" # \\" },
\\" items \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / schemaArray \\" }
],
\\" DEFAULT \\": {}
},
\\" maxItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" uniqueItems \\": {
\\" TYPE \\": \\" boolean \\",
\\" DEFAULT \\": false
},
\\" contains \\": { \\" $ ref \\": \\" # \\" },
\\" maxProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" required \\": { \\" $ ref \\": \\" # / definitions / stringArray \\" },
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" definitions \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" properties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" patternProperties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" dependencies \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / stringArray \\" }
]
}
},
\\" propertyNames \\": { \\" $ ref \\": \\" # \\" },
\\" const \\": {},
\\" enum \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" uniqueItems \\": true
},
\\" TYPE \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
{
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
\\" minItems \\": 1,
\\" uniqueItems \\": true
}
]
},
\\" format \\": { \\" TYPE \\": \\" string \\" },
\\" allOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" anyOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" oneOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" NOT \\": { \\" $ ref \\": \\" # \\" }
},
\\" DEFAULT \\": {}
}
},{}],48:[function(require,module,exports){
/**
* slice() reference.
*/
var slice = Array.prototype.slice;
/**
* Expose \`co\`.
*/
module.exports = co[''default''] = co.co = co;
/**
* Wrap the given generator \`fn\` into a
* function that returns a promise.
* This is a separate function so that
* every \`co()\` call doesn''t create a new,
* unnecessary closure.
*
* @param {GeneratorFunction} fn
* @return {Function}
* @api public
*/
co.wrap = function (fn) {
createPromise.__generatorFunction__ = fn;
return createPromise;
function createPromise() {
return co.call(this, fn.apply(this, arguments));
}
};
/**
* Execute the generator function or a generator
* and return a promise.
*
* @param {Function} fn
* @return {Promise}
* @api public
*/
function co(gen) {
var ctx = this;
var args = slice.call(arguments, 1)
// we wrap everything in a promise to avoid promise chaining,
// which leads to memory leak errors.
// see https://github.com/tj/co/issues/180
return new Promise(function(resolve, reject) {
if (typeof gen === ''function'') gen = gen.apply(ctx, args);
if (!gen || typeof gen.next !== ''function'') return resolve(gen);
onFulfilled();
/**
* @param {Mixed} res
* @return {Promise}
* @api private
*/
function onFulfilled(res) {
var ret;
try {
ret = gen.next(res);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* @param {Error} err
* @return {Promise}
* @api private
*/
function onRejected(err) {
var ret;
try {
ret = gen.throw(err);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* Get the next value in the generator,
* return a promise.
*
* @param {Object} ret
* @return {Promise}
* @api private
*/
function next(ret) {
if (ret.done) return resolve(ret.value);
var value = toPromise.call(ctx, ret.value);
if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
return onRejected(new TypeError(''You may only yield a function, promise, generator, array, or object, ''
+ ''but the following object was passed: \\" '' + String(ret.value) + '' \\"''));
}
});
}
/**
* Convert a \`yield\`ed value into a promise.
*
* @param {Mixed} obj
* @return {Promise}
* @api private
*/
function toPromise(obj) {
if (!obj) return obj;
if (isPromise(obj)) return obj;
if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
if (''function'' == typeof obj) return thunkToPromise.call(this, obj);
if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
if (isObject(obj)) return objectToPromise.call(this, obj);
return obj;
}
/**
* Convert a thunk to a promise.
*
* @param {Function}
* @return {Promise}
* @api private
*/
function thunkToPromise(fn) {
var ctx = this;
return new Promise(function (resolve, reject) {
fn.call(ctx, function (err, res) {
if (err) return reject(err);
if (arguments.length > 2) res = slice.call(arguments, 1);
resolve(res);
});
});
}
/**
* Convert an array of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Array} obj
* @return {Promise}
* @api private
*/
function arrayToPromise(obj) {
return Promise.all(obj.map(toPromise, this));
}
/**
* Convert an object of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Object} obj
* @return {Promise}
* @api private
*/
function objectToPromise(obj){
var results = new obj.constructor();
var keys = Object.keys(obj);
var promises = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var promise = toPromise.call(this, obj[key]);
if (promise && isPromise(promise)) defer(promise, key);
else results[key] = obj[key];
}
return Promise.all(promises).then(function () {
return results;
});
function defer(promise, key) {
// predefine the key in the result
results[key] = undefined;
promises.push(promise.then(function (res) {
results[key] = res;
}));
}
}
/**
* Check if \`obj\` is a promise.
*
* @param {Object} obj
* @return {Boolean}
* @api private
*/
function isPromise(obj) {
return ''function'' == typeof obj.then;
}
/**
* Check if \`obj\` is a generator.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGenerator(obj) {
return ''function'' == typeof obj.next && ''function'' == typeof obj.throw;
}
/**
* Check if \`obj\` is a generator function.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGeneratorFunction(obj) {
var constructor = obj.constructor;
if (!constructor) return false;
if (''GeneratorFunction'' === constructor.name || ''GeneratorFunction'' === constructor.displayName) return true;
return isGenerator(constructor.prototype);
}
/**
* Check for plain object.
*
* @param {Mixed} val
* @return {Boolean}
* @api private
*/
function isObject(val) {
return Object == val.constructor;
}
},{}],49:[function(require,module,exports){
''use strict'';
module.exports = function equal(a, b) {
if (a === b) return true;
var arrA = Array.isArray(a)
, arrB = Array.isArray(b)
, i;
if (arrA && arrB) {
if (a.length != b.length) return false;
for (i = 0; i < a.length; i++)
if (!equal(a[i], b[i])) return false;
return true;
}
if (arrA != arrB) return false;
if (a && b && typeof a === ''object'' && typeof b === ''object'') {
var keys = Object.keys(a);
if (keys.length !== Object.keys(b).length) return false;
var dateA = a instanceof Date
, dateB = b instanceof Date;
if (dateA && dateB) return a.getTime() == b.getTime();
if (dateA != dateB) return false;
var regexpA = a instanceof RegExp
, regexpB = b instanceof RegExp;
if (regexpA && regexpB) return a.toString() == b.toString();
if (regexpA != regexpB) return false;
for (i = 0; i < keys.length; i++)
if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
for (i = 0; i < keys.length; i++)
if(!equal(a[keys[i]], b[keys[i]])) return false;
return true;
}
return false;
};
},{}],50:[function(require,module,exports){
''use strict'';
var traverse = module.exports = function (schema, opts, cb) {
if (typeof opts == ''function'') {
cb = opts;
opts = {};
}
_traverse(opts, cb, schema, '''', schema);
};
traverse.keywords = {
additionalItems: true,
items: true,
contains: true,
additionalProperties: true,
propertyNames: true,
not: true
};
traverse.arrayKeywords = {
items: true,
allOf: true,
anyOf: true,
oneOf: true
};
traverse.propsKeywords = {
definitions: true,
properties: true,
patternProperties: true,
dependencies: true
};
traverse.skipKeywords = {
enum: true,
const: true,
required: true,
maximum: true,
minimum: true,
exclusiveMaximum: true,
exclusiveMinimum: true,
multipleOf: true,
maxLength: true,
minLength: true,
pattern: true,
format: true,
maxItems: true,
minItems: true,
uniqueItems: true,
maxProperties: true,
minProperties: true
};
function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (schema && typeof schema == ''object'' && !Array.isArray(schema)) {
cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
for (var key in schema) {
var sch = schema[key];
if (Array.isArray(sch)) {
if (key in traverse.arrayKeywords) {
for (var i=0; i<sch.length; i++)
_traverse(opts, cb, sch[i], jsonPtr + ''/'' + key + ''/'' + i, rootSchema, jsonPtr, key, schema, i);
}
} else if (key in traverse.propsKeywords) {
if (sch && typeof sch == ''object'') {
for (var prop in sch)
_traverse(opts, cb, sch[prop], jsonPtr + ''/'' + key + ''/'' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
}
} else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
_traverse(opts, cb, sch, jsonPtr + ''/'' + key, rootSchema, jsonPtr, key, schema);
}
}
}
}
function escapeJsonPtr(str) {
return str.replace(/~/g, ''~0'').replace(/\\\\//g, ''~1'');
}
},{}],51:[function(require,module,exports){
var json = typeof JSON !== ''undefined'' ? JSON : require(''jsonify'');
module.exports = function (obj, opts) {
if (!opts) opts = {};
if (typeof opts === ''function'') opts = { cmp: opts };
var space = opts.space || '''';
if (typeof space === ''number'') space = Array(space+1).join('' '');
var cycles = (typeof opts.cycles === ''boolean'') ? opts.cycles : false;
var replacer = opts.replacer || function(key, value) { return value; };
var cmp = opts.cmp && (function (f) {
return function (node) {
return function (a, b) {
var aobj = { key: a, value: node[a] };
var bobj = { key: b, value: node[b] };
return f(aobj, bobj);
};
};
})(opts.cmp);
var seen = [];
return (function stringify (parent, key, node, level) {
var indent = space ? (''\\\\n'' + new Array(level + 1).join(space)) : '''';
var colonSeparator = space ? '': '' : '':'';
if (node && node.toJSON && typeof node.toJSON === ''function'') {
node = node.toJSON();
}
node = replacer.call(parent, key, node);
if (node === undefined) {
return;
}
if (typeof node !== ''object'' || node === null) {
return json.stringify(node);
}
if (isArray(node)) {
var out = [];
for (var i = 0; i < node.length; i++) {
var item = stringify(node, i, node[i], level+1) || json.stringify(null);
out.push(indent + space + item);
}
return ''['' + out.join('','') + indent + '']'';
}
else {
if (seen.indexOf(node) !== -1) {
if (cycles) return json.stringify(''__cycle__'');
throw new TypeError(''Converting circular structure to JSON'');
}
else seen.push(node);
var keys = objectKeys(node).sort(cmp && cmp(node));
var out = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var value = stringify(node, key, node[key], level+1);
if(!value) continue;
var keyValue = json.stringify(key)
+ colonSeparator
+ value;
;
out.push(indent + space + keyValue);
}
seen.splice(seen.indexOf(node), 1);
return ''{'' + out.join('','') + indent + ''}'';
}
})({ '''': obj }, '''', obj, 0);
};
var isArray = Array.isArray || function (x) {
return {}.toString.call(x) === ''[object Array]'';
};
var objectKeys = Object.keys || function (obj) {
var has = Object.prototype.hasOwnProperty || function () { return true };
var keys = [];
for (var key in obj) {
if (has.call(obj, key)) keys.push(key);
}
return keys;
};
},{\\" jsonify \\":52}],52:[function(require,module,exports){
exports.parse = require(''./lib/parse'');
exports.stringify = require(''./lib/stringify'');
},{\\"./ lib / parse \\":53,\\"./ lib / stringify \\":54}],53:[function(require,module,exports){
var at, // The index of the current character
ch, // The current character
escapee = {
''\\" '':  '' \\"'',
''\\\\\\\\'': ''\\\\\\\\'',
''/'':  ''/'',
b:    ''\\\\b'',
f:    ''\\\\f'',
n:    ''\\\\n'',
r:    ''\\\\r'',
t:    ''\\\\t''
},
text,
error = function (m) {
// Call error when something is wrong.
throw {
name:    ''SyntaxError'',
message: m,
at:      at,
text:    text
};
},
next = function (c) {
// If a c parameter is provided, verify that it matches the current character.
if (c && c !== ch) {
error(\\" Expected ''\\" + c + \\"'' INSTEAD OF ''\\" + ch + \\"'' \\");
}
// Get the next character. When there are no more characters,
// return the empty string.
ch = text.charAt(at);
at += 1;
return ch;
},
number = function () {
// Parse a number value.
var number,
string = '''';
if (ch === ''-'') {
string = ''-'';
next(''-'');
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
if (ch === ''.'') {
string += ''.'';
while (next() && ch >= ''0'' && ch <= ''9'') {
string += ch;
}
}
if (ch === ''e'' || ch === ''E'') {
string += ch;
next();
if (ch === ''-'' || ch === ''+'') {
string += ch;
next();
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
}
number = +string;
if (!isFinite(number)) {
error(\\" Bad number \\");
} else {
return number;
}
},
string = function () {
// Parse a string value.
var hex,
i,
string = '''',
uffff;
// When parsing for string values, we must look for \\" AND characters. IF (ch == = ''\\"'') { while (NEXT ()) { IF (ch == = ''\\"'') { NEXT (); RETURN string; }
ELSE
IF (ch == = ''\\\\\\\\'') { NEXT (); IF (ch == = ''u'') { uffff = 0; FOR (i = 0; i < 4; i + = 1) { hex = parseInt (NEXT (), 16); IF (! isFinite(hex)) { break; } uffff = uffff * 16 + hex; } string + = String.fromCharCode (uffff); }
ELSE
IF (typeof escapee[ch] == = ''string'') { string + = escapee[ch]; }
ELSE
{ break; } }
ELSE
{ string + = ch; } } } error (\\"Bad string\\"); }, white = FUNCTION () { / / SKIP whitespace. while (ch && ch <= '' '') { NEXT (); } }, word = FUNCTION () { / / TRUE, FALSE, OR null. switch (ch) { CASE ''t'' : NEXT (''t''); NEXT (''r''); NEXT (''u''); NEXT (''e''); RETURN TRUE; CASE ''f'' : NEXT (''f''); NEXT (''a''); NEXT (''l''); NEXT (''s''); NEXT (''e''); RETURN FALSE; CASE ''n'' : NEXT (''n''); NEXT (''u''); NEXT (''l''); NEXT (''l''); RETURN NULL; } error (\\"Unexpected ''\\" + ch + \\"''\\"); }, value, / / Place holder FOR the value function. ARRAY = FUNCTION () { / / Parse an ARRAY value. var ARRAY =[]; IF (ch == = ''['') { NEXT (''[''); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; / / empty ARRAY } while (ch) { array.push (value ()); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; } NEXT ('',''); white (); } } error (\\"Bad array\\"); }, object = FUNCTION () { / / Parse an object value. var KEY, object = {}; IF (ch == = ''{'') { NEXT (''{''); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; / / empty object } while (ch) { KEY = string (); white (); NEXT ('':''); IF (Object.hasOwnProperty.call (object, KEY)) { error (''Duplicate key \\"'' + KEY + ''\\"''); } object[KEY] = value (); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; } NEXT ('',''); white (); } } error (\\"Bad object\\"); }; value = FUNCTION () { / / Parse a json value. It could be an object, an ARRAY, a string, a number, / / OR a word. white (); switch (ch) { CASE ''{'' : RETURN object (); CASE ''['' : RETURN ARRAY (); CASE ''\\"'' : RETURN string (); CASE ''-'' : RETURN number (); default: RETURN ch >= ''0'' && ch <= ''9'' ? number () : word (); } }; / / RETURN the json_parse function. It will have access TO ALL OF the above / / functions AND variables. module.exports = FUNCTION (source, reviver) { var result; text = source; at = 0; ch = '' ''; result = value (); white (); IF (ch) { error (\\"Syntax error\\"); } / / IF there IS a reviver FUNCTION, we recursively walk the new structure, / / passing EACH name / value pair TO the reviver FUNCTION FOR possible / / transformation, starting WITH a TEMPORARY root object that holds the result / / IN an empty key. IF there IS NOT a reviver FUNCTION, we simply RETURN the / / result. RETURN typeof reviver == = ''function'' ? (
FUNCTION walk (
holder, KEY
) { var k, v, value = holder[KEY]; IF (
value && typeof value == = ''object''
) { FOR (
k IN value
) { IF (
Object.prototype.hasOwnProperty.call (
value, k
)
) { v = walk (
value, k
); IF (
v != = undefined
) { value[k] = v; }
ELSE
{ DELETE value[k]; } } } } RETURN reviver.call (
holder, KEY, value
); }({'''' : result }, '''')) : result; }; }, {}], 54:[FUNCTION (require, module, exports) { var cx = /[u0000 u00ad u0600 - u0604 u070f u17b4 u17b5 u200c - u200f u2028 - u202f u2060 - u206f ufeff ufff0 - uffff] / g, escapable = /[\\\\\\\\ \\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,
gap,
indent,
meta = {    // table of character substitutions
''\\\\b'': ''\\\\\\\\b'',
''\\\\t'': ''\\\\\\\\t'',
''\\\\n'': ''\\\\\\\\n'',
''\\\\f'': ''\\\\\\\\f'',
''\\\\r'': ''\\\\\\\\r'',
''\\" '' : '' \\\\\\\\ \\"'',
''\\\\\\\\'': ''\\\\\\\\\\\\\\\\''
},
rep;
function quote(string) {
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
escapable.lastIndex = 0;
return escapable.test(string) ? ''\\" '' + string.replace(escapable, function (a) {
var c = meta[a];
return typeof c === '' string '' ? c :
'' \\\\\\\\u '' + ('' 0000 '' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '' \\"'' : ''\\" '' + string + '' \\"''; } FUNCTION str (KEY, holder) { / / Produce a string FROM holder[KEY].var i, / / The LOOP
counter. k, / / The member key. v, / / The member value. length, mind = gap, partial, value = holder[KEY]; / / IF the value has a toJSON method, CALL it TO obtain a replacement value. IF (value && typeof value == = ''object'' && typeof value.toJSON == = ''function'') { value = value.toJSON (KEY); } / / IF we were called WITH a replacer FUNCTION, THEN
CALL the replacer TO / / obtain a replacement value. IF (
typeof rep == = ''function'') { value = rep.call (holder, KEY, value); } / / What happens NEXT depends ON the value ''s type.
switch (typeof value) {
case '' string '':
return quote(value);
case '' number '':
// JSON numbers must be finite. Encode non-finite numbers as null.
return isFinite(value) ? String(value) : '' NULL '';
case '' boolean '':
case '' NULL '':
// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce '' NULL ''. The case is included here in
// the remote chance that this gets fixed someday.
return String(value);
case '' object '':
if (!value) return '' NULL '';
gap += indent;
partial = [];
// Array.isArray
if (Object.prototype.toString.apply(value) === ''[object ARRAY] '') {
length = value.length;
for (i = 0; i < length; i += 1) {
partial[i] = str(i, value) || '' NULL '';
}
// Join all of the elements together, separated with commas, and
// wrap them in brackets.
v = partial.length === 0 ? ''[] '' : gap ?
''[n '' + gap + partial.join('', n '' + gap) + '' n '' + mind + ''] '' :
''['' + partial.join('', '') + ''] '';
gap = mind;
return v;
}
// If the replacer is an array, use it to select the members to be
// stringified.
if (rep && typeof rep === '' object '') {
length = rep.length;
for (i = 0; i < length; i += 1) {
k = rep[i];
if (typeof k === '' string '') {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
else {
// Otherwise, iterate through all of the keys in the object.
for (k in value) {
if (Object.prototype.hasOwnProperty.call(value, k)) {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
// Join all of the member texts together, separated with commas,
// and wrap them in braces.
v = partial.length === 0 ? '' {}'' : gap ? ''{\\\\n'' + gap + partial.join ('',\\\\n'' + gap) + ''\\\\n'' + mind + ''}'' :''{'' + partial.join ('','') + ''}''; gap = mind; RETURN v; } } module.exports = FUNCTION (value, replacer, space) { var i; gap = ''''; indent = ''''; / / IF the space parameter IS a number, make an indent string containing that / / many spaces. IF (typeof space == = ''number'') { FOR (i = 0; i < space; i + = 1) { indent + = '' ''; } } / / IF the space parameter IS a string, it will be used AS the
indent string.
ELSE
IF (typeof space == = ''string'') { indent = space; } / / IF there IS a replacer, it must be a FUNCTION OR an array. / / Otherwise, throw an error. rep = replacer; IF (replacer && typeof replacer != = ''function'' && (typeof replacer != = ''object'' || typeof replacer.length != = ''number'')) { throw new Error (''JSON.stringify''); } / / Make a fake root object containing our value under
the KEY OF ''''. / / RETURN the result OF stringifying the value. RETURN str ('''', {'''' : value }); }; }, {}]}, {},[7]) (7) });
/* plv8 bundle ends */
RETURN module; })(); ');"
`;

exports[`kitchen sink insert 2`] = `
"INSERT INTO shoelace_data VALUES (1, 2, 3, 'truth', (TRUE));
INSERT INTO shoelace_data ( id, col1, col2, val1, bl2 ) VALUES (1, 2, 3, 'truth', (TRUE));
INSERT INTO shoelace_data DEFAULT VALUES;
INSERT INTO v8.modules ( name, code ) VALUES ('ajv', ' (FUNCTION () { var module = { exports: { } };
var exports = module.exports;
/* plv8 bundle begins */
(FUNCTION (f) {if(typeof exports == = \\"object\\" && typeof module != = \\"undefined\\") {module.exports=f()}else IF (typeof define == = \\"function\\" && define.amd) {define([], f) }else{var g;
IF (typeof
WINDOW != = \\"undefined\\") {g=window}else IF (typeof global != = \\"undefined\\") {g=global}else IF (typeof self != = \\"undefined\\") {g=self}else{g=this}g.ajv = f () }})(function(){var define,
module,
exports;
RETURN (FUNCTION e (t, n, r) {function s (o, u) {if(!n[o]){if(!t[o]){var a = typeof require == \\"function\\" && require;
IF (! u && a)
RETURN a (o,
! 0);
IF (i)
RETURN i (o,
! 0);
var f = new Error (\\"Cannot find module ''\\" + o + \\"''\\");
throw f.code = \\"MODULE_NOT_FOUND\\",
f }var l = n[o] = {exports : {}};
t[o][0].CALL (l.exports, FUNCTION (e) {var n = t[o][1][e];
RETURN s (n ? n:e) },
l,
l.exports,
e,
t,
n,
r) }return n[o].exports }var i = typeof require == \\"function\\" && require;
FOR (var o = 0;
o < r.length;
o + +) s (r[o]);
RETURN s })({1 :[FUNCTION (require, module, exports) { (FUNCTION (global) {
/*! https://mths.be/punycode v1.4.1 by @mathias */
;
(FUNCTION (root) {
/** Detect free variables */
var freeExports = typeof exports == ''object'' && exports && ! exports.nodeType && exports;
var freeModule = typeof module == ''object'' && module && ! module.nodeType && module;
var freeGlobal = typeof global == ''object'' && global;
IF (freeGlobal.global == = freeGlobal || freeGlobal.window == = freeGlobal || freeGlobal.self == = freeGlobal) { root = freeGlobal;
}
/**
* The \`punycode\` object.
* @name punycode
* @type Object
*/
var punycode,
/** Highest positive signed 32-bit float value */
maxInt = 2147483647,
/ / aka. 0x7FFFFFFF
OR 2 ^ 31 - 1
/** Bootstring parameters */
base = 36,
tMin = 1,
tMax = 26,
skew = 38,
damp = 700,
initialBias = 72,
initialN = 128,
/ / 0x80 DELIMITER = ''-'',
/ / ''\\\\x2D''
/** Regular expressions */
regexPunycode = / ^ xn --/, regexNonASCII = /[^ x20 - x7E] /,
/ / unprintable ASCII chars + non - ASCII chars regexSeparators = /[x2E u3002 uFF0E uFF61] / g,
/ / RFC 3490 separators
/** Error messages */
errors = { ''overflow'' :''Overflow: input needs wider integers to process'',
''not-basic'' :''Illegal input >= 0x80 (not a basic code point)'',
''invalid-input'' :''Invalid input'' },
/** Convenience shortcuts */
baseMinusTMin = base - tMin,
floor = Math.floor,
stringFromCharCode = String.fromCharCode,
/** Temporary variable */
KEY;
/*--------------------------------------------------------------------------*/
/**
* A generic error utility function.
* @private
* @param {String} type The error type.
* @returns {Error} Throws a \`RangeError\` with the applicable error message.
*/
FUNCTION error (TYPE) { throw new RangeError (errors[TYPE]);
}
/**
* A generic \`Array#map\` utility function.
* @private
* @param {Array} array The array to iterate over.
* @param {Function} callback The function that gets called for every array
* item.
* @returns {Array} A new array of values returned by the callback function.
*/
FUNCTION map (ARRAY, fn) { var length = array.length;
var result =[];
while (length --) { result[length] = fn (ARRAY[length]);
} RETURN result;
}
/**
* A simple \`Array#map\`-like wrapper to work with domain name strings or email
* addresses.
* @private
* @param {String} domain The domain name or email address.
* @param {Function} callback The function that gets called for every
* character.
* @returns {Array} A new string of characters returned by the callback
* function.
*/
FUNCTION mapDomain (string, fn) { var parts = string.split (''@'');
var result = '''';
IF (parts.length > 1) { / / IN email addresses,
ONLY the DOMAIN name should be punycoded. Leave / / the local part (i.e. everything up TO \`@\`) intact. result = parts[0] + ''@'';
string = parts[1];
} / / Avoid \`split(regex)\` FOR IE8 compatibility. See # 17. string = string.replace(regexSeparators, ''\\\\x2E'');
var labels = string.split (''.'');
var encoded = map (labels, fn).
JOIN (''.'');
RETURN result + encoded;
}
/**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see \`punycode.ucs2.encode\`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
FUNCTION ucs2decode (string) { var output =[], counter = 0, length = string.length, value, extra;
while (counter < length) { value = string.charCodeAt (counter + +);
IF (value >= 0xD800 && value <= 0xDBFF && counter < length) { / / high surrogate,
AND there IS a NEXT character extra = string.charCodeAt (counter + +);
IF ((extra & 0xFC00) == 0xDC00) { / / low surrogate output.push (((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
}
ELSE
{ / / unmatched surrogate;
ONLY append this code unit,
IN CASE the NEXT / / code unit IS the high surrogate OF a surrogate pair output.push (value); counter --; } }
ELSE
{ output.push (value); } } RETURN output; }
/**
* Creates a string based on an array of numeric code points.
* @see \`punycode.ucs2.decode\`
* @memberOf punycode.ucs2
* @name encode
* @param {Array} codePoints The array of numeric code points.
* @returns {String} The new Unicode string (UCS-2).
*/
FUNCTION ucs2encode (ARRAY) { RETURN map (ARRAY, FUNCTION (value) { var output = ''''; IF (value > 0xFFFF) { value - = 0x10000; output + = stringFromCharCode (value >> > 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output + = stringFromCharCode (value); RETURN output; }).join(''''); }
/**
* Converts a basic code point into a digit/integer.
* @see \`digitToBasic()\`
* @private
* @param {Number} codePoint The basic numeric code point value.
* @returns {Number} The numeric value of a basic code point (for use in
* representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
* the code point does not represent a value.
*/
FUNCTION basicToDigit (codePoint) { IF (codePoint - 48 < 10) { RETURN codePoint - 22; } IF (codePoint - 65 < 26) { RETURN codePoint - 65; } IF (codePoint - 97 < 26) { RETURN codePoint - 97; } RETURN base; }
/**
* Converts a digit/integer into a basic code point.
* @see \`basicToDigit()\`
* @private
* @param {Number} digit The numeric value of a basic code point.
* @returns {Number} The basic code point whose value (when used for
* representing integers) is \`digit\`, which needs to be in the range
* \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
* used; else, the lowercase form is used. The behavior is undefined
* if \`flag\` is non-zero and \`digit\` has no uppercase form.
*/
FUNCTION digitToBasic (digit, flag) { / / 0..25 map TO ASCII a..z OR A..Z / / 26..35 map TO ASCII 0..9 RETURN digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }
/**
* Bias adaptation function as per section 3.4 of RFC 3492.
* https://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
FUNCTION adapt (delta, numPoints, firstTime) { var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta + = floor(delta / numPoints); FOR (
/* no initialization */
; delta > baseMinusTMin * tMax >> 1; k + = base) { delta = floor(delta / baseMinusTMin); } RETURN floor(k + (baseMinusTMin + 1) * delta / (delta + skew)); }
/**
* Converts a Punycode string of ASCII-only symbols to a string of Unicode
* symbols.
* @memberOf punycode
* @param {String} input The Punycode string of ASCII-only symbols.
* @returns {String} The resulting string of Unicode symbols.
*/
FUNCTION decode(input) { / / Don ''t use UCS-2
var output = [],
inputLength = input.length,
out,
i = 0,
n = initialN,
bias = initialBias,
basic,
j,
index,
oldi,
w,
k,
digit,
t,
/** Cached calculation results */
baseMinusT;
// Handle the basic code points: let \`basic\` be the number of input code
// points before the last delimiter, or \`0\` if there is none, then copy
// the first basic code points to the output.
basic = input.lastIndexOf(delimiter);
if (basic < 0) {
basic = 0;
}
for (j = 0; j < basic; ++j) {
// if it'' s NOT a basic code point IF (input.charCodeAt (j) >= 0x80) { error (''not-basic''); } output.push (input.charCodeAt (j)); } / / Main decoding loop: START just AFTER the LAST DELIMITER IF ANY basic code / / points were copied; START at the beginning otherwise. FOR (INDEX = basic > 0 ? basic + 1 : 0; INDEX < inputLength;
/* no final expression */) { / / \`index\` IS the INDEX OF the NEXT character TO be consumed. / / Decode a generalized variable - length integer INTO \`delta\`, / / which gets added TO \`i\`.The overflow checking IS easier / / IF we increase \`i\` AS we
go, THEN
subtract OFF its starting / / value at the
END TO obtain \`delta\`. FOR (oldi = i, w = 1, k = base;
/* no condition */
;
k + = base) { IF (INDEX >= inputLength) { error (''invalid-input'');
} digit = basicToDigit (input.charCodeAt (INDEX + +));
IF (digit >= base || digit > floor((maxInt - i) / w)) { error (''overflow'');
} i + = digit * w;
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (digit < t) { break;
} baseMinusT = base - t;
IF (w > floor(maxInt / baseMinusT)) { error (''overflow'');
} w *= baseMinusT;
} out = output.length + 1;
bias = adapt (i - oldi, out, oldi == 0);
/ / \`i\` was supposed TO wrap around
FROM
\`out\` TO \`0\`,
/ / incrementing \`n\` EACH time,
so
we ''ll fix that now:
if (floor(i / out) > maxInt - n) {
error('' overflow '');
}
n += floor(i / out);
i %= out;
// Insert \`n\` at position \`i\` of the output
output.splice(i++, 0, n);
}
return ucs2encode(output);
}
/**
* Converts a string of Unicode symbols (e.g. a domain name label) to a
* Punycode string of ASCII-only symbols.
* @memberOf punycode
* @param {String} input The string of Unicode symbols.
* @returns {String} The resulting Punycode string of ASCII-only symbols.
*/
function encode(input) {
var n,
delta,
handledCPCount,
basicLength,
bias,
j,
m,
q,
k,
t,
currentValue,
output = [],
/** \`inputLength\` will hold the number of code points in \`input\`. */
inputLength,
/** Cached calculation results */
handledCPCountPlusOne,
baseMinusT,
qMinusT;
// Convert the input in UCS-2 to Unicode
input = ucs2decode(input);
// Cache the length
inputLength = input.length;
// Initialize the state
n = initialN;
delta = 0;
bias = initialBias;
// Handle the basic code points
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < 0x80) {
output.push(stringFromCharCode(currentValue));
}
}
handledCPCount = basicLength = output.length;
// \`handledCPCount\` is the number of code points that have been handled;
// \`basicLength\` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if (basicLength) {
output.push(delimiter);
}
// Main encoding loop:
while (handledCPCount < inputLength) {
// All non-basic code points < n have been handled already. Find the next
// larger one:
for (m = maxInt, j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue >= n && currentValue < m) {
m = currentValue;
}
}
// Increase \`delta\` enough to advance the decoder'' s < n,
i > state TO < m,
0 >,
/ / but guard against overflow handledCPCountPlusOne = handledCPCount + 1;
IF (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error (''overflow'');
} delta + = (m - n) * handledCPCountPlusOne;
n = m;
FOR (j = 0;
j < inputLength;
+ + j) { currentValue = input[j];
IF (currentValue < n && + + delta > maxInt) { error (''overflow'');
} IF (currentValue == n) { / / Represent delta AS a generalized variable - length integer FOR (q = delta,
k = base;
/* no condition */
;
k + = base) { t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (q < t) { break;
} qMinusT = q - t;
baseMinusT = base - t;
output.push (stringFromCharCode (digitToBasic (t + qMinusT % baseMinusT, 0)));
q = floor(qMinusT / baseMinusT);
} output.push (stringFromCharCode (digitToBasic (q, 0)));
bias = adapt (delta, handledCPCountPlusOne, handledCPCount == basicLength);
delta = 0;
+ + handledCPCount;
} } + + delta;
+ + n;
} RETURN output.join ('''');
}
/**
* Converts a Punycode string representing a domain name or an email address
* to Unicode. Only the Punycoded parts of the input will be converted, i.e.
* it doesn''t matter if you call it on a string that has already been
* converted to Unicode.
* @memberOf punycode
* @param {String} input The Punycoded domain name or email address to
* convert to Unicode.
* @returns {String} The Unicode representation of the given Punycode
* string.
*/
FUNCTION toUnicode (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexPunycode.test (string) ? decode(string.slice (4).toLowerCase ()) : string;
});
}
/**
* Converts a Unicode string representing a domain name or an email address to
* Punycode. Only the non-ASCII parts of the domain name will be converted,
* i.e. it doesn''t matter if you call it with a domain that''s already in
* ASCII.
* @memberOf punycode
* @param {String} input The domain name or email address to convert, as a
* Unicode string.
* @returns {String} The Punycode representation of the given domain name or
* email address.
*/
FUNCTION toASCII (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexNonASCII.test (string) ? ''xn--'' + encode(string) : string;
});
}
/*--------------------------------------------------------------------------*/
/** Define the public API */
punycode = {
/**
* A string representing the current Punycode.js version number.
* @memberOf punycode
* @type String
*/
''version'' :''1.4.1'',
/**
* An object of methods to convert from JavaScript''s internal character
* representation (UCS-2) to Unicode code points, and back.
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode
* @type Object
*/
''ucs2'' : { ''decode'' : ucs2decode,
''encode'' : ucs2encode },
''decode'' : decode,
''encode'' : encode,
''toASCII'' : toASCII,
''toUnicode'' : toUnicode };
/** Expose \`punycode\` */
/ / SOME AMD build optimizers,
LIKE r.js,
CHECK FOR specific condition patterns / / LIKE the following: IF (typeof define == ''function'' && typeof define.amd == ''object'' && define.amd) { define (''punycode'', FUNCTION () { RETURN punycode;
});
}
ELSE
IF (freeExports && freeModule) { IF (module.exports == freeExports) { / / IN Node.js,
io.js,
OR RingoJS v0.8.0 + freeModule.exports = punycode;
}
ELSE
{ / / IN Narwhal
OR RingoJS v0.7.0 - FOR (KEY IN punycode) { punycode.hasOwnProperty (KEY) && (freeExports[KEY] = punycode[KEY]);
} } }
ELSE
{ / / IN Rhino
OR a web browser root.punycode = punycode;
} }(this));
}).call(this,
typeof global != = \\"undefined\\" ? global : typeof self != = \\"undefined\\" ? self : typeof
WINDOW != = \\"undefined\\" ?
WINDOW : {}) },
{}],
2:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
/ / IF obj.hasOwnProperty has been overridden,
THEN
calling / / obj.hasOwnProperty (prop) will break. / / See: https: / / github.com / joyent / node / issues / 1707 FUNCTION hasOwnProperty (obj, prop) { RETURN Object.prototype.hasOwnProperty.call (obj, prop);
} module.exports = FUNCTION (qs, sep, eq, options) { sep = sep || ''&'';
eq = eq || ''='';
var obj = {};
IF (typeof qs != = ''string'' || qs.length == = 0) { RETURN obj;
} var regexp = / + / g;
qs = qs.split (sep);
var maxKeys = 1000;
IF (options && typeof options.maxKeys == = ''number'') { maxKeys = options.maxKeys;
} var len = qs.length;
/ / maxKeys <= 0 means that we should NOT
LIMIT keys count IF (maxKeys > 0 && len > maxKeys) { len = maxKeys;
} FOR (var i = 0;
i < len;
+ + i) { var x = qs[i].replace(regexp, ''%20''),
idx = x.indexOf (eq),
kstr,
vstr,
k,
v;
IF (idx >= 0) { kstr = x.substr(0, idx);
vstr = x.substr(idx + 1);
}
ELSE
{ kstr = x;
vstr = '''';
} k = decodeURIComponent (kstr);
v = decodeURIComponent (vstr);
IF (! hasOwnProperty (obj, k)) { obj[k] = v;
}
ELSE
IF (isArray (obj[k])) { obj[k].push (v);
}
ELSE
{ obj[k] =[obj[k], v];
} } RETURN obj;
};
var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]'';
};
},
{}],
3:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
var stringifyPrimitive = FUNCTION (v) { switch (typeof v) { CASE ''string'' : RETURN v; CASE ''boolean'' : RETURN v ? ''true'' :''false''; CASE ''number'' : RETURN isFinite(v) ? v : ''''; default: RETURN ''''; } }; module.exports = FUNCTION (obj, sep, eq, name) { sep = sep || ''&''; eq = eq || ''=''; IF (obj == = NULL) { obj = undefined; } IF (typeof obj == = ''object'') { RETURN map (objectKeys (obj), FUNCTION (k) { var ks = encodeURIComponent (stringifyPrimitive (k)) + eq; IF (isArray (obj[k])) { RETURN map (obj[k], FUNCTION (v) { RETURN ks + encodeURIComponent (stringifyPrimitive (v)); }).join(sep); }
ELSE
{ RETURN ks + encodeURIComponent (stringifyPrimitive (obj[k])); } }).join(sep); } IF (! name)
RETURN ''''; RETURN encodeURIComponent (stringifyPrimitive (name)) + eq + encodeURIComponent (stringifyPrimitive (obj)); }; var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]''; }; FUNCTION map (xs, f) { IF (xs.map)
RETURN xs.map (f); var res =[]; FOR (var i = 0; i < xs.length; i + +) { res.push (f (xs[i], i)); } RETURN res; } var objectKeys = Object.keys || FUNCTION (obj) { var res =[]; FOR (var KEY IN obj) { IF (Object.prototype.hasOwnProperty.call (obj, KEY)) res.push (KEY); } RETURN res; }; }, {}], 4:[FUNCTION (require, module, exports) { ''use strict''; exports.decode = exports.parse = require (''./decode''); exports.encode = exports.stringify = require (''./encode''); }, {\\". / decode \\":2,\\"./ encode \\":3}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\" Software \\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\" AS IS
\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
''use strict'';
var punycode = require(''punycode'');
var util = require(''./util'');
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
this.protocol = null;
this.slashes = null;
this.auth = null;
this.host = null;
this.port = null;
this.hostname = null;
this.hash = null;
this.search = null;
this.query = null;
this.pathname = null;
this.path = null;
this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
portPattern = /:[0-9]*$/,
// Special case for a simple path URL
simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,
// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = [''<'', ''>'', ''\\" '', '' \`'', '' '', ''\\\\r'', ''\\\\n'', ''\\\\t''],
// RFC 2396: characters not allowed for various reasons.
unwise = [''{'', ''}'', ''|'', ''\\\\\\\\'', ''^'', ''\` ''].concat(delims),
// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['' \\\\'' ''].concat(unwise),
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['' % '', '' / '', '' ? '', ''; '', '' # ''].concat(autoEscape),
hostEndingChars = ['' / '', '' ? '', '' # ''],
hostnameMaxLen = 255,
hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
// protocols that can allow \\"unsafe\\" and \\"unwise\\" chars.
unsafeProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that never have a hostname.
hostlessProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that always contain a // bit.
slashedProtocol = {
'' http '': true,
'' https '': true,
'' ftp '': true,
'' gopher '': true,
'' file '': true,
'' http: '': true,
'' https: '': true,
'' ftp: '': true,
'' gopher: '': true,
'' file: '': true
},
querystring = require('' querystring '');
function urlParse(url, parseQueryString, slashesDenoteHost) {
if (url && util.isObject(url) && url instanceof Url) return url;
var u = new Url;
u.parse(url, parseQueryString, slashesDenoteHost);
return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
if (!util.isString(url)) {
throw new TypeError(\\"Parameter '' url '' must be a string, not \\" + typeof url);
}
// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex = url.indexOf('' ? ''),
splitter =
(queryIndex !== -1 && queryIndex < url.indexOf('' # '')) ? '' ? '' : '' # '',
uSplit = url.split(splitter),
slashRegex = /\\\\\\\\/g;
uSplit[0] = uSplit[0].replace(slashRegex, '' / '');
url = uSplit.join(splitter);
var rest = url;
// trim before proceeding.
// This is to support parse stuff like \\"  http://foo.com  \\\\n\\"
rest = rest.trim();
if (!slashesDenoteHost && url.split('' # '').length === 1) {
// Try fast path regexp
var simplePath = simplePathPattern.exec(rest);
if (simplePath) {
this.path = rest;
this.href = rest;
this.pathname = simplePath[1];
if (simplePath[2]) {
this.search = simplePath[2];
if (parseQueryString) {
this.query = querystring.parse(this.search.substr(1));
} else {
this.query = this.search.substr(1);
}
} else if (parseQueryString) {
this.search = '''';
this.query = {};
}
return this;
}
}
var proto = protocolPattern.exec(rest);
if (proto) {
proto = proto[0];
var lowerProto = proto.toLowerCase();
this.protocol = lowerProto;
rest = rest.substr(proto.length);
}
// figure out if it'' s got a host / / user@server
IS * always * interpreted AS a hostname, AND url / / resolution will treat / / foo / bar AS host = foo, path = bar because that ''s
// how the browser resolves relative URLs.
if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {
var slashes = rest.substr(0, 2) === '' / / '';
if (slashes && !(proto && hostlessProtocol[proto])) {
rest = rest.substr(2);
this.slashes = true;
}
}
if (!hostlessProtocol[proto] &&
(slashes || (proto && !slashedProtocol[proto]))) {
// there'' s a hostname. / / the FIRST instance OF /, ?,;, OR # ends the host. / / / / IF there IS an @ IN the hostname, THEN
non - host chars * are * allowed / / TO the
LEFT OF the LAST @ sign, unless SOME host - ending character / / comes * BEFORE * the @ - sign. / / URLs are obnoxious. / / / / ex: / / http: / / a@b@c / => user:a@b host:c / / http: / / a@b ? @c => user:a host:c path: / ? @c / / v0.12 TODO (isaacs) : This IS NOT quite how Chrome does things. / / Review our test CASE against browsers more comprehensively. / / find the FIRST instance OF ANY hostEndingChars var hostEnd = - 1; FOR (var i = 0; i < hostEndingChars.length; i + +) { var hec = rest.indexOf (hostEndingChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / at this point, either we have an explicit point
WHERE
the / / auth portion cannot go past, OR the LAST @ char IS the decider. var auth, atSign; IF (hostEnd == = - 1) { / / atSign can be anywhere. atSign = rest.lastIndexOf (''@''); }
ELSE
{ / / atSign must be IN auth portion. / / http: / / a@b / c@d => host:b auth:a path: / c@d atSign = rest.lastIndexOf (''@'', hostEnd); } / / Now we have a portion which IS definitely the auth. / / Pull that off. IF (atSign != = - 1) { auth = rest.slice (0, atSign); rest = rest.slice (atSign + 1); this.auth = decodeURIComponent (auth); } / / the host IS the remaining TO the
LEFT OF the FIRST non - host char hostEnd = - 1; FOR (var i = 0; i < nonHostChars.length; i + +) { var hec = rest.indexOf (nonHostChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / IF we still have NOT hit it, THEN
the entire thing IS a host. IF (hostEnd == = - 1) hostEnd = rest.length; this.host = rest.slice (0, hostEnd); rest = rest.slice (hostEnd); / / pull out port. this.parseHost (); / / we ''ve indicated that there is a hostname,
// so even if it'' s empty, it has TO be present. this.hostname = this.hostname || ''''; / / IF hostname begins WITH[ AND ends WITH] / / assume that it ''s an IPv6 address.
var ipv6Hostname = this.hostname[0] === ''['' &&
this.hostname[this.hostname.length - 1] === ''] '';
// validate a little.
if (!ipv6Hostname) {
var hostparts = this.hostname.split(/\\\\./);
for (var i = 0, l = hostparts.length; i < l; i++) {
var part = hostparts[i];
if (!part) continue;
if (!part.match(hostnamePartPattern)) {
var newpart = '''';
for (var j = 0, k = part.length; j < k; j++) {
if (part.charCodeAt(j) > 127) {
// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart += '' x '';
} else {
newpart += part[j];
}
}
// we test again with ASCII char only
if (!newpart.match(hostnamePartPattern)) {
var validParts = hostparts.slice(0, i);
var notHost = hostparts.slice(i + 1);
var bit = part.match(hostnamePartStart);
if (bit) {
validParts.push(bit[1]);
notHost.unshift(bit[2]);
}
if (notHost.length) {
rest = '' / '' + notHost.join(''.'') + rest;
}
this.hostname = validParts.join(''.'');
break;
}
}
}
}
if (this.hostname.length > hostnameMaxLen) {
this.hostname = '''';
} else {
// hostnames are always lower case.
this.hostname = this.hostname.toLowerCase();
}
if (!ipv6Hostname) {
// IDNA Support: Returns a punycoded representation of \\"domain\\".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn'' t matter IF / / you CALL it WITH a DOMAIN that already IS ASCII - only. this.hostname = punycode.toASCII (
this.hostname); } var p = this.port ? '':'' + this.port : ''''; var h = this.hostname || ''''; this.host = h + p; this.href + = this.host; / / strip[ AND] FROM the hostname / / the host field still retains them, though IF (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); IF (rest[0] != = ''/'') { rest = ''/'' + rest; } } } / / now rest IS SET TO the post - host stuff. / / chop OFF ANY delim chars. IF (! unsafeProtocol[lowerProto]) { / / FIRST, make 100 % sure that ANY \\"autoEscape\\" chars get / / escaped, even IF encodeURIComponent doesn ''t think they
// need to be.
for (var i = 0, l = autoEscape.length; i < l; i++) {
var ae = autoEscape[i];
if (rest.indexOf(ae) === -1)
continue;
var esc = encodeURIComponent(ae);
if (esc === ae) {
esc = escape(ae);
}
rest = rest.split(ae).join(esc);
}
}
// chop off from the tail first.
var hash = rest.indexOf('' # '');
if (hash !== -1) {
// got a fragment string.
this.hash = rest.substr(hash);
rest = rest.slice(0, hash);
}
var qm = rest.indexOf('' ? '');
if (qm !== -1) {
this.search = rest.substr(qm);
this.query = rest.substr(qm + 1);
if (parseQueryString) {
this.query = querystring.parse(this.query);
}
rest = rest.slice(0, qm);
} else if (parseQueryString) {
// no query string, but parseQueryString still requested
this.search = '''';
this.query = {};
}
if (rest) this.pathname = rest;
if (slashedProtocol[lowerProto] &&
this.hostname && !this.pathname) {
this.pathname = '' / '';
}
//to support http.request
if (this.pathname || this.search) {
var p = this.pathname || '''';
var s = this.search || '''';
this.path = p + s;
}
// finally, reconstruct the href based on what has been validated.
this.href = this.format();
return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
// ensure it'' s an object, AND NOT a string url. / / IF it ''s an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if (util.isString(obj)) obj = urlParse(obj);
if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
return obj.format();
}
Url.prototype.format = function() {
var auth = this.auth || '''';
if (auth) {
auth = encodeURIComponent(auth);
auth = auth.replace(/%3A/i, '' : '');
auth += '' @ '';
}
var protocol = this.protocol || '''',
pathname = this.pathname || '''',
hash = this.hash || '''',
host = false,
query = '''';
if (this.host) {
host = auth + this.host;
} else if (this.hostname) {
host = auth + (this.hostname.indexOf('' : '') === -1 ?
this.hostname :
''['' + this.hostname + ''] '');
if (this.port) {
host += '' : '' + this.port;
}
}
if (this.query &&
util.isObject(this.query) &&
Object.keys(this.query).length) {
query = querystring.stringify(this.query);
}
var search = this.search || (query && ('' ? '' + query)) || '''';
if (protocol && protocol.substr(-1) !== '' :'') protocol += '' : '';
// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if (this.slashes ||
(!protocol || slashedProtocol[protocol]) && host !== false) {
host = '' / / '' + (host || '''');
if (pathname && pathname.charAt(0) !== '' / '') pathname = '' / '' + pathname;
} else if (!host) {
host = '''';
}
if (hash && hash.charAt(0) !== '' # '') hash = '' # '' + hash;
if (search && search.charAt(0) !== '' ? '') search = '' ? '' + search;
pathname = pathname.replace(/[?#]/g, function(match) {
return encodeURIComponent(match);
});
search = search.replace('' # '', '' % 23 '');
return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
if (!source) return relative;
return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
if (util.isString(relative)) {
var rel = new Url();
rel.parse(relative, false, true);
relative = rel;
}
var result = new Url();
var tkeys = Object.keys(this);
for (var tk = 0; tk < tkeys.length; tk++) {
var tkey = tkeys[tk];
result[tkey] = this[tkey];
}
// hash is always overridden, no matter what.
// even href=\\"\\" will remove it.
result.hash = relative.hash;
// if the relative url is empty, then there'' s NOTHING
LEFT TO DO here. IF (relative.href == = '''') { result.href = result.format(); RETURN result; } / / hrefs LIKE / / foo / bar always cut TO the protocol. IF (relative.slashes && ! relative.protocol) { / / take everything
EXCEPT
the protocol FROM relative var rkeys = Object.keys (relative); FOR (var rk = 0; rk < rkeys.length; rk + +) { var rkey = rkeys[rk]; IF (rkey != = ''protocol'') result[rkey] = relative[rkey]; } / / urlParse appends TRAILING / TO urls LIKE http: / / www.example.com IF (slashedProtocol[result.protocol] && result.hostname && ! result.pathname) { result.path = result.pathname = ''/''; } result.href = result.format(); RETURN result; } IF (relative.protocol && relative.protocol != = result.protocol) { / / IF it ''s a known url protocol, then changing
// the protocol does weird things
// first, if it'' s NOT file:, THEN
we MUST have a host, / /
AND IF there was a path / / TO
BEGIN
WITH,
THEN
we MUST have a path. / / IF it IS file:,
THEN
the host IS dropped,
/ / because that ''s known to be hostless.
// anything else is assumed to be absolute.
if (!slashedProtocol[relative.protocol]) {
var keys = Object.keys(relative);
for (var v = 0; v < keys.length; v++) {
var k = keys[v];
result[k] = relative[k];
}
result.href = result.format();
return result;
}
result.protocol = relative.protocol;
if (!relative.host && !hostlessProtocol[relative.protocol]) {
var relPath = (relative.pathname || '''').split('' / '');
while (relPath.length && !(relative.host = relPath.shift()));
if (!relative.host) relative.host = '''';
if (!relative.hostname) relative.hostname = '''';
if (relPath[0] !== '''') relPath.unshift('''');
if (relPath.length < 2) relPath.unshift('''');
result.pathname = relPath.join('' / '');
} else {
result.pathname = relative.pathname;
}
result.search = relative.search;
result.query = relative.query;
result.host = relative.host || '''';
result.auth = relative.auth;
result.hostname = relative.hostname || relative.host;
result.port = relative.port;
// to support http.request
if (result.pathname || result.search) {
var p = result.pathname || '''';
var s = result.search || '''';
result.path = p + s;
}
result.slashes = result.slashes || relative.slashes;
result.href = result.format();
return result;
}
var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '' / ''),
isRelAbs = (
relative.host ||
relative.pathname && relative.pathname.charAt(0) === '' / ''
),
mustEndAbs = (isRelAbs || isSourceAbs ||
(result.host && relative.pathname)),
removeAllDots = mustEndAbs,
srcPath = result.pathname && result.pathname.split('' / '') || [],
relPath = relative.pathname && relative.pathname.split('' / '') || [],
psychotic = result.protocol && !slashedProtocol[result.protocol];
// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if (psychotic) {
result.hostname = '''';
result.port = null;
if (result.host) {
if (srcPath[0] === '''') srcPath[0] = result.host;
else srcPath.unshift(result.host);
}
result.host = '''';
if (relative.protocol) {
relative.hostname = null;
relative.port = null;
if (relative.host) {
if (relPath[0] === '''') relPath[0] = relative.host;
else relPath.unshift(relative.host);
}
relative.host = null;
}
mustEndAbs = mustEndAbs && (relPath[0] === '''' || srcPath[0] === '''');
}
if (isRelAbs) {
// it'' s absolute. result.host = (
relative.host || relative.host == = '''') ? relative.host : result.host; result.hostname = (relative.hostname || relative.hostname == = '''') ? relative.hostname : result.hostname; result.search = relative.search; result.query = relative.query; srcPath = relPath; / / fall through TO the dot - handling below. }
ELSE
IF (relPath.length) { / / it ''s relative
// throw away the existing file, and take the new path instead.
if (!srcPath) srcPath = [];
srcPath.pop();
srcPath = srcPath.concat(relPath);
result.search = relative.search;
result.query = relative.query;
} else if (!util.isNullOrUndefined(relative.search)) {
// just pull out the search.
// like href='' ? foo ''.
// Put this after the other two cases because it simplifies the booleans
if (psychotic) {
result.hostname = result.host = srcPath.shift();
//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('' mailto:local1@domain1 '', '' local2@domain2 '')
var authInHost = result.host && result.host.indexOf('' @ '') > 0 ?
result.host.split('' @ '') : false;
if (authInHost) {
result.auth = authInHost.shift();
result.host = result.hostname = authInHost.shift();
}
}
result.search = relative.search;
result.query = relative.query;
//to support http.request
if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
result.path = (result.pathname ? result.pathname : '''') +
(result.search ? result.search : '''');
}
result.href = result.format();
return result;
}
if (!srcPath.length) {
// no path at all.  easy.
// we'' ve already handled the other stuff above. result.pathname = NULL; / / TO support http.request IF (result.search) { result.path = ''/'' + result.search; }
ELSE
{ result.path = NULL; } result.href = result.format(); RETURN result; } / / IF a url ENDs IN. OR.., THEN
it must get a TRAILING slash. / / however, IF it ends IN anything
ELSE
non - slashy, / / THEN
it must NOT get a TRAILING slash. var LAST = srcPath.slice (- 1)[0]; var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (LAST == = ''.'' || LAST == = ''..'') || LAST == = ''''); / / strip single dots, resolve double dots TO parent dir / / IF the path tries TO go above the root, \`up\` ends up > 0 var up = 0; FOR (var i = srcPath.length; i >= 0; i --) { LAST = srcPath[i]; IF (LAST == = ''.'') { srcPath.splice (i, 1); }
ELSE
IF (LAST == = ''..'') { srcPath.splice (i, 1); up + +; }
ELSE
IF (up) { srcPath.splice (i, 1); up --; } } / / IF the path IS allowed TO go above the root, restore LEADING..s IF (! mustEndAbs && ! removeAllDots) { FOR (;up --; up) { srcPath.unshift (''..''); } } IF (mustEndAbs && srcPath[0] != = '''' && (! srcPath[0] || srcPath[0].charAt (0) != = ''/'')) { srcPath.unshift (''''); } IF (hasTrailingSlash && (srcPath.join (''/'').substr(- 1) != = ''/'')) { srcPath.push (''''); } var isAbsolute = srcPath[0] == = '''' || (srcPath[0] && srcPath[0].charAt (0) == = ''/''); / / put the host back IF (psychotic) { result.hostname = result.host = isAbsolute ? '''' : srcPath.length ? srcPath.shift () : ''''; / / occationaly the auth can get stuck ONLY IN host / / this especially happens IN cases LIKE / / url.resolveObject (''mailto:local1@domain1'', ''local2@domain2'') var authInHost = result.host && result.host.indexOf (''@'') > 0 ? result.host.split (''@'') : FALSE; IF (authInHost) { result.auth = authInHost.shift (); result.host = result.hostname = authInHost.shift (); } } mustEndAbs = mustEndAbs || (result.host && srcPath.length); IF (mustEndAbs && ! isAbsolute) { srcPath.unshift (''''); } IF (! srcPath.length) { result.pathname = NULL; result.path = NULL; }
ELSE
{ result.pathname = srcPath.join (''/''); } / / TO support request.http IF (! util.isNull (result.pathname) || ! util.isNull (result.search)) { result.path = (result.pathname ? result.pathname : '''') + (result.search ? result.search : ''''); } result.auth = relative.auth || result.auth; result.slashes = result.slashes || relative.slashes; result.href = result.format(); RETURN result; }; Url.prototype.parseHost = FUNCTION () { var host = this.host; var port = portPattern.exec (host); IF (port) { port = port[0]; IF (port != = '':'') { this.port = port.substr(1); } host = host.substr(0, host.length - port.length); } IF (host) this.hostname = host; }; }, {\\". / util \\":6,\\" punycode \\":1,\\" querystring \\":4}],6:[function(require,module,exports){
''use strict'';
module.exports = {
isString: function(arg) {
return typeof(arg) === ''string'';
},
isObject: function(arg) {
return typeof(arg) === ''object'' && arg !== null;
},
isNull: function(arg) {
return arg === null;
},
isNullOrUndefined: function(arg) {
return arg == null;
}
};
},{}],7:[function(require,module,exports){
module.exports = require(''ajv'');
},{\\" ajv \\":9}],8:[function(require,module,exports){
''use strict'';
var KEYWORDS = [
''multipleOf'',
''maximum'',
''exclusiveMaximum'',
''minimum'',
''exclusiveMinimum'',
''maxLength'',
''minLength'',
''pattern'',
''additionalItems'',
''maxItems'',
''minItems'',
''uniqueItems'',
''maxProperties'',
''minProperties'',
''required'',
''additionalProperties'',
''enum'',
''format'',
''const''
];
module.exports = function (metaSchema, keywordsJsonPointers) {
for (var i=0; i<keywordsJsonPointers.length; i++) {
metaSchema = JSON.parse(JSON.stringify(metaSchema));
var segments = keywordsJsonPointers[i].split(''/'');
var keywords = metaSchema;
var j;
for (j=1; j<segments.length; j++)
keywords = keywords[segments[j]];
for (j=0; j<KEYWORDS.length; j++) {
var key = KEYWORDS[j];
var schema = keywords[key];
if (schema) {
keywords[key] = {
anyOf: [
schema,
{ $ref: ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
}
}
return metaSchema;
};
},{}],9:[function(require,module,exports){
''use strict'';
var compileSchema = require(''./compile'')
, resolve = require(''./compile/resolve'')
, Cache = require(''./cache'')
, SchemaObject = require(''./compile/schema_obj'')
, stableStringify = require(''json-stable-stringify'')
, formats = require(''./compile/formats'')
, rules = require(''./compile/rules'')
, $dataMetaSchema = require(''./$data'')
, patternGroups = require(''./patternGroups'')
, util = require(''./compile/util'')
, co = require(''co'');
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require(''./compile/async'');
var customKeyword = require(''./keyword'');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
var errorClasses = require(''./compile/error_classes'');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
var META_IGNORE_OPTIONS = [ ''removeAdditional'', ''useDefaults'', ''coerceTypes'' ];
var META_SUPPORT_DATA = [''/properties''];
/**
* Creates validator instance.
* Usage: \`Ajv(opts)\`
* @param {Object} opts optional options
* @return {Object} ajv instance
*/
function Ajv(opts) {
if (!(this instanceof Ajv)) return new Ajv(opts);
opts = this._opts = util.copy(opts) || {};
this._schemas = {};
this._refs = {};
this._fragments = {};
this._formats = formats(opts.format);
var schemaUriFormat = this._schemaUriFormat = this._formats[''uri-reference''];
this._schemaUriFormatFunc = function (str) { return schemaUriFormat.test(str); };
this._cache = opts.cache || new Cache;
this._loadingSchemas = {};
this._compilations = [];
this.RULES = rules();
this._getId = chooseGetId(opts);
opts.loopRequired = opts.loopRequired || Infinity;
if (opts.errorDataPath == ''property'') opts._errorDataPathProperty = true;
if (opts.serialize === undefined) opts.serialize = stableStringify;
this._metaOpts = getMetaSchemaOptions(this);
if (opts.formats) addInitialFormats(this);
addDraft6MetaSchema(this);
if (typeof opts.meta == ''object'') this.addMetaSchema(opts.meta);
addInitialSchemas(this);
if (opts.patternGroups) patternGroups(this);
}
/**
* Validate data using schema
* Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
* @this   Ajv
* @param  {String|Object} schemaKeyRef key, ref or schema object
* @param  {Any} data to be validated
* @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
*/
function validate(schemaKeyRef, data) {
var v;
if (typeof schemaKeyRef == ''string'') {
v = this.getSchema(schemaKeyRef);
if (!v) throw new Error(''no schema with key or ref \\" '' + schemaKeyRef + '' \\"'');
} else {
var schemaObj = this._addSchema(schemaKeyRef);
v = schemaObj.validate || this._compile(schemaObj);
}
var valid = v(data);
if (v.$async === true)
return this._opts.async == ''*'' ? co(valid) : valid;
this.errors = v.errors;
return valid;
}
/**
* Create validating function for passed schema.
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
* @return {Function} validating function
*/
function compile(schema, _meta) {
var schemaObj = this._addSchema(schema, undefined, _meta);
return schemaObj.validate || this._compile(schemaObj);
}
/**
* Adds schema to the instance.
* @this   Ajv
* @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
* @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
* @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
* @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
*/
function addSchema(schema, key, _skipValidation, _meta) {
if (Array.isArray(schema)){
for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
return;
}
var id = this._getId(schema);
if (id !== undefined && typeof id != ''string'')
throw new Error(''schema id must be string'');
key = resolve.normalizeId(key || id);
checkUnique(this, key);
this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
}
/**
* Add schema that will be used to validate other schemas
* options in META_IGNORE_OPTIONS are alway set to false
* @this   Ajv
* @param {Object} schema schema object
* @param {String} key optional schema key
* @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
*/
function addMetaSchema(schema, key, skipValidation) {
this.addSchema(schema, key, skipValidation, true);
}
/**
* Validate schema
* @this   Ajv
* @param {Object} schema schema to validate
* @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
* @return {Boolean} true if schema is valid
*/
function validateSchema(schema, throwOrLogError) {
var $schema = schema.$schema;
if ($schema !== undefined && typeof $schema != ''string'')
throw new Error(''$schema must be a string'');
$schema = $schema || this._opts.defaultMeta || defaultMeta(this);
if (!$schema) {
console.warn(''meta-schema not available'');
this.errors = null;
return true;
}
var currentUriFormat = this._formats.uri;
this._formats.uri = typeof currentUriFormat == ''function''
? this._schemaUriFormatFunc
: this._schemaUriFormat;
var valid;
try { valid = this.validate($schema, schema); }
finally { this._formats.uri = currentUriFormat; }
if (!valid && throwOrLogError) {
var message = ''schema is invalid: '' + this.errorsText();
if (this._opts.validateSchema == ''log'') console.error(message);
else throw new Error(message);
}
return valid;
}
function defaultMeta(self) {
var meta = self._opts.meta;
self._opts.defaultMeta = typeof meta == ''object''
? self._getId(meta) || meta
: self.getSchema(META_SCHEMA_ID)
? META_SCHEMA_ID
: undefined;
return self._opts.defaultMeta;
}
/**
* Get compiled schema from the instance by \`key\` or \`ref\`.
* @this   Ajv
* @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
* @return {Function} schema validating function (with property \`schema\`).
*/
function getSchema(keyRef) {
var schemaObj = _getSchemaObj(this, keyRef);
switch (typeof schemaObj) {
case ''object'': return schemaObj.validate || this._compile(schemaObj);
case ''string'': return this.getSchema(schemaObj);
case ''undefined'': return _getSchemaFragment(this, keyRef);
}
}
function _getSchemaFragment(self, ref) {
var res = resolve.schema.call(self, { schema: {} }, ref);
if (res) {
var schema = res.schema
, root = res.root
, baseId = res.baseId;
var v = compileSchema.call(self, schema, root, undefined, baseId);
self._fragments[ref] = new SchemaObject({
ref: ref,
fragment: true,
schema: schema,
root: root,
baseId: baseId,
validate: v
});
return v;
}
}
function _getSchemaObj(self, keyRef) {
keyRef = resolve.normalizeId(keyRef);
return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
* Remove cached schema(s).
* If no parameter is passed all schemas but meta-schemas are removed.
* If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
* Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
* @this   Ajv
* @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
*/
function removeSchema(schemaKeyRef) {
if (schemaKeyRef instanceof RegExp) {
_removeAllSchemas(this, this._schemas, schemaKeyRef);
_removeAllSchemas(this, this._refs, schemaKeyRef);
return;
}
switch (typeof schemaKeyRef) {
case ''undefined'':
_removeAllSchemas(this, this._schemas);
_removeAllSchemas(this, this._refs);
this._cache.clear();
return;
case ''string'':
var schemaObj = _getSchemaObj(this, schemaKeyRef);
if (schemaObj) this._cache.del(schemaObj.cacheKey);
delete this._schemas[schemaKeyRef];
delete this._refs[schemaKeyRef];
return;
case ''object'':
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
this._cache.del(cacheKey);
var id = this._getId(schemaKeyRef);
if (id) {
id = resolve.normalizeId(id);
delete this._schemas[id];
delete this._refs[id];
}
}
}
function _removeAllSchemas(self, schemas, regex) {
for (var keyRef in schemas) {
var schemaObj = schemas[keyRef];
if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
self._cache.del(schemaObj.cacheKey);
delete schemas[keyRef];
}
}
}
/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
if (typeof schema != ''object'' && typeof schema != ''boolean'')
throw new Error(''schema should be object or boolean'');
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schema) : schema;
var cached = this._cache.get(cacheKey);
if (cached) return cached;
shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
var id = resolve.normalizeId(this._getId(schema));
if (id && shouldAddSchema) checkUnique(this, id);
var willValidate = this._opts.validateSchema !== false && !skipValidation;
var recursiveMeta;
if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
this.validateSchema(schema, true);
var localRefs = resolve.ids.call(this, schema);
var schemaObj = new SchemaObject({
id: id,
schema: schema,
localRefs: localRefs,
cacheKey: cacheKey,
meta: meta
});
if (id[0] != ''#'' && shouldAddSchema) this._refs[id] = schemaObj;
this._cache.put(cacheKey, schemaObj);
if (willValidate && recursiveMeta) this.validateSchema(schema, true);
return schemaObj;
}
/* @this   Ajv */
function _compile(schemaObj, root) {
if (schemaObj.compiling) {
schemaObj.validate = callValidate;
callValidate.schema = schemaObj.schema;
callValidate.errors = null;
callValidate.root = root ? root : callValidate;
if (schemaObj.schema.$async === true)
callValidate.$async = true;
return callValidate;
}
schemaObj.compiling = true;
var currentOpts;
if (schemaObj.meta) {
currentOpts = this._opts;
this._opts = this._metaOpts;
}
var v;
try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
finally {
schemaObj.compiling = false;
if (schemaObj.meta) this._opts = currentOpts;
}
schemaObj.validate = v;
schemaObj.refs = v.refs;
schemaObj.refVal = v.refVal;
schemaObj.root = v.root;
return v;
function callValidate() {
var _validate = schemaObj.validate;
var result = _validate.apply(null, arguments);
callValidate.errors = _validate.errors;
return result;
}
}
function chooseGetId(opts) {
switch (opts.schemaId) {
case ''$id'': return _get$Id;
case ''id'': return _getId;
default: return _get$IdOrId;
}
}
function _getId(schema) {
if (schema.$id) console.warn(''schema $id ignored'', schema.$id);
return schema.id;
}
function _get$Id(schema) {
if (schema.id) console.warn(''schema id ignored'', schema.id);
return schema.$id;
}
function _get$IdOrId(schema) {
if (schema.$id && schema.id && schema.$id != schema.id)
throw new Error(''schema $id is different from id'');
return schema.$id || schema.id;
}
/**
* Convert array of error message objects to string
* @this   Ajv
* @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
* @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
* @return {String} human readable string with all errors descriptions
*/
function errorsText(errors, options) {
errors = errors || this.errors;
if (!errors) return ''No errors'';
options = options || {};
var separator = options.separator === undefined ? '', '' : options.separator;
var dataVar = options.dataVar === undefined ? ''data'' : options.dataVar;
var text = '''';
for (var i=0; i<errors.length; i++) {
var e = errors[i];
if (e) text += dataVar + e.dataPath + '' '' + e.message + separator;
}
return text.slice(0, -separator.length);
}
/**
* Add custom format
* @this   Ajv
* @param {String} name format name
* @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
*/
function addFormat(name, format) {
if (typeof format == ''string'') format = new RegExp(format);
this._formats[name] = format;
}
function addDraft6MetaSchema(self) {
var $dataSchema;
if (self._opts.$data) {
$dataSchema = require(''./refs/$data.json'');
self.addMetaSchema($dataSchema, $dataSchema.$id, true);
}
if (self._opts.meta === false) return;
var metaSchema = require(''./refs/json-schema-draft-06.json'');
if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
self._refs[''http://json-schema.org/schema''] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
var optsSchemas = self._opts.schemas;
if (!optsSchemas) return;
if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
for (var name in self._opts.formats) {
var format = self._opts.formats[name];
self.addFormat(name, format);
}
}
function checkUnique(self, id) {
if (self._schemas[id] || self._refs[id])
throw new Error(''schema with key or id \\" '' + id + '' \\" already exists'');
}
function getMetaSchemaOptions(self) {
var metaOpts = util.copy(self._opts);
for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
delete metaOpts[META_IGNORE_OPTIONS[i]];
return metaOpts;
}
},{\\"./ $ data \\":8,\\"./
CACHE \\":10,\\"./ compile \\":15,\\"./ compile / async \\":12,\\"./ compile / error_classes \\":13,\\"./ compile / formats \\":14,\\"./ compile / resolve \\":16,\\"./ compile / rules \\":17,\\"./ compile / schema_obj \\":18,\\"./ compile / util \\":20,\\"./ keyword \\":44,\\"./ patternGroups \\":45,\\"./ refs / $ data.json \\":46,\\"./ refs / json - SCHEMA - draft - 06.json \\":47,\\" co \\":48,\\" json - STABLE - stringify \\":51}],10:[function(require,module,exports){
''use strict'';
var Cache = module.exports = function Cache() {
this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
this._cache = {};
};
},{}],11:[function(require,module,exports){
''use strict'';
//all requires must be explicit because browserify won''t work with dynamic requires
module.exports = {
''$ref'': require(''../dotjs/ref''),
allOf: require(''../dotjs/allOf''),
anyOf: require(''../dotjs/anyOf''),
const: require(''../dotjs/const''),
contains: require(''../dotjs/contains''),
dependencies: require(''../dotjs/dependencies''),
''enum'': require(''../dotjs/enum''),
format: require(''../dotjs/format''),
items: require(''../dotjs/items''),
maximum: require(''../dotjs/_limit''),
minimum: require(''../dotjs/_limit''),
maxItems: require(''../dotjs/_limitItems''),
minItems: require(''../dotjs/_limitItems''),
maxLength: require(''../dotjs/_limitLength''),
minLength: require(''../dotjs/_limitLength''),
maxProperties: require(''../dotjs/_limitProperties''),
minProperties: require(''../dotjs/_limitProperties''),
multipleOf: require(''../dotjs/multipleOf''),
not: require(''../dotjs/not''),
oneOf: require(''../dotjs/oneOf''),
pattern: require(''../dotjs/pattern''),
properties: require(''../dotjs/properties''),
propertyNames: require(''../dotjs/propertyNames''),
required: require(''../dotjs/required''),
uniqueItems: require(''../dotjs/uniqueItems''),
validate: require(''../dotjs/validate'')
};
},{\\"../ dotjs / _limit \\":21,\\"../ dotjs / _limitItems \\":22,\\"../ dotjs / _limitLength \\":23,\\"../ dotjs / _limitProperties \\":24,\\"../ dotjs / allOf \\":25,\\"../ dotjs / anyOf \\":26,\\"../ dotjs / const \\":27,\\"../ dotjs / contains \\":28,\\"../ dotjs / dependencies \\":30,\\"../ dotjs / enum \\":31,\\"../ dotjs / format \\":32,\\"../ dotjs / items \\":33,\\"../ dotjs / multipleOf \\":34,\\"../ dotjs / NOT \\":35,\\"../ dotjs / oneOf \\":36,\\"../ dotjs / pattern \\":37,\\"../ dotjs / properties \\":38,\\"../ dotjs / propertyNames \\":39,\\"../ dotjs / ref \\":40,\\"../ dotjs / required \\":41,\\"../ dotjs / uniqueItems \\":42,\\"../ dotjs / validate \\":43}],12:[function(require,module,exports){
''use strict'';
var MissingRefError = require(''./error_classes'').MissingRef;
module.exports = compileAsync;
/**
* Creates validating function for passed schema with asynchronous loading of missing schemas.
* \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
* @this  Ajv
* @param {Object}   schema schema object
* @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
* @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
* @return {Promise} promise that resolves with a validating function.
*/
function compileAsync(schema, meta, callback) {
/* eslint no-shadow: 0 */
/* global Promise */
/* jshint validthis: true */
var self = this;
if (typeof this._opts.loadSchema != ''function'')
throw new Error(''options.loadSchema should be a function'');
if (typeof meta == ''function'') {
callback = meta;
meta = undefined;
}
var p = loadMetaSchemaOf(schema).then(function () {
var schemaObj = self._addSchema(schema, undefined, meta);
return schemaObj.validate || _compileAsync(schemaObj);
});
if (callback) {
p.then(
function(v) { callback(null, v); },
callback
);
}
return p;
function loadMetaSchemaOf(sch) {
var $schema = sch.$schema;
return $schema && !self.getSchema($schema)
? compileAsync.call(self, { $ref: $schema }, true)
: Promise.resolve();
}
function _compileAsync(schemaObj) {
try { return self._compile(schemaObj); }
catch(e) {
if (e instanceof MissingRefError) return loadMissingSchema(e);
throw e;
}
function loadMissingSchema(e) {
var ref = e.missingSchema;
if (added(ref)) throw new Error(''Schema '' + ref + '' is loaded but '' + e.missingRef + '' cannot be resolved'');
var schemaPromise = self._loadingSchemas[ref];
if (!schemaPromise) {
schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
schemaPromise.then(removePromise, removePromise);
}
return schemaPromise.then(function (sch) {
if (!added(ref)) {
return loadMetaSchemaOf(sch).then(function () {
if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
});
}
}).then(function() {
return _compileAsync(schemaObj);
});
function removePromise() {
delete self._loadingSchemas[ref];
}
function added(ref) {
return self._refs[ref] || self._schemas[ref];
}
}
}
}
},{\\"./ error_classes \\":13}],13:[function(require,module,exports){
''use strict'';
var resolve = require(''./resolve'');
module.exports = {
Validation: errorSubclass(ValidationError),
MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
this.message = ''validation failed'';
this.errors = errors;
this.ajv = this.validation = true;
}
MissingRefError.message = function (baseId, ref) {
return ''can\\\\''t resolve reference '' + ref + '' from id '' + baseId;
};
function MissingRefError(baseId, ref, message) {
this.message = message || MissingRefError.message(baseId, ref);
this.missingRef = resolve.url(baseId, ref);
this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
Subclass.prototype = Object.create(Error.prototype);
Subclass.prototype.constructor = Subclass;
return Subclass;
}
},{\\"./ resolve \\":16}],14:[function(require,module,exports){
''use strict'';
var util = require(''./util'');
var DATE = /^\\\\d\\\\d\\\\d\\\\d-(\\\\d\\\\d)-(\\\\d\\\\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)(\\\\.\\\\d+)?(z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\\\\-.]*:)(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''()*+,;=]|%[0-9a-f]{2})*)(?::\\\\d*)?(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\\\?(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\\\-.]*:)?(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''\\" () * +,; =] | %[0 - 9a - f] {2}) *) (?::d *) ? (? : / (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@] | %[0 - 9a - f] {2}) *) *) ? | (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\\\?(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@ / ?] | %[0 - 9a - f] {2}) *) ? (? : # (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\\\x00-\\\\x20\\"'' <> % \\\\\\\\ ^ \`{|}]|%[0-9a-f]{2})|\\\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?)*\\\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\\\/\\\\/)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!10(?:\\\\.\\\\d{1,3}){3})(?!127(?:\\\\.\\\\d{1,3}){3})(?!169\\\\.254(?:\\\\.\\\\d{1,3}){2})(?!192\\\\.168(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)*(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}]{2,})))(?::\\\\d{2,5})?(?:\\\\/[^\\\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\\\u017F]?|ftp):\\\\/\\\\/)(?:(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+(?::(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?@)?(?:(?!10(?:\\\\.[0-9]{1,3}){3})(?!127(?:\\\\.[0-9]{1,3}){3})(?!169\\\\.254(?:\\\\.[0-9]{1,3}){2})(?!192\\\\.168(?:\\\\.[0-9]{1,3}){2})(?!172\\\\.(?:1[6-9]|2[0-9]|3[01])(?:\\\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)(?:\\\\.(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)*(?:\\\\.(?:(?:[KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\\\/(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\\\/(?:[a-z0-9_\\\\-.!$&''()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\\\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
mode = mode == ''full'' ? ''full'' : ''fast'';
return util.copy(formats[mode]);
}
formats.fast = {
// date: http://tools.ietf.org/html/rfc3339#section-5.6
date: /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d$/,
// date-time: http://tools.ietf.org/html/rfc3339#section-5.6
time: /^[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i,
''date-time'': /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d[t\\\\s][0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)$/i,
// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\\\\/)\\\\/?[^\\\\s]*$/i,
''uri-reference'': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\\\/\\\\/)?[^\\\\s]*$/i,
''uri-template'': URITEMPLATE,
url: URL,
// email (sources from jsen validator):
// http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
// http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for ''willful violation'')
email: /^[a-z0-9.!#$%&''*+/=?^_\` {|}~ -] + @[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ? (? :.[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ?) * $ / i, hostname: HOSTNAME, / / optimized https: / / www.safaribooksonline.com / library / VIEW / regular - expressions - cookbook / 9780596802837 / ch07s16.html ipv4: / ^ (? : (? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?).) {3}(? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?) $ /, / / optimized http: / / stackoverflow.com / questions / 53497 / regular - expression - that - matches - valid - ipv6 - addresses ipv6: / ^ s * (? : (? : (? :[0 - 9a - f] {1, 4 } :) {7}(? :[0 - 9a - f] {1, 4 }| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {6}(?::[0 - 9a - f] {1, 4 }|(? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {5}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 2 })| : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {4}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 3 })|(? : (?::[0 - 9a - f] {1, 4 })? : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {3}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 4 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 2 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {2}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 5 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 3 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {1}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 6 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 4 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (?::(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 7 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 5 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :))) (? : %.+) ? s * $ / i, regex: regex, / / uuid: http: / / tools.ietf.org / html / rfc4122 uuid: uuid, / / json - pointer: https: / / tools.ietf.org / html / rfc6901 / / uri fragment: https: / / tools.ietf.org / html / rfc3986 # appendix - A ''json-pointer'' : JSON_POINTER, / / relative json - pointer: http: / / tools.ietf.org / html / draft - luff - relative - json - pointer - 00 ''relative-json-pointer'' : RELATIVE_JSON_POINTER }; formats.full = { date: date, time: time, ''date-time'' : date_time, uri: uri, ''uri-reference'' : URIREF, ''uri-template'' : URITEMPLATE, url: URL, email: / ^[a - z0 - 9 ! # $ % & ''*+/=?^_\`{|}~-]+(?:\\\\.[a-z0-9!#$%&''''*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
hostname: hostname,
ipv4: /^(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$/,
ipv6: /^\\\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:)))(?:%.+)?\\\\s*$/i,
regex: regex,
uuid: UUID,
'' json - pointer '': JSON_POINTER,
'' relative - json - pointer '': RELATIVE_JSON_POINTER
};
function date(str) {
// full-date from http://tools.ietf.org/html/rfc3339#section-5.6
var matches = str.match(DATE);
if (!matches) return false;
var month = +matches[1];
var day = +matches[2];
return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}
function time(str, full) {
var matches = str.match(TIME);
if (!matches) return false;
var hour = matches[1];
var minute = matches[2];
var second = matches[3];
var timeZone = matches[5];
return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\\\\s/i;
function date_time(str) {
// http://tools.ietf.org/html/rfc3339#section-5.6
var dateTime = str.split(DATE_TIME_SEPARATOR);
return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function hostname(str) {
// https://tools.ietf.org/html/rfc1034#section-3.5
// https://tools.ietf.org/html/rfc1123#section-2
return str.length <= 255 && HOSTNAME.test(str);
}
var NOT_URI_FRAGMENT = /\\\\/|:/;
function uri(str) {
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \\".\\"
return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\\\\\\\]\\\\\\\\Z/;
function regex(str) {
if (Z_ANCHOR.test(str)) return false;
try {
new RegExp(str);
return true;
} catch(e) {
return false;
}
}
},{\\"./util\\":20}],15:[function(require,module,exports){
'' use STRICT '';
var resolve = require(''./ resolve '')
, util = require(''./ util '')
, errorClasses = require(''./ error_classes '')
, stableStringify = require('' json - STABLE - stringify '');
var validateGenerator = require(''../ dotjs / validate '');
/**
* Functions below are used inside compiled validations function
*/
var co = require('' co '');
var ucs2length = util.ucs2length;
var equal = require('' fast - deep - equal '');
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
* Compiles schema to validation function
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Object} root object with information about the root schema for this schema
* @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
* @param  {String} baseId base ID for IDs in the schema
* @return {Function} validation function
*/
function compile(schema, root, localRefs, baseId) {
/* jshint validthis: true, evil: true */
/* eslint no-shadow: 0 */
var self = this
, opts = this._opts
, refVal = [ undefined ]
, refs = {}
, patterns = []
, patternsHash = {}
, defaults = []
, defaultsHash = {}
, customRules = [];
root = root || { schema: schema, refVal: refVal, refs: refs };
var c = checkCompiling.call(this, schema, root, baseId);
var compilation = this._compilations[c.index];
if (c.compiling) return (compilation.callValidate = callValidate);
var formats = this._formats;
var RULES = this.RULES;
try {
var v = localCompile(schema, root, localRefs, baseId);
compilation.validate = v;
var cv = compilation.callValidate;
if (cv) {
cv.schema = v.schema;
cv.errors = null;
cv.refs = v.refs;
cv.refVal = v.refVal;
cv.root = v.root;
cv.$async = v.$async;
if (opts.sourceCode) cv.source = v.source;
}
return v;
} finally {
endCompiling.call(this, schema, root, baseId);
}
function callValidate() {
var validate = compilation.validate;
var result = validate.apply(null, arguments);
callValidate.errors = validate.errors;
return result;
}
function localCompile(_schema, _root, localRefs, baseId) {
var isRoot = !_root || (_root && _root.schema == _schema);
if (_root.schema != root.schema)
return compile.call(self, _schema, _root, localRefs, baseId);
var $async = _schema.$async === true;
var sourceCode = validateGenerator({
isTop: true,
schema: _schema,
isRoot: isRoot,
baseId: baseId,
root: _root,
schemaPath: '''',
errSchemaPath: '' # '',
errorPath: '' \\"\\" '',
MissingRefError: errorClasses.MissingRef,
RULES: RULES,
validate: validateGenerator,
util: util,
resolve: resolve,
resolveRef: resolveRef,
usePattern: usePattern,
useDefault: useDefault,
useCustomRule: useCustomRule,
opts: opts,
formats: formats,
self: self
});
sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
+ vars(defaults, defaultCode) + vars(customRules, customRuleCode)
+ sourceCode;
if (opts.processCode) sourceCode = opts.processCode(sourceCode);
// console.log('' n n n * * * n '', JSON.stringify(sourceCode));
var validate;
try {
var makeValidate = new Function(
'' self '',
'' RULES '',
'' formats '',
'' root '',
'' refVal '',
'' defaults '',
'' customRules '',
'' co '',
'' equal '',
'' ucs2length '',
'' ValidationError '',
sourceCode
);
validate = makeValidate(
self,
RULES,
formats,
root,
refVal,
defaults,
customRules,
co,
equal,
ucs2length,
ValidationError
);
refVal[0] = validate;
} catch(e) {
console.error('' Error compiling SCHEMA, FUNCTION code: '', sourceCode);
throw e;
}
validate.schema = _schema;
validate.errors = null;
validate.refs = refs;
validate.refVal = refVal;
validate.root = isRoot ? validate : _root;
if ($async) validate.$async = true;
if (opts.sourceCode === true) {
validate.source = {
code: sourceCode,
patterns: patterns,
defaults: defaults
};
}
return validate;
}
function resolveRef(baseId, ref, isRoot) {
ref = resolve.url(baseId, ref);
var refIndex = refs[ref];
var _refVal, refCode;
if (refIndex !== undefined) {
_refVal = refVal[refIndex];
refCode = '' refVal['' + refIndex + ''] '';
return resolvedRef(_refVal, refCode);
}
if (!isRoot && root.refs) {
var rootRefId = root.refs[ref];
if (rootRefId !== undefined) {
_refVal = root.refVal[rootRefId];
refCode = addLocalRef(ref, _refVal);
return resolvedRef(_refVal, refCode);
}
}
refCode = addLocalRef(ref);
var v = resolve.call(self, localCompile, root, ref);
if (v === undefined) {
var localSchema = localRefs && localRefs[ref];
if (localSchema) {
v = resolve.inlineRef(localSchema, opts.inlineRefs)
? localSchema
: compile.call(self, localSchema, root, localRefs, baseId);
}
}
if (v === undefined) {
removeLocalRef(ref);
} else {
replaceLocalRef(ref, v);
return resolvedRef(v, refCode);
}
}
function addLocalRef(ref, v) {
var refId = refVal.length;
refVal[refId] = v;
refs[ref] = refId;
return '' refVal '' + refId;
}
function removeLocalRef(ref) {
delete refs[ref];
}
function replaceLocalRef(ref, v) {
var refId = refs[ref];
refVal[refId] = v;
}
function resolvedRef(refVal, code) {
return typeof refVal == '' object '' || typeof refVal == '' boolean ''
? { code: code, schema: refVal, inline: true }
: { code: code, $async: refVal && refVal.$async };
}
function usePattern(regexStr) {
var index = patternsHash[regexStr];
if (index === undefined) {
index = patternsHash[regexStr] = patterns.length;
patterns[index] = regexStr;
}
return '' pattern '' + index;
}
function useDefault(value) {
switch (typeof value) {
case '' boolean '':
case '' number '':
return '''' + value;
case '' string '':
return util.toQuotedString(value);
case '' object '':
if (value === null) return '' NULL '';
var valueStr = stableStringify(value);
var index = defaultsHash[valueStr];
if (index === undefined) {
index = defaultsHash[valueStr] = defaults.length;
defaults[index] = value;
}
return '' DEFAULT '' + index;
}
}
function useCustomRule(rule, schema, parentSchema, it) {
var validateSchema = rule.definition.validateSchema;
if (validateSchema && self._opts.validateSchema !== false) {
var valid = validateSchema(schema);
if (!valid) {
var message = '' keyword SCHEMA IS invalid: '' + self.errorsText(validateSchema.errors);
if (self._opts.validateSchema == '' log '') console.error(message);
else throw new Error(message);
}
}
var compile = rule.definition.compile
, inline = rule.definition.inline
, macro = rule.definition.macro;
var validate;
if (compile) {
validate = compile.call(self, schema, parentSchema, it);
} else if (macro) {
validate = macro.call(self, schema, parentSchema, it);
if (opts.validateSchema !== false) self.validateSchema(validate, true);
} else if (inline) {
validate = inline.call(self, it, rule.keyword, schema, parentSchema);
} else {
validate = rule.definition.validate;
if (!validate) return;
}
if (validate === undefined)
throw new Error('' custom keyword \\"'' + rule.keyword + ''\\" failed TO compile '');
var index = customRules.length;
customRules[index] = validate;
return {
code: '' customRule '' + index,
validate: validate
};
}
}
/**
* Checks if the schema is currently compiled
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Object} object with properties \\"index\\" (compilation index) and \\"compiling\\" (boolean)
*/
function checkCompiling(schema, root, baseId) {
/* jshint validthis: true */
var index = compIndex.call(this, schema, root, baseId);
if (index >= 0) return { index: index, compiling: true };
index = this._compilations.length;
this._compilations[index] = {
schema: schema,
root: root,
baseId: baseId
};
return { index: index, compiling: false };
}
/**
* Removes the schema from the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
*/
function endCompiling(schema, root, baseId) {
/* jshint validthis: true */
var i = compIndex.call(this, schema, root, baseId);
if (i >= 0) this._compilations.splice(i, 1);
}
/**
* Index of schema compilation in the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Integer} compilation index
*/
function compIndex(schema, root, baseId) {
/* jshint validthis: true */
for (var i=0; i<this._compilations.length; i++) {
var c = this._compilations[i];
if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
}
return -1;
}
function patternCode(i, patterns) {
return '' var pattern '' + i + '' = new RegExp ('' + util.toQuotedString(patterns[i]) + ''); '';
}
function defaultCode(i) {
return '' var DEFAULT '' + i + '' = defaults['' + i + '']; '';
}
function refValCode(i, refVal) {
return refVal[i] === undefined ? '''' : '' var refVal '' + i + '' = refVal['' + i + '']; '';
}
function customRuleCode(i) {
return '' var customRule '' + i + '' = customRules['' + i + '']; '';
}
function vars(arr, statement) {
if (!arr.length) return '''';
var code = '''';
for (var i=0; i<arr.length; i++)
code += statement(i, arr);
return code;
}
},{\\"../dotjs/validate\\":43,\\"./error_classes\\":13,\\"./resolve\\":16,\\"./util\\":20,\\"co\\":48,\\"fast-deep-equal\\":49,\\"json-stable-stringify\\":51}],16:[function(require,module,exports){
'' use STRICT '';
var url = require('' url '')
, equal = require('' fast - deep - equal '')
, util = require(''./ util '')
, SchemaObject = require(''./ schema_obj '')
, traverse = require('' json - SCHEMA - traverse '');
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
* [resolve and compile the references ($ref)]
* @this   Ajv
* @param  {Function} compile reference to schema compilation funciton (localCompile)
* @param  {Object} root object with information about the root schema for the current schema
* @param  {String} ref reference to resolve
* @return {Object|Function} schema object (if the schema can be inlined) or validation function
*/
function resolve(compile, root, ref) {
/* jshint validthis: true */
var refVal = this._refs[ref];
if (typeof refVal == '' string '') {
if (this._refs[refVal]) refVal = this._refs[refVal];
else return resolve.call(this, compile, root, refVal);
}
refVal = refVal || this._schemas[ref];
if (refVal instanceof SchemaObject) {
return inlineRef(refVal.schema, this._opts.inlineRefs)
? refVal.schema
: refVal.validate || this._compile(refVal);
}
var res = resolveSchema.call(this, root, ref);
var schema, v, baseId;
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
if (schema instanceof SchemaObject) {
v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
} else if (schema !== undefined) {
v = inlineRef(schema, this._opts.inlineRefs)
? schema
: compile.call(this, schema, root, undefined, baseId);
}
return v;
}
/**
* Resolve schema, its root and baseId
* @this Ajv
* @param  {Object} root root object with properties schema, refVal, refs
* @param  {String} ref  reference to resolve
* @return {Object} object with properties schema, root, baseId
*/
function resolveSchema(root, ref) {
/* jshint validthis: true */
var p = url.parse(ref, false, true)
, refPath = _getFullPath(p)
, baseId = getFullPath(this._getId(root.schema));
if (refPath !== baseId) {
var id = normalizeId(refPath);
var refVal = this._refs[id];
if (typeof refVal == '' string '') {
return resolveRecursive.call(this, root, refVal, p);
} else if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
root = refVal;
} else {
refVal = this._schemas[id];
if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
if (id == normalizeId(ref))
return { schema: refVal, root: root, baseId: baseId };
root = refVal;
} else {
return;
}
}
if (!root.schema) return;
baseId = getFullPath(this._getId(root.schema));
}
return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
/* jshint validthis: true */
var res = resolveSchema.call(this, root, ref);
if (res) {
var schema = res.schema;
var baseId = res.baseId;
root = res.root;
var id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
return getJsonPointer.call(this, parsedRef, baseId, schema, root);
}
}
var PREVENT_SCOPE_CHANGE = util.toHash(['' properties '', '' patternProperties '', '' enum '', '' dependencies '', '' definitions '']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
/* jshint validthis: true */
parsedRef.hash = parsedRef.hash || '''';
if (parsedRef.hash.slice(0,2) != '' # / '') return;
var parts = parsedRef.hash.split('' / '');
for (var i = 1; i < parts.length; i++) {
var part = parts[i];
if (part) {
part = util.unescapeFragment(part);
schema = schema[part];
if (schema === undefined) break;
var id;
if (!PREVENT_SCOPE_CHANGE[part]) {
id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
if (schema.$ref) {
var $ref = resolveUrl(baseId, schema.$ref);
var res = resolveSchema.call(this, root, $ref);
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
}
}
}
}
if (schema !== undefined && schema !== root.schema)
return { schema: schema, root: root, baseId: baseId };
}
var SIMPLE_INLINED = util.toHash([
'' TYPE '', '' format '', '' pattern '',
'' maxLength '', '' minLength '',
'' maxProperties '', '' minProperties '',
'' maxItems '', '' minItems '',
'' maximum '', '' minimum '',
'' uniqueItems '', '' multipleOf '',
'' required '', '' enum ''
]);
function inlineRef(schema, limit) {
if (limit === false) return false;
if (limit === undefined || limit === true) return checkNoRef(schema);
else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
var item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return false;
item = schema[key];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
}
return true;
}
function countKeys(schema) {
var count = 0, item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '') count += countKeys(item);
if (count == Infinity) return Infinity;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return Infinity;
if (SIMPLE_INLINED[key]) {
count++;
} else {
item = schema[key];
if (typeof item == '' object '') count += countKeys(item) + 1;
if (count == Infinity) return Infinity;
}
}
}
return count;
}
function getFullPath(id, normalize) {
if (normalize !== false) id = normalizeId(id);
var p = url.parse(id, false, true);
return _getFullPath(p);
}
function _getFullPath(p) {
var protocolSeparator = p.protocol || p.href.slice(0,2) == '' / / '' ? '' / / '' : '''';
return (p.protocol||'''') + protocolSeparator + (p.host||'''') + (p.path||'''')  + '' # '';
}
var TRAILING_SLASH_HASH = /#\\\\/?$/;
function normalizeId(id) {
return id ? id.replace(TRAILING_SLASH_HASH, '''') : '''';
}
function resolveUrl(baseId, id) {
id = normalizeId(id);
return url.resolve(baseId, id);
}
/* @this Ajv */
function resolveIds(schema) {
var schemaId = normalizeId(this._getId(schema));
var baseIds = {'''': schemaId};
var fullPaths = {'''': getFullPath(schemaId, false)};
var localRefs = {};
var self = this;
traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (jsonPtr === '''') return;
var id = self._getId(sch);
var baseId = baseIds[parentJsonPtr];
var fullPath = fullPaths[parentJsonPtr] + '' / '' + parentKeyword;
if (keyIndex !== undefined)
fullPath += '' / '' + (typeof keyIndex == '' number '' ? keyIndex : util.escapeFragment(keyIndex));
if (typeof id == '' string '') {
id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);
var refVal = self._refs[id];
if (typeof refVal == '' string '') refVal = self._refs[refVal];
if (refVal && refVal.schema) {
if (!equal(sch, refVal.schema))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
} else if (id != normalizeId(fullPath)) {
if (id[0] == '' # '') {
if (localRefs[id] && !equal(sch, localRefs[id]))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
localRefs[id] = sch;
} else {
self._refs[id] = fullPath;
}
}
}
baseIds[jsonPtr] = baseId;
fullPaths[jsonPtr] = fullPath;
});
return localRefs;
}
},{\\"./schema_obj\\":18,\\"./util\\":20,\\"fast-deep-equal\\":49,\\"json-schema-traverse\\":50,\\"url\\":5}],17:[function(require,module,exports){
'' use STRICT '';
var ruleModules = require(''./ _rules '')
, toHash = require(''./ util '').toHash;
module.exports = function rules() {
var RULES = [
{ type: '' number '',
rules: [ { '' maximum '': ['' exclusiveMaximum ''] },
{ '' minimum '': ['' exclusiveMinimum ''] }, '' multipleOf '', '' format ''] },
{ type: '' string '',
rules: [ '' maxLength '', '' minLength '', '' pattern '', '' format '' ] },
{ type: '' ARRAY '',
rules: [ '' maxItems '', '' minItems '', '' uniqueItems '', '' contains '', '' items '' ] },
{ type: '' object '',
rules: [ '' maxProperties '', '' minProperties '', '' required '', '' dependencies '', '' propertyNames '',
{ '' properties '': ['' additionalProperties '', '' patternProperties ''] } ] },
{ rules: [ '' $ ref '', '' const '', '' enum '', '' NOT '', '' anyOf '', '' oneOf '', '' allOf '' ] }
];
var ALL = [ '' TYPE '' ];
var KEYWORDS = [
'' additionalItems '', '' $ SCHEMA '', '' id '', '' title '',
'' description '', '' DEFAULT '', '' definitions ''
];
var TYPES = [ '' number '', '' integer '', '' string '', '' ARRAY '', '' object '', '' boolean '', '' NULL '' ];
RULES.all = toHash(ALL);
RULES.types = toHash(TYPES);
RULES.forEach(function (group) {
group.rules = group.rules.map(function (keyword) {
var implKeywords;
if (typeof keyword == '' object '') {
var key = Object.keys(keyword)[0];
implKeywords = keyword[key];
keyword = key;
implKeywords.forEach(function (k) {
ALL.push(k);
RULES.all[k] = true;
});
}
ALL.push(keyword);
var rule = RULES.all[keyword] = {
keyword: keyword,
code: ruleModules[keyword],
implements: implKeywords
};
return rule;
});
if (group.type) RULES.types[group.type] = group;
});
RULES.keywords = toHash(ALL.concat(KEYWORDS));
RULES.custom = {};
return RULES;
};
},{\\"./_rules\\":11,\\"./util\\":20}],18:[function(require,module,exports){
'' use STRICT '';
var util = require(''./ util '');
module.exports = SchemaObject;
function SchemaObject(obj) {
util.copy(obj, this);
}
},{\\"./util\\":20}],19:[function(require,module,exports){
'' use STRICT '';
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
var length = 0
, len = str.length
, pos = 0
, value;
while (pos < len) {
length++;
value = str.charCodeAt(pos++);
if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
// high surrogate, and there is a next character
value = str.charCodeAt(pos);
if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
}
}
return length;
};
},{}],20:[function(require,module,exports){
'' use STRICT '';
module.exports = {
copy: copy,
checkDataType: checkDataType,
checkDataTypes: checkDataTypes,
coerceToTypes: coerceToTypes,
toHash: toHash,
getProperty: getProperty,
escapeQuotes: escapeQuotes,
equal: require('' fast - deep - equal ''),
ucs2length: require(''./ ucs2length ''),
varOccurences: varOccurences,
varReplace: varReplace,
cleanUpCode: cleanUpCode,
finalCleanUpCode: finalCleanUpCode,
schemaHasRules: schemaHasRules,
schemaHasRulesExcept: schemaHasRulesExcept,
toQuotedString: toQuotedString,
getPathExpr: getPathExpr,
getPath: getPath,
getData: getData,
unescapeFragment: unescapeFragment,
unescapeJsonPointer: unescapeJsonPointer,
escapeFragment: escapeFragment,
escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
to = to || {};
for (var key in o) to[key] = o[key];
return to;
}
function checkDataType(dataType, data, negate) {
var EQUAL = negate ? '' != = '' : '' == = ''
, AND = negate ? '' || '' : '' && ''
, OK = negate ? '' ! '' : ''''
, NOT = negate ? '''' : '' ! '';
switch (dataType) {
case '' NULL '': return data + EQUAL + '' NULL '';
case '' ARRAY '': return OK + '' Array.isArray ('' + data + '') '';
case '' object '': return '' ('' + OK + data + AND +
'' typeof '' + data + EQUAL + '' \\"object\\" '' + AND +
NOT + '' Array.isArray ('' + data + '')) '';
case '' integer '': return '' (typeof '' + data + EQUAL + '' \\"number\\" '' + AND +
NOT + '' ('' + data + '' % 1) '' +
AND + data + EQUAL + data + '') '';
default: return '' typeof '' + data + EQUAL + '' \\"'' + dataType + ''\\" '';
}
}
function checkDataTypes(dataTypes, data) {
switch (dataTypes.length) {
case 1: return checkDataType(dataTypes[0], data, true);
default:
var code = '''';
var types = toHash(dataTypes);
if (types.array && types.object) {
code = types.null ? '' ('': '' (! '' + data + '' || '';
code += '' typeof '' + data + '' != = \\"object\\") '';
delete types.null;
delete types.array;
delete types.object;
}
if (types.number) delete types.integer;
for (var t in types)
code += (code ? '' && '' : '''' ) + checkDataType(t, data, true);
return code;
}
}
var COERCE_TO_TYPES = toHash([ '' string '', '' number '', '' integer '', '' boolean '', '' NULL '' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
if (Array.isArray(dataTypes)) {
var types = [];
for (var i=0; i<dataTypes.length; i++) {
var t = dataTypes[i];
if (COERCE_TO_TYPES[t]) types[types.length] = t;
else if (optionCoerceTypes === '' ARRAY '' && t === '' ARRAY '') types[types.length] = t;
}
if (types.length) return types;
} else if (COERCE_TO_TYPES[dataTypes]) {
return [dataTypes];
} else if (optionCoerceTypes === '' ARRAY '' && dataTypes === '' ARRAY '') {
return ['' ARRAY ''];
}
}
function toHash(arr) {
var hash = {};
for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'' | \\\\\\\\ / g; FUNCTION getProperty (KEY) { RETURN typeof KEY == ''number'' ? ''['' + KEY + '']'' : IDENTIFIER.test (KEY) ? ''.'' + KEY :\\"[''\\" + escapeQuotes (KEY) + \\"'']\\"; } FUNCTION escapeQuotes (str) { RETURN str.replace(SINGLE_QUOTE, ''\\\\\\\\$&'').replace(/ n / g, ''\\\\\\\\n'').replace(/ r / g, ''\\\\\\\\r'').replace(/ f / g, ''\\\\\\\\f'').replace(/ t / g, ''\\\\\\\\t''); } FUNCTION varOccurences (str, dataVar) { dataVar + = ''[^0-9]''; var matches = str.match (new RegExp (dataVar, ''g'')); RETURN matches ? matches.length : 0; } FUNCTION varReplace (str, dataVar, expr) { dataVar + = ''([^0-9])''; expr = expr.replace(/ $ / g, ''$$$$''); RETURN str.replace(new RegExp (dataVar, ''g''), expr + ''$1''); } var EMPTY_ELSE = /
ELSE
s * { s * } / g, EMPTY_IF_NO_ELSE = / IF s * ([^)] +) s * { s * }(?! s *
ELSE
) / g, EMPTY_IF_WITH_ELSE = / IF s * (([^)] +)) s * { s * } s *
ELSE
(? ! s * IF) / g; FUNCTION cleanUpCode (out) { RETURN out.replace(EMPTY_ELSE, '''').replace(EMPTY_IF_NO_ELSE, '''').replace(EMPTY_IF_WITH_ELSE, ''if (!($1))''); } var ERRORS_REGEXP = /[^ v.] errors / g, REMOVE_ERRORS = / var errors = 0; | var vErrors = NULL; | validate.errors = vErrors; / g, REMOVE_ERRORS_ASYNC = / var errors = 0; | var vErrors = NULL; / g, RETURN_VALID = ''return errors === 0;'', RETURN_TRUE = ''validate.errors = null; return true;'', RETURN_ASYNC = / IF (errors == = 0)
RETURN data; s *
ELSE
throw new ValidationError (vErrors); /, RETURN_DATA_ASYNC = ''return data;'', ROOTDATA_REGEXP = /[^ A - Za - z_$] rootData[^ A - Za - z0 - 9_$] / g, REMOVE_ROOTDATA = / IF (rootData == = undefined) rootData = data; /; FUNCTION finalCleanUpCode (out, async) { var matches = out.match (ERRORS_REGEXP); IF (matches && matches.length == 2) { out = async ? out.replace(REMOVE_ERRORS_ASYNC, '''').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '''').replace(RETURN_VALID, RETURN_TRUE); } matches = out.match (ROOTDATA_REGEXP); IF (! matches || matches.length != = 3)
RETURN out; RETURN out.replace(REMOVE_ROOTDATA, ''''); } FUNCTION schemaHasRules (SCHEMA, rules) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA; FOR (var KEY IN SCHEMA)
IF (rules[KEY])
RETURN TRUE; } FUNCTION schemaHasRulesExcept (SCHEMA, rules, exceptKeyword) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA && exceptKeyword != ''not''; FOR (var KEY IN SCHEMA)
IF (KEY != exceptKeyword && rules[KEY])
RETURN TRUE; } FUNCTION toQuotedString (str) { RETURN ''\\\\'''' + escapeQuotes (str) + ''\\\\''''; } FUNCTION getPathExpr (currentPath, expr, jsonPointers, isNumber) { var path = jsonPointers / / FALSE BY DEFAULT ? ''\\\\''/\\\\'' + '' + expr + (isNumber ? '''' :''.replace(/~/g, \\\\''~0\\\\'').replace(/\\\\\\\\//g, \\\\''~1\\\\'')'') : (isNumber ? ''\\\\''[\\\\'' + '' + expr + '' + \\\\'']\\\\'''' :''\\\\''[\\\\\\\\\\\\''\\\\'' + '' + expr + '' + \\\\''\\\\\\\\\\\\'']\\\\''''); RETURN joinPaths (currentPath, path); } FUNCTION getPath (currentPath, prop, jsonPointers) { var path = jsonPointers / / FALSE BY DEFAULT ? toQuotedString (''/'' + escapeJsonPointer (prop)) : toQuotedString (getProperty (prop)); RETURN joinPaths (currentPath, path); } var JSON_POINTER = / ^ / (? :[^ ~] | ~ 0 | ~ 1) * $ /; var RELATIVE_JSON_POINTER = / ^ ([0 - 9] +) (# | / (? :[^ ~] | ~ 0 | ~ 1) *) ? $ /; FUNCTION getData ($ data, lvl, paths) { var up, jsonPointer, data, matches; IF ($ data == = '''')
RETURN ''rootData''; IF ($ data[0] == ''/'') { IF (! JSON_POINTER.test ($ data)) throw new Error (''Invalid JSON-pointer: '' + $ data); jsonPointer = $ data; data = ''rootData''; }
ELSE
{ matches = $ data.match (RELATIVE_JSON_POINTER); IF (! matches) throw new Error (''Invalid JSON-pointer: '' + $ data); up = + matches[1]; jsonPointer = matches[2]; IF (jsonPointer == ''#'') { IF (up >= lvl) throw new Error (''Cannot access property/index '' + up + '' levels up, current level is '' + lvl); RETURN paths[lvl - up]; } IF (up > lvl) throw new Error (''Cannot access data '' + up + '' levels up, current level is '' + lvl); data = ''data'' + ((lvl - up) || ''''); IF (! jsonPointer)
RETURN data; } var expr = data; var segments = jsonPointer.split (''/''); FOR (var i = 0; i < segments.length; i + +) { var segment = segments[i]; IF (segment) { data + = getProperty (unescapeJsonPointer (segment)); expr + = '' && '' + data; } } RETURN expr; } FUNCTION joinPaths (a, b) { IF (a == ''\\"\\"'')
RETURN b; RETURN (a + '' + '' + b).replace(/ '' \\\\+ '' / g, ''''); } FUNCTION unescapeFragment (str) { RETURN unescapeJsonPointer (decodeURIComponent (str)); } FUNCTION escapeFragment (str) { RETURN encodeURIComponent (escapeJsonPointer (str)); } FUNCTION escapeJsonPointer (str) { RETURN str.replace(/ ~ / g, ''~0'').replace(/ / / g, ''~1''); } FUNCTION unescapeJsonPointer (str) { RETURN str.replace(/ ~ 1 / g, ''/'').replace(/ ~ 0 / g, ''~''); } }, {\\". / ucs2length \\":19,\\" fast - deep - equal \\":49}],21:[function(require,module,exports){
''use strict'';
module.exports = function generate__limit(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $isMax = $keyword == ''maximum'',
$exclusiveKeyword = $isMax ? ''exclusiveMaximum'' : ''exclusiveMinimum'',
$schemaExcl = it.schema[$exclusiveKeyword],
$isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
$op = $isMax ? ''<'' : ''>'',
$notOp = $isMax ? ''>'' : ''<'',
$errorKeyword = undefined;
if ($isDataExcl) {
var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
$exclusive = ''exclusive'' + $lvl,
$exclType = ''exclType'' + $lvl,
$exclIsNumber = ''exclIsNumber'' + $lvl,
$opExpr = ''op'' + $lvl,
$opStr = ''\\\\'' + '' + $opExpr + '' + \\\\'''';
out += '' var schemaExcl'' + ($lvl) + '' = '' + ($schemaValueExcl) + ''; '';
$schemaValueExcl = ''schemaExcl'' + $lvl;
out += '' var '' + ($exclusive) + ''; var '' + ($exclType) + '' = typeof '' + ($schemaValueExcl) + ''; if ('' + ($exclType) + '' != \\\\''boolean\\\\'' && '' + ($exclType) + '' != \\\\''undefined\\\\'' && '' + ($exclType) + '' != \\\\''number\\\\'') { '';
var $errorKeyword = $exclusiveKeyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_exclusiveLimit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''' + ($exclusiveKeyword) + '' should be boolean\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($exclType) + '' == \\\\''number\\\\'' ? (('' + ($exclusive) + '' = '' + ($schemaValue) + '' === undefined || '' + ($schemaValueExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '') ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValueExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) : (('' + ($exclusive) + '' = '' + ($schemaValueExcl) + '' === true) ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValue) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { var op'' + ($lvl) + '' = '' + ($exclusive) + '' ? \\\\'''' + ($op) + ''\\\\'' : \\\\'''' + ($op) + ''=\\\\'';'';
} else {
var $exclIsNumber = typeof $schemaExcl == ''number'',
$opStr = $op;
if ($exclIsNumber && $isData) {
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' ( '' + ($schemaValue) + '' === undefined || '' + ($schemaExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '' ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { '';
} else {
if ($exclIsNumber && $schema === undefined) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$schemaValue = $schemaExcl;
$notOp += ''='';
} else {
if ($exclIsNumber) $schemaValue = Math[$isMax ? ''min'' : ''max'']($schemaExcl, $schema);
if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$notOp += ''='';
} else {
$exclusive = false;
$opStr += ''='';
}
}
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' || '' + ($data) + '' !== '' + ($data) + '') { '';
}
}
$errorKeyword = $errorKeyword || $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { comparison: '' + ($opExpr) + '', limit: '' + ($schemaValue) + '', exclusive: '' + ($exclusive) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '' + ($opStr) + '' '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],22:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxItems'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + ''.length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxItems'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],23:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxLength'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
if (it.opts.unicode === false) {
out += '' '' + ($data) + ''.length '';
} else {
out += '' ucs2length('' + ($data) + '') '';
}
out += '' '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitLength'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be '';
if ($keyword == ''maxLength'') {
out += ''longer'';
} else {
out += ''shorter'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' characters\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],24:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxProperties'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' Object.keys('' + ($data) + '').length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxProperties'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],25:[function(require,module,exports){
''use strict'';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
var out = '' '';
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $currentBaseId = $it.baseId,
$allSchemasEmpty = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$allSchemasEmpty = false;
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($breakOnError) {
if ($allSchemasEmpty) {
out += '' if (true) { '';
} else {
out += '' '' + ($closingBraces.slice(0, -1)) + '' '';
}
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],26:[function(require,module,exports){
''use strict'';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $noEmptySchema = $schema.every(function($sch) {
return it.util.schemaHasRules($sch, it.RULES.all);
});
if ($noEmptySchema) {
var $currentBaseId = $it.baseId;
out += '' var '' + ($errs) + '' = errors; var '' + ($valid) + '' = false;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' '' + ($valid) + '' = '' + ($valid) + '' || '' + ($nextValid) + ''; if (!'' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''anyOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match some schema in anyOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],27:[function(require,module,exports){
''use strict'';
module.exports = function generate_const(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (!$isData) {
out += '' var schema'' + ($lvl) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '' = equal('' + ($data) + '', schema'' + ($lvl) + ''); if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''const'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to constant\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],28:[function(require,module,exports){
''use strict'';
module.exports = function generate_contains(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId,
$nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($nonEmptySchema) {
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($nextValid) + '' = false; for (var '' + ($idx) + '' = 0; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if ('' + ($nextValid) + '') break; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($nextValid) + '') {'';
} else {
out += '' if ('' + ($data) + ''.length == 0) {'';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''contains'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should contain a valid item\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
if ($nonEmptySchema) {
out += ''  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
}
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],29:[function(require,module,exports){
''use strict'';
module.exports = function generate_custom(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $rule = this,
$definition = ''definition'' + $lvl,
$rDef = $rule.definition,
$closingBraces = '''';
var $compile, $inline, $macro, $ruleValidate, $validateCode;
if ($isData && $rDef.$data) {
$validateCode = ''keywordValidate'' + $lvl;
var $validateSchema = $rDef.validateSchema;
out += '' var '' + ($definition) + '' = RULES.custom[\\\\'''' + ($keyword) + ''\\\\''].definition; var '' + ($validateCode) + '' = '' + ($definition) + ''.validate;'';
} else {
$ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
if (!$ruleValidate) return;
$schemaValue = ''validate.schema'' + $schemaPath;
$validateCode = $ruleValidate.code;
$compile = $rDef.compile;
$inline = $rDef.inline;
$macro = $rDef.macro;
}
var $ruleErrs = $validateCode + ''.errors'',
$i = ''i'' + $lvl,
$ruleErr = ''ruleErr'' + $lvl,
$asyncKeyword = $rDef.async;
if ($asyncKeyword && !it.async) throw new Error(''async keyword in sync schema'');
if (!($inline || $macro)) {
out += '''' + ($ruleErrs) + '' = null;'';
}
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($isData && $rDef.$data) {
$closingBraces += ''}'';
out += '' if ('' + ($schemaValue) + '' === undefined) { '' + ($valid) + '' = true; } else { '';
if ($validateSchema) {
$closingBraces += ''}'';
out += '' '' + ($valid) + '' = '' + ($definition) + ''.validateSchema('' + ($schemaValue) + ''); if ('' + ($valid) + '') { '';
}
}
if ($inline) {
if ($rDef.statements) {
out += '' '' + ($ruleValidate.validate) + '' '';
} else {
out += '' '' + ($valid) + '' = '' + ($ruleValidate.validate) + ''; '';
}
} else if ($macro) {
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $ruleValidate.validate;
$it.schemaPath = '''';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $validateCode);
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($code);
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
out += ''  '' + ($validateCode) + ''.call( '';
if (it.opts.passContext) {
out += ''this'';
} else {
out += ''self'';
}
if ($compile || $rDef.schema === false) {
out += '' , '' + ($data) + '' '';
} else {
out += '' , '' + ($schemaValue) + '' , '' + ($data) + '' , validate.schema'' + (it.schemaPath) + '' '';
}
out += '' , (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '' , rootData )  '';
var def_callRuleValidate = out;
out = $$outStack.pop();
if ($rDef.errors === false) {
out += '' '' + ($valid) + '' = '';
if ($asyncKeyword) {
out += '''' + (it.yieldAwait);
}
out += '''' + (def_callRuleValidate) + ''; '';
} else {
if ($asyncKeyword) {
$ruleErrs = ''customErrors'' + $lvl;
out += '' var '' + ($ruleErrs) + '' = null; try { '' + ($valid) + '' = '' + (it.yieldAwait) + (def_callRuleValidate) + ''; } catch (e) { '' + ($valid) + '' = false; if (e instanceof ValidationError) '' + ($ruleErrs) + '' = e.errors; else throw e; } '';
} else {
out += '' '' + ($ruleErrs) + '' = null; '' + ($valid) + '' = '' + (def_callRuleValidate) + ''; '';
}
}
}
if ($rDef.modifying) {
out += '' if ('' + ($parentData) + '') '' + ($data) + '' = '' + ($parentData) + ''['' + ($parentDataProperty) + ''];'';
}
out += '''' + ($closingBraces);
if ($rDef.valid) {
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
out += '' if ( '';
if ($rDef.valid === undefined) {
out += '' !'';
if ($macro) {
out += '''' + ($nextValid);
} else {
out += '''' + ($valid);
}
} else {
out += '' '' + (!$rDef.valid) + '' '';
}
out += '') { '';
$errorKeyword = $rule.keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
var def_customError = out;
out = $$outStack.pop();
if ($inline) {
if ($rDef.errors) {
if ($rDef.errors != ''full'') {
out += ''  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } '';
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if ('' + ($errs) + '' == errors) { '' + (def_customError) + '' } else {  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } '';
}
}
} else if ($macro) {
out += ''   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if (Array.isArray('' + ($ruleErrs) + '')) { if (vErrors === null) vErrors = '' + ($ruleErrs) + ''; else vErrors = vErrors.concat('' + ($ruleErrs) + ''); errors = vErrors.length;  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '';  '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\";  '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } else { '' + (def_customError) + '' } '';
}
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
}
return out;
}
},{}],30:[function(require,module,exports){
''use strict'';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $schemaDeps = {},
$propertyDeps = {},
$ownProperties = it.opts.ownProperties;
for ($property in $schema) {
var $sch = $schema[$property];
var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
$deps[$property] = $sch;
}
out += ''var '' + ($errs) + '' = errors;'';
var $currentErrorPath = it.errorPath;
out += ''var missing'' + ($lvl) + '';'';
for (var $property in $propertyDeps) {
$deps = $propertyDeps[$property];
if ($deps.length) {
out += '' if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
if ($breakOnError) {
out += '' && ( '';
var arr1 = $deps;
if (arr1) {
var $propertyKey, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$propertyKey = arr1[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '')) {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
out += '' ) { '';
var arr2 = $deps;
if (arr2) {
var $propertyKey, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$propertyKey = arr2[i2 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
out += '' }   '';
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
}
it.errorPath = $currentErrorPath;
var $currentBaseId = $it.baseId;
for (var $property in $schemaDeps) {
var $sch = $schemaDeps[$property];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
out += '') { '';
$it.schema = $sch;
$it.schemaPath = $schemaPath + it.util.getProperty($property);
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($property);
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
if ($breakOnError) {
out += ''   '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],31:[function(require,module,exports){
''use strict'';
module.exports = function generate_enum(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $i = ''i'' + $lvl,
$vSchema = ''schema'' + $lvl;
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '';'';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '''' + ($valid) + '' = false;for (var '' + ($i) + ''=0; '' + ($i) + ''<'' + ($vSchema) + ''.length; '' + ($i) + ''++) if (equal('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + ''])) { '' + ($valid) + '' = true; break; }'';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''enum'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { allowedValues: schema'' + ($lvl) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to one of the allowed values\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],32:[function(require,module,exports){
''use strict'';
module.exports = function generate_format(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
if (it.opts.format === false) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $unknownFormats = it.opts.unknownFormats,
$allowUnknown = Array.isArray($unknownFormats);
if ($isData) {
var $format = ''format'' + $lvl,
$isObject = ''isObject'' + $lvl,
$formatType = ''formatType'' + $lvl;
out += '' var '' + ($format) + '' = formats['' + ($schemaValue) + '']; var '' + ($isObject) + '' = typeof '' + ($format) + '' == \\\\''object\\\\'' && !('' + ($format) + '' instanceof RegExp) && '' + ($format) + ''.validate; var '' + ($formatType) + '' = '' + ($isObject) + '' && '' + ($format) + ''.type || \\\\''string\\\\''; if ('' + ($isObject) + '') { '';
if (it.async) {
out += '' var async'' + ($lvl) + '' = '' + ($format) + ''.async; '';
}
out += '' '' + ($format) + '' = '' + ($format) + ''.validate; } if (  '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' ('';
if ($unknownFormats != ''ignore'') {
out += '' ('' + ($schemaValue) + '' && !'' + ($format) + '' '';
if ($allowUnknown) {
out += '' && self._opts.unknownFormats.indexOf('' + ($schemaValue) + '') == -1 '';
}
out += '') || '';
}
out += '' ('' + ($format) + '' && '' + ($formatType) + '' == \\\\'''' + ($ruleType) + ''\\\\'' && !(typeof '' + ($format) + '' == \\\\''function\\\\'' ? '';
if (it.async) {
out += '' (async'' + ($lvl) + '' ? '' + (it.yieldAwait) + '' '' + ($format) + ''('' + ($data) + '') : '' + ($format) + ''('' + ($data) + '')) '';
} else {
out += '' '' + ($format) + ''('' + ($data) + '') '';
}
out += '' : '' + ($format) + ''.test('' + ($data) + ''))))) {'';
} else {
var $format = it.formats[$schema];
if (!$format) {
if ($unknownFormats == ''ignore'') {
console.warn(''unknown format \\" '' + $schema + '' \\" ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else {
throw new Error(''unknown format \\" '' + $schema + '' \\" is used in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
var $isObject = typeof $format == ''object'' && !($format instanceof RegExp) && $format.validate;
var $formatType = $isObject && $format.type || ''string'';
if ($isObject) {
var $async = $format.async === true;
$format = $format.validate;
}
if ($formatType != $ruleType) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
if ($async) {
if (!it.async) throw new Error(''async format in sync schema'');
var $formatRef = ''formats'' + it.util.getProperty($schema) + ''.validate'';
out += '' if (!('' + (it.yieldAwait) + '' '' + ($formatRef) + ''('' + ($data) + ''))) { '';
} else {
out += '' if (! '';
var $formatRef = ''formats'' + it.util.getProperty($schema);
if ($isObject) $formatRef += ''.validate'';
if (typeof $format == ''function'') {
out += '' '' + ($formatRef) + ''('' + ($data) + '') '';
} else {
out += '' '' + ($formatRef) + ''.test('' + ($data) + '') '';
}
out += '') { '';
}
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''format'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { format:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match format \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],33:[function(require,module,exports){
''use strict'';
module.exports = function generate_items(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId;
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if (Array.isArray($schema)) {
var $additionalItems = it.schema.additionalItems;
if ($additionalItems === false) {
out += '' '' + ($valid) + '' = '' + ($data) + ''.length <= '' + ($schema.length) + ''; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schema.length) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have more than '' + ($schema.length) + '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($i) + '') { '';
var $passData = $data + ''['' + $i + '']'';
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
$it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
$it.dataPathArr[$dataNxt] = $i;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if (typeof $additionalItems == ''object'' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
$it.schema = $additionalItems;
$it.schemaPath = it.schemaPath + ''.additionalItems'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($schema.length) + '') {  for (var '' + ($idx) + '' = '' + ($schema.length) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
} else if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += ''  for (var '' + ($idx) + '' = '' + (0) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],34:[function(require,module,exports){
''use strict'';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
out += ''var division'' + ($lvl) + '';if ('';
if ($isData) {
out += '' '' + ($schemaValue) + '' !== undefined && ( typeof '' + ($schemaValue) + '' != \\\\''number\\\\'' || '';
}
out += '' (division'' + ($lvl) + '' = '' + ($data) + '' / '' + ($schemaValue) + '', '';
if (it.opts.multipleOfPrecision) {
out += '' Math.abs(Math.round(division'' + ($lvl) + '') - division'' + ($lvl) + '') > 1e-'' + (it.opts.multipleOfPrecision) + '' '';
} else {
out += '' division'' + ($lvl) + '' !== parseInt(division'' + ($lvl) + '') '';
}
out += '' ) '';
if ($isData) {
out += ''  )  '';
}
out += '' ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''multipleOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { multipleOf: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be multiple of '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],35:[function(require,module,exports){
''use strict'';
module.exports = function generate_not(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.createErrors = false;
var $allErrorsOption;
if ($it.opts.allErrors) {
$allErrorsOption = $it.opts.allErrors;
$it.opts.allErrors = false;
}
out += '' '' + (it.validate($it)) + '' '';
$it.createErrors = true;
if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if ('' + ($nextValid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
} else {
out += ''  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if ($breakOnError) {
out += '' if (false) { '';
}
}
return out;
}
},{}],36:[function(require,module,exports){
''use strict'';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
out += ''var '' + ($errs) + '' = errors;var prevValid'' + ($lvl) + '' = false;var '' + ($valid) + '' = false;'';
var $currentBaseId = $it.baseId;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
} else {
out += '' var '' + ($nextValid) + '' = true; '';
}
if ($i) {
out += '' if ('' + ($nextValid) + '' && prevValid'' + ($lvl) + '') '' + ($valid) + '' = false; else { '';
$closingBraces += ''}'';
}
out += '' if ('' + ($nextValid) + '') '' + ($valid) + '' = prevValid'' + ($lvl) + '' = true;'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '''' + ($closingBraces) + ''if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''oneOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match exactly one schema in oneOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += ''} else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; }'';
if (it.opts.allErrors) {
out += '' } '';
}
return out;
}
},{}],37:[function(require,module,exports){
''use strict'';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $regexp = $isData ? ''(new RegExp('' + $schemaValue + ''))'' : it.usePattern($schema);
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' !'' + ($regexp) + ''.test('' + ($data) + '') ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''pattern'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { pattern:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match pattern \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],38:[function(require,module,exports){
''use strict'';
module.exports = function generate_properties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl;
var $schemaKeys = Object.keys($schema || {}),
$pProperties = it.schema.patternProperties || {},
$pPropertyKeys = Object.keys($pProperties),
$aProperties = it.schema.additionalProperties,
$someProperties = $schemaKeys.length || $pPropertyKeys.length,
$noAdditional = $aProperties === false,
$additionalIsSchema = typeof $aProperties == ''object'' && Object.keys($aProperties).length,
$removeAdditional = it.opts.removeAdditional,
$checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
var $required = it.schema.required;
if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
if (it.opts.patternGroups) {
var $pgProperties = it.schema.patternGroups || {},
$pgPropertyKeys = Object.keys($pgProperties);
}
out += ''var '' + ($errs) + '' = errors;var '' + ($nextValid) + '' = true;'';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined;'';
}
if ($checkAdditional) {
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
if ($someProperties) {
out += '' var isAdditional'' + ($lvl) + '' = !(false '';
if ($schemaKeys.length) {
if ($schemaKeys.length > 5) {
out += '' || validate.schema'' + ($schemaPath) + ''['' + ($key) + ''] '';
} else {
var arr1 = $schemaKeys;
if (arr1) {
var $propertyKey, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$propertyKey = arr1[i1 += 1];
out += '' || '' + ($key) + '' == '' + (it.util.toQuotedString($propertyKey)) + '' '';
}
}
}
}
if ($pPropertyKeys.length) {
var arr2 = $pPropertyKeys;
if (arr2) {
var $pProperty, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$pProperty = arr2[$i += 1];
out += '' || '' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '') '';
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr3 = $pgPropertyKeys;
if (arr3) {
var $pgProperty, $i = -1,
l3 = arr3.length - 1;
while ($i < l3) {
$pgProperty = arr3[$i += 1];
out += '' || '' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '') '';
}
}
}
out += '' ); if (isAdditional'' + ($lvl) + '') { '';
}
if ($removeAdditional == ''all'') {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
var $currentErrorPath = it.errorPath;
var $additionalProperty = ''\\\\'' + '' + $key + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
}
if ($noAdditional) {
if ($removeAdditional) {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
out += '' '' + ($nextValid) + '' = false; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { additionalProperty: \\\\'''' + ($additionalProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have additional properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' break; '';
}
}
} else if ($additionalIsSchema) {
if ($removeAdditional == ''failing'') {
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if (!'' + ($nextValid) + '') { errors = '' + ($errs) + ''; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete '' + ($data) + ''['' + ($key) + '']; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
} else {
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
}
}
it.errorPath = $currentErrorPath;
}
if ($someProperties) {
out += '' } '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
var $useDefaults = it.opts.useDefaults && !it.compositeRule;
if ($schemaKeys.length) {
var arr4 = $schemaKeys;
if (arr4) {
var $propertyKey, i4 = -1,
l4 = arr4.length - 1;
while (i4 < l4) {
$propertyKey = arr4[i4 += 1];
var $sch = $schema[$propertyKey];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
var $prop = it.util.getProperty($propertyKey),
$passData = $data + $prop,
$hasDefault = $useDefaults && $sch.default !== undefined;
$it.schema = $sch;
$it.schemaPath = $schemaPath + $prop;
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($propertyKey);
$it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
$it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
$code = it.util.varReplace($code, $nextData, $passData);
var $useData = $passData;
} else {
var $useData = $nextData;
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '';
}
if ($hasDefault) {
out += '' '' + ($code) + '' '';
} else {
if ($requiredHash && $requiredHash[$propertyKey]) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = false; '';
var $currentErrorPath = it.errorPath,
$currErrSchemaPath = $errSchemaPath,
$missingProperty = it.util.escapeQuotes($propertyKey);
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
$errSchemaPath = it.errSchemaPath + ''/required'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
it.errorPath = $currentErrorPath;
out += '' } else { '';
} else {
if ($breakOnError) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = true; } else { '';
} else {
out += '' if ('' + ($useData) + '' !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '' ) { '';
}
}
out += '' '' + ($code) + '' } '';
}
}
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($pPropertyKeys.length) {
var arr5 = $pPropertyKeys;
if (arr5) {
var $pProperty, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$pProperty = arr5[i5 += 1];
var $sch = $pProperties[$pProperty];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternProperties'' + it.util.getProperty($pProperty);
$it.errSchemaPath = it.errSchemaPath + ''/patternProperties/'' + it.util.escapeFragment($pProperty);
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '')) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr6 = $pgPropertyKeys;
if (arr6) {
var $pgProperty, i6 = -1,
l6 = arr6.length - 1;
while (i6 < l6) {
$pgProperty = arr6[i6 += 1];
var $pgSchema = $pgProperties[$pgProperty],
$sch = $pgSchema.schema;
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternGroups'' + it.util.getProperty($pgProperty) + ''.schema'';
$it.errSchemaPath = it.errSchemaPath + ''/patternGroups/'' + it.util.escapeFragment($pgProperty) + ''/schema'';
out += '' var pgPropCount'' + ($lvl) + '' = 0;  '';
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '')) { pgPropCount'' + ($lvl) + ''++; '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
var $pgMin = $pgSchema.minimum,
$pgMax = $pgSchema.maximum;
if ($pgMin !== undefined || $pgMax !== undefined) {
out += '' var '' + ($valid) + '' = true; '';
var $currErrSchemaPath = $errSchemaPath;
if ($pgMin !== undefined) {
var $limit = $pgMin,
$reason = ''minimum'',
$moreOrLess = ''less'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' >= '' + ($pgMin) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/minimum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($pgMax !== undefined) {
out += '' else '';
}
}
if ($pgMax !== undefined) {
var $limit = $pgMax,
$reason = ''maximum'',
$moreOrLess = ''more'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' <= '' + ($pgMax) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/maximum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],39:[function(require,module,exports){
''use strict'';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$i = ''i'' + $lvl,
$invalidName = ''\\\\'' + '' + $key + '' + \\\\'''',
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
out += '' var '' + ($errs) + '' = errors; '';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined; '';
}
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' var startErrs'' + ($lvl) + '' = errors; '';
var $passData = $key;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if (!'' + ($nextValid) + '') { for (var '' + ($i) + ''=startErrs'' + ($lvl) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { vErrors['' + ($i) + ''].propertyName = '' + ($key) + ''; }   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''propertyNames'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { propertyName: \\\\'''' + ($invalidName) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''property name \\\\\\\\\\\\'''' + ($invalidName) + ''\\\\\\\\\\\\'' is invalid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
if ($breakOnError) {
out += '' break; '';
}
out += '' } }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],40:[function(require,module,exports){
''use strict'';
module.exports = function generate_ref(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $async, $refCode;
if ($schema == ''#'' || $schema == ''#/'') {
if (it.isRoot) {
$async = it.async;
$refCode = ''validate'';
} else {
$async = it.root.schema.$async === true;
$refCode = ''root.refVal[0]'';
}
} else {
var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
if ($refVal === undefined) {
var $message = it.MissingRefError.message(it.baseId, $schema);
if (it.opts.missingRefs == ''fail'') {
console.error($message);
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''$ref'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { ref: \\\\'''' + (it.util.escapeQuotes($schema)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''can\\\\\\\\\\\\''t resolve reference '' + (it.util.escapeQuotes($schema)) + ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: '' + (it.util.toQuotedString($schema)) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
if ($breakOnError) {
out += '' if (false) { '';
}
} else if (it.opts.missingRefs == ''ignore'') {
console.warn($message);
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
throw new it.MissingRefError(it.baseId, $schema, $message);
}
} else if ($refVal.inline) {
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $refVal.schema;
$it.schemaPath = '''';
$it.errSchemaPath = $schema;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $refVal.code);
out += '' '' + ($code) + '' '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
}
} else {
$async = $refVal.$async === true;
$refCode = $refVal.code;
}
}
if ($refCode) {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
if (it.opts.passContext) {
out += '' '' + ($refCode) + ''.call(this, '';
} else {
out += '' '' + ($refCode) + ''( '';
}
out += '' '' + ($data) + '', (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '', rootData)  '';
var __callValidate = out;
out = $$outStack.pop();
if ($async) {
if (!it.async) throw new Error(''async schema referenced by sync schema'');
if ($breakOnError) {
out += '' var '' + ($valid) + ''; '';
}
out += '' try { '' + (it.yieldAwait) + '' '' + (__callValidate) + ''; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = true; '';
}
out += '' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = false; '';
}
out += '' } '';
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
}
} else {
out += '' if (!'' + (__callValidate) + '') { if (vErrors === null) vErrors = '' + ($refCode) + ''.errors; else vErrors = vErrors.concat('' + ($refCode) + ''.errors); errors = vErrors.length; } '';
if ($breakOnError) {
out += '' else { '';
}
}
}
return out;
}
},{}],41:[function(require,module,exports){
''use strict'';
module.exports = function generate_required(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $vSchema = ''schema'' + $lvl;
if (!$isData) {
if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
var $required = [];
var arr1 = $schema;
if (arr1) {
var $property, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$property = arr1[i1 += 1];
var $propertySch = it.schema.properties[$property];
if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
$required[$required.length] = $property;
}
}
}
} else {
var $required = $schema;
}
}
if ($isData || $required.length) {
var $currentErrorPath = it.errorPath,
$loopRequired = $isData || $required.length >= it.opts.loopRequired,
$ownProperties = it.opts.ownProperties;
if ($breakOnError) {
out += '' var missing'' + ($lvl) + ''; '';
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
out += '' var '' + ($valid) + '' = true; '';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { '' + ($valid) + '' = '' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += ''; if (!'' + ($valid) + '') break; } '';
if ($isData) {
out += ''  }  '';
}
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
} else {
out += '' if ( '';
var arr2 = $required;
if (arr2) {
var $propertyKey, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$propertyKey = arr2[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '') {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
}
} else {
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
if ($isData) {
out += '' if ('' + ($vSchema) + '' && !Array.isArray('' + ($vSchema) + '')) {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ('' + ($vSchema) + '' !== undefined) { '';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { if ('' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } '';
if ($isData) {
out += ''  }  '';
}
} else {
var arr3 = $required;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
}
it.errorPath = $currentErrorPath;
} else if ($breakOnError) {
out += '' if (true) {'';
}
return out;
}
},{}],42:[function(require,module,exports){
''use strict'';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (($schema || $isData) && it.opts.uniqueItems !== false) {
if ($isData) {
out += '' var '' + ($valid) + ''; if ('' + ($schemaValue) + '' === false || '' + ($schemaValue) + '' === undefined) '' + ($valid) + '' = true; else if (typeof '' + ($schemaValue) + '' != \\\\''boolean\\\\'') '' + ($valid) + '' = false; else { '';
}
out += '' var '' + ($valid) + '' = true; if ('' + ($data) + ''.length > 1) { var i = '' + ($data) + ''.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal('' + ($data) + ''[i], '' + ($data) + ''[j])) { '' + ($valid) + '' = false; break outer; } } } } '';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''uniqueItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { i: i, j: j } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have duplicate items (items ## \\\\'' + j + \\\\'' and \\\\'' + i + \\\\'' are identical)\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],43:[function(require,module,exports){
''use strict'';
module.exports = function generate_validate(it, $keyword, $ruleType) {
var out = '''';
var $async = it.schema.$async === true,
$refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, ''$ref''),
$id = it.self._getId(it.schema);
if (it.isTop) {
if ($async) {
it.async = true;
var $es7 = it.opts.async == ''es7'';
it.yieldAwait = $es7 ? ''await'' : ''yield'';
}
out += '' var validate = '';
if ($async) {
if ($es7) {
out += '' (async function '';
} else {
if (it.opts.async != ''*'') {
out += ''co.wrap'';
}
out += ''(function* '';
}
} else {
out += '' (function '';
}
out += '' (data, dataPath, parentData, parentDataProperty, rootData) { \\\\''use strict\\\\''; '';
if ($id && (it.opts.sourceCode || it.opts.processCode)) {
out += '' '' + (''/\\\\*# sourceURL='' + $id + '' */'') + '' '';
}
}
if (typeof it.schema == ''boolean'' || !($refKeywords || it.schema.$ref)) {
var $keyword = ''false schema'';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
if (it.schema === false) {
if (it.isTop) {
$breakOnError = true;
} else {
out += '' var '' + ($valid) + '' = false; '';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''false schema'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''boolean schema is false\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
if (it.isTop) {
if ($async) {
out += '' return data; '';
} else {
out += '' validate.errors = null; return true; '';
}
} else {
out += '' var '' + ($valid) + '' = true; '';
}
}
if (it.isTop) {
out += '' }); return validate; '';
}
return out;
}
if (it.isTop) {
var $top = it.isTop,
$lvl = it.level = 0,
$dataLvl = it.dataLevel = 0,
$data = ''data'';
it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
it.baseId = it.baseId || it.rootId;
delete it.isTop;
it.dataPathArr = [undefined];
out += '' var vErrors = null; '';
out += '' var errors = 0;     '';
out += '' if (rootData === undefined) rootData = data; '';
} else {
var $lvl = it.level,
$dataLvl = it.dataLevel,
$data = ''data'' + ($dataLvl || '''');
if ($id) it.baseId = it.resolve.url(it.baseId, $id);
if ($async && !it.async) throw new Error(''async schema in sync schema'');
out += '' var errs_'' + ($lvl) + '' = errors;'';
}
var $valid = ''valid'' + $lvl,
$breakOnError = !it.opts.allErrors,
$closingBraces1 = '''',
$closingBraces2 = '''';
var $errorKeyword;
var $typeSchema = it.schema.type,
$typeIsArray = Array.isArray($typeSchema);
if ($typeIsArray && $typeSchema.length == 1) {
$typeSchema = $typeSchema[0];
$typeIsArray = false;
}
if (it.schema.$ref && $refKeywords) {
if (it.opts.extendRefs == ''fail'') {
throw new Error(''$ref: validation keywords used in schema at path \\" '' + it.errSchemaPath + '' \\" (see option extendRefs)'');
} else if (it.opts.extendRefs !== true) {
$refKeywords = false;
console.warn(''$ref: keywords ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
if ($typeSchema) {
if (it.opts.coerceTypes) {
var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
}
var $rulesGroup = it.RULES.types[$typeSchema];
if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'',
$method = $typeIsArray ? ''checkDataTypes'' : ''checkDataType'';
out += '' if ('' + (it.util[$method]($typeSchema, $data, true)) + '') { '';
if ($coerceToTypes) {
var $dataType = ''dataType'' + $lvl,
$coerced = ''coerced'' + $lvl;
out += '' var '' + ($dataType) + '' = typeof '' + ($data) + ''; '';
if (it.opts.coerceTypes == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''object\\\\'' && Array.isArray('' + ($data) + '')) '' + ($dataType) + '' = \\\\''array\\\\''; '';
}
out += '' var '' + ($coerced) + '' = undefined; '';
var $bracesCoercion = '''';
var arr1 = $coerceToTypes;
if (arr1) {
var $type, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$type = arr1[$i += 1];
if ($i) {
out += '' if ('' + ($coerced) + '' === undefined) { '';
$bracesCoercion += ''}'';
}
if (it.opts.coerceTypes == ''array'' && $type != ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''array\\\\'' && '' + ($data) + ''.length == 1) { '' + ($coerced) + '' = '' + ($data) + '' = '' + ($data) + ''[0]; '' + ($dataType) + '' = typeof '' + ($data) + '';  } '';
}
if ($type == ''string'') {
out += '' if ('' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'') '' + ($coerced) + '' = \\\\''\\\\'' + '' + ($data) + ''; else if ('' + ($data) + '' === null) '' + ($coerced) + '' = \\\\''\\\\''; '';
} else if ($type == ''number'' || $type == ''integer'') {
out += '' if ('' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' === null || ('' + ($dataType) + '' == \\\\''string\\\\'' && '' + ($data) + '' && '' + ($data) + '' == +'' + ($data) + '' '';
if ($type == ''integer'') {
out += '' && !('' + ($data) + '' % 1)'';
}
out += '')) '' + ($coerced) + '' = +'' + ($data) + ''; '';
} else if ($type == ''boolean'') {
out += '' if ('' + ($data) + '' === \\\\''false\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === null) '' + ($coerced) + '' = false; else if ('' + ($data) + '' === \\\\''true\\\\'' || '' + ($data) + '' === 1) '' + ($coerced) + '' = true; '';
} else if ($type == ''null'') {
out += '' if ('' + ($data) + '' === \\\\''\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === false) '' + ($coerced) + '' = null; '';
} else if (it.opts.coerceTypes == ''array'' && $type == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''string\\\\'' || '' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' == null) '' + ($coerced) + '' = ['' + ($data) + '']; '';
}
}
}
out += '' '' + ($bracesCoercion) + '' if ('' + ($coerced) + '' === undefined) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  '';
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' '' + ($data) + '' = '' + ($coerced) + ''; '';
if (!$dataLvl) {
out += ''if ('' + ($parentData) + '' !== undefined)'';
}
out += '' '' + ($parentData) + ''['' + ($parentDataProperty) + ''] = '' + ($coerced) + ''; } '';
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
}
out += '' } '';
}
}
if (it.schema.$ref && !$refKeywords) {
out += '' '' + (it.RULES.all.$ref.code(it, ''$ref'')) + '' '';
if ($breakOnError) {
out += '' } if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
} else {
if (it.opts.v5 && it.schema.patternGroups) {
console.warn(''keyword \\" patternGroups \\" is deprecated and disabled. Use option patternGroups: true to enable.'');
}
var arr2 = it.RULES;
if (arr2) {
var $rulesGroup, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$rulesGroup = arr2[i2 += 1];
if ($shouldUseGroup($rulesGroup)) {
if ($rulesGroup.type) {
out += '' if ('' + (it.util.checkDataType($rulesGroup.type, $data)) + '') { '';
}
if (it.opts.useDefaults && !it.compositeRule) {
if ($rulesGroup.type == ''object'' && it.schema.properties) {
var $schema = it.schema.properties,
$schemaKeys = Object.keys($schema);
var arr3 = $schemaKeys;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $sch = $schema[$propertyKey];
if ($sch.default !== undefined) {
var $passData = $data + it.util.getProperty($propertyKey);
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
} else if ($rulesGroup.type == ''array'' && Array.isArray(it.schema.items)) {
var arr4 = it.schema.items;
if (arr4) {
var $sch, $i = -1,
l4 = arr4.length - 1;
while ($i < l4) {
$sch = arr4[$i += 1];
if ($sch.default !== undefined) {
var $passData = $data + ''['' + $i + '']'';
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
}
}
var arr5 = $rulesGroup.rules;
if (arr5) {
var $rule, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$rule = arr5[i5 += 1];
if ($shouldUseRule($rule)) {
var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
if ($code) {
out += '' '' + ($code) + '' '';
if ($breakOnError) {
$closingBraces1 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces1) + '' '';
$closingBraces1 = '''';
}
if ($rulesGroup.type) {
out += '' } '';
if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
out += '' else { '';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
}
if ($breakOnError) {
out += '' if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces2) + '' '';
}
if ($top) {
if ($async) {
out += '' if (errors === 0) return data;           '';
out += '' else throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; '';
out += '' return errors === 0;       '';
}
out += '' }); return validate;'';
} else {
out += '' var '' + ($valid) + '' = errors === errs_'' + ($lvl) + '';'';
}
out = it.util.cleanUpCode(out);
if ($top) {
out = it.util.finalCleanUpCode(out, $async);
}
function $shouldUseGroup($rulesGroup) {
var rules = $rulesGroup.rules;
for (var i = 0; i < rules.length; i++)
if ($shouldUseRule(rules[i])) return true;
}
function $shouldUseRule($rule) {
return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImlementsSomeKeyword($rule));
}
function $ruleImlementsSomeKeyword($rule) {
var impl = $rule.implements;
for (var i = 0; i < impl.length; i++)
if (it.schema[impl[i]] !== undefined) return true;
}
return out;
}
},{}],44:[function(require,module,exports){
''use strict'';
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require(''./dotjs/custom'');
module.exports = {
add: addKeyword,
get: getKeyword,
remove: removeKeyword
};
/**
* Define custom keyword
* @this  Ajv
* @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
* @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
*/
function addKeyword(keyword, definition) {
/* jshint validthis: true */
/* eslint no-shadow: 0 */
var RULES = this.RULES;
if (RULES.keywords[keyword])
throw new Error(''Keyword '' + keyword + '' is already defined'');
if (!IDENTIFIER.test(keyword))
throw new Error(''Keyword '' + keyword + '' is not a valid identifier'');
if (definition) {
if (definition.macro && definition.valid !== undefined)
throw new Error(''\\" valid \\" option cannot be used with macro keywords'');
var dataType = definition.type;
if (Array.isArray(dataType)) {
var i, len = dataType.length;
for (i=0; i<len; i++) checkDataType(dataType[i]);
for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
} else {
if (dataType) checkDataType(dataType);
_addRule(keyword, dataType, definition);
}
var $data = definition.$data === true && this._opts.$data;
if ($data && !definition.validate)
throw new Error(''$data support: \\" validate \\" function is not defined'');
var metaSchema = definition.metaSchema;
if (metaSchema) {
if ($data) {
metaSchema = {
anyOf: [
metaSchema,
{ ''$ref'': ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
definition.validateSchema = this.compile(metaSchema, true);
}
}
RULES.keywords[keyword] = RULES.all[keyword] = true;
function _addRule(keyword, dataType, definition) {
var ruleGroup;
for (var i=0; i<RULES.length; i++) {
var rg = RULES[i];
if (rg.type == dataType) {
ruleGroup = rg;
break;
}
}
if (!ruleGroup) {
ruleGroup = { type: dataType, rules: [] };
RULES.push(ruleGroup);
}
var rule = {
keyword: keyword,
definition: definition,
custom: true,
code: customRuleCode,
implements: definition.implements
};
ruleGroup.rules.push(rule);
RULES.custom[keyword] = rule;
}
function checkDataType(dataType) {
if (!RULES.types[dataType]) throw new Error(''Unknown type '' + dataType);
}
}
/**
* Get keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
* @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
*/
function getKeyword(keyword) {
/* jshint validthis: true */
var rule = this.RULES.custom[keyword];
return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
* Remove keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
*/
function removeKeyword(keyword) {
/* jshint validthis: true */
var RULES = this.RULES;
delete RULES.keywords[keyword];
delete RULES.all[keyword];
delete RULES.custom[keyword];
for (var i=0; i<RULES.length; i++) {
var rules = RULES[i].rules;
for (var j=0; j<rules.length; j++) {
if (rules[j].keyword == keyword) {
rules.splice(j, 1);
break;
}
}
}
}
},{\\"./ dotjs / custom \\":29}],45:[function(require,module,exports){
''use strict'';
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
module.exports = function (ajv) {
var defaultMeta = ajv._opts.defaultMeta;
var metaSchemaRef = typeof defaultMeta == ''string''
? { $ref: defaultMeta }
: ajv.getSchema(META_SCHEMA_ID)
? { $ref: META_SCHEMA_ID }
: {};
ajv.addKeyword(''patternGroups'', {
// implemented in properties.jst
metaSchema: {
type: ''object'',
additionalProperties: {
type: ''object'',
required: [ ''schema'' ],
properties: {
maximum: {
type: ''integer'',
minimum: 0
},
minimum: {
type: ''integer'',
minimum: 0
},
schema: metaSchemaRef
},
additionalProperties: false
}
}
});
ajv.RULES.all.properties.implements.push(''patternGroups'');
};
},{}],46:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" https: / / raw.githubusercontent.com / epoberezkin / ajv / master / lib / refs / $ data.json # \\",
\\" description \\": \\" Meta - SCHEMA FOR $ data reference (json - SCHEMA EXTENSION proposal) \\",
\\" TYPE \\": \\" object \\",
\\" required \\": [ \\" $ data \\" ],
\\" properties \\": {
\\" $ data \\": {
\\" TYPE \\": \\" string \\",
\\" anyOf \\": [
{ \\" format \\": \\" relative - json - pointer \\" },
{ \\" format \\": \\" json - pointer \\" }
]
}
},
\\" additionalProperties \\": false
}
},{}],47:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" title \\": \\" Core SCHEMA meta - SCHEMA \\",
\\" definitions \\": {
\\" schemaArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" items \\": { \\" $ ref \\": \\" # \\" }
},
\\" nonNegativeInteger \\": {
\\" TYPE \\": \\" integer \\",
\\" minimum \\": 0
},
\\" nonNegativeIntegerDefault0 \\": {
\\" allOf \\": [
{ \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
{ \\" DEFAULT \\": 0 }
]
},
\\" simpleTypes \\": {
\\" enum \\": [
\\" ARRAY \\",
\\" boolean \\",
\\" integer \\",
\\" NULL \\",
\\" number \\",
\\" object \\",
\\" string \\"
]
},
\\" stringArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" TYPE \\": \\" string \\" },
\\" uniqueItems \\": true,
\\" DEFAULT \\": []
}
},
\\" TYPE \\": [\\" object \\", \\" boolean \\"],
\\" properties \\": {
\\" $ id \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" $ SCHEMA \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri \\"
},
\\" $ ref \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" title \\": {
\\" TYPE \\": \\" string \\"
},
\\" description \\": {
\\" TYPE \\": \\" string \\"
},
\\" DEFAULT \\": {},
\\" multipleOf \\": {
\\" TYPE \\": \\" number \\",
\\" exclusiveMinimum \\": 0
},
\\" maximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMaximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" minimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMinimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" maxLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" pattern \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" regex \\"
},
\\" additionalItems \\": { \\" $ ref \\": \\" # \\" },
\\" items \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / schemaArray \\" }
],
\\" DEFAULT \\": {}
},
\\" maxItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" uniqueItems \\": {
\\" TYPE \\": \\" boolean \\",
\\" DEFAULT \\": false
},
\\" contains \\": { \\" $ ref \\": \\" # \\" },
\\" maxProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" required \\": { \\" $ ref \\": \\" # / definitions / stringArray \\" },
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" definitions \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" properties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" patternProperties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" dependencies \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / stringArray \\" }
]
}
},
\\" propertyNames \\": { \\" $ ref \\": \\" # \\" },
\\" const \\": {},
\\" enum \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" uniqueItems \\": true
},
\\" TYPE \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
{
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
\\" minItems \\": 1,
\\" uniqueItems \\": true
}
]
},
\\" format \\": { \\" TYPE \\": \\" string \\" },
\\" allOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" anyOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" oneOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" NOT \\": { \\" $ ref \\": \\" # \\" }
},
\\" DEFAULT \\": {}
}
},{}],48:[function(require,module,exports){
/**
* slice() reference.
*/
var slice = Array.prototype.slice;
/**
* Expose \`co\`.
*/
module.exports = co[''default''] = co.co = co;
/**
* Wrap the given generator \`fn\` into a
* function that returns a promise.
* This is a separate function so that
* every \`co()\` call doesn''t create a new,
* unnecessary closure.
*
* @param {GeneratorFunction} fn
* @return {Function}
* @api public
*/
co.wrap = function (fn) {
createPromise.__generatorFunction__ = fn;
return createPromise;
function createPromise() {
return co.call(this, fn.apply(this, arguments));
}
};
/**
* Execute the generator function or a generator
* and return a promise.
*
* @param {Function} fn
* @return {Promise}
* @api public
*/
function co(gen) {
var ctx = this;
var args = slice.call(arguments, 1)
// we wrap everything in a promise to avoid promise chaining,
// which leads to memory leak errors.
// see https://github.com/tj/co/issues/180
return new Promise(function(resolve, reject) {
if (typeof gen === ''function'') gen = gen.apply(ctx, args);
if (!gen || typeof gen.next !== ''function'') return resolve(gen);
onFulfilled();
/**
* @param {Mixed} res
* @return {Promise}
* @api private
*/
function onFulfilled(res) {
var ret;
try {
ret = gen.next(res);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* @param {Error} err
* @return {Promise}
* @api private
*/
function onRejected(err) {
var ret;
try {
ret = gen.throw(err);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* Get the next value in the generator,
* return a promise.
*
* @param {Object} ret
* @return {Promise}
* @api private
*/
function next(ret) {
if (ret.done) return resolve(ret.value);
var value = toPromise.call(ctx, ret.value);
if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
return onRejected(new TypeError(''You may only yield a function, promise, generator, array, or object, ''
+ ''but the following object was passed: \\" '' + String(ret.value) + '' \\"''));
}
});
}
/**
* Convert a \`yield\`ed value into a promise.
*
* @param {Mixed} obj
* @return {Promise}
* @api private
*/
function toPromise(obj) {
if (!obj) return obj;
if (isPromise(obj)) return obj;
if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
if (''function'' == typeof obj) return thunkToPromise.call(this, obj);
if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
if (isObject(obj)) return objectToPromise.call(this, obj);
return obj;
}
/**
* Convert a thunk to a promise.
*
* @param {Function}
* @return {Promise}
* @api private
*/
function thunkToPromise(fn) {
var ctx = this;
return new Promise(function (resolve, reject) {
fn.call(ctx, function (err, res) {
if (err) return reject(err);
if (arguments.length > 2) res = slice.call(arguments, 1);
resolve(res);
});
});
}
/**
* Convert an array of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Array} obj
* @return {Promise}
* @api private
*/
function arrayToPromise(obj) {
return Promise.all(obj.map(toPromise, this));
}
/**
* Convert an object of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Object} obj
* @return {Promise}
* @api private
*/
function objectToPromise(obj){
var results = new obj.constructor();
var keys = Object.keys(obj);
var promises = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var promise = toPromise.call(this, obj[key]);
if (promise && isPromise(promise)) defer(promise, key);
else results[key] = obj[key];
}
return Promise.all(promises).then(function () {
return results;
});
function defer(promise, key) {
// predefine the key in the result
results[key] = undefined;
promises.push(promise.then(function (res) {
results[key] = res;
}));
}
}
/**
* Check if \`obj\` is a promise.
*
* @param {Object} obj
* @return {Boolean}
* @api private
*/
function isPromise(obj) {
return ''function'' == typeof obj.then;
}
/**
* Check if \`obj\` is a generator.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGenerator(obj) {
return ''function'' == typeof obj.next && ''function'' == typeof obj.throw;
}
/**
* Check if \`obj\` is a generator function.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGeneratorFunction(obj) {
var constructor = obj.constructor;
if (!constructor) return false;
if (''GeneratorFunction'' === constructor.name || ''GeneratorFunction'' === constructor.displayName) return true;
return isGenerator(constructor.prototype);
}
/**
* Check for plain object.
*
* @param {Mixed} val
* @return {Boolean}
* @api private
*/
function isObject(val) {
return Object == val.constructor;
}
},{}],49:[function(require,module,exports){
''use strict'';
module.exports = function equal(a, b) {
if (a === b) return true;
var arrA = Array.isArray(a)
, arrB = Array.isArray(b)
, i;
if (arrA && arrB) {
if (a.length != b.length) return false;
for (i = 0; i < a.length; i++)
if (!equal(a[i], b[i])) return false;
return true;
}
if (arrA != arrB) return false;
if (a && b && typeof a === ''object'' && typeof b === ''object'') {
var keys = Object.keys(a);
if (keys.length !== Object.keys(b).length) return false;
var dateA = a instanceof Date
, dateB = b instanceof Date;
if (dateA && dateB) return a.getTime() == b.getTime();
if (dateA != dateB) return false;
var regexpA = a instanceof RegExp
, regexpB = b instanceof RegExp;
if (regexpA && regexpB) return a.toString() == b.toString();
if (regexpA != regexpB) return false;
for (i = 0; i < keys.length; i++)
if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
for (i = 0; i < keys.length; i++)
if(!equal(a[keys[i]], b[keys[i]])) return false;
return true;
}
return false;
};
},{}],50:[function(require,module,exports){
''use strict'';
var traverse = module.exports = function (schema, opts, cb) {
if (typeof opts == ''function'') {
cb = opts;
opts = {};
}
_traverse(opts, cb, schema, '''', schema);
};
traverse.keywords = {
additionalItems: true,
items: true,
contains: true,
additionalProperties: true,
propertyNames: true,
not: true
};
traverse.arrayKeywords = {
items: true,
allOf: true,
anyOf: true,
oneOf: true
};
traverse.propsKeywords = {
definitions: true,
properties: true,
patternProperties: true,
dependencies: true
};
traverse.skipKeywords = {
enum: true,
const: true,
required: true,
maximum: true,
minimum: true,
exclusiveMaximum: true,
exclusiveMinimum: true,
multipleOf: true,
maxLength: true,
minLength: true,
pattern: true,
format: true,
maxItems: true,
minItems: true,
uniqueItems: true,
maxProperties: true,
minProperties: true
};
function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (schema && typeof schema == ''object'' && !Array.isArray(schema)) {
cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
for (var key in schema) {
var sch = schema[key];
if (Array.isArray(sch)) {
if (key in traverse.arrayKeywords) {
for (var i=0; i<sch.length; i++)
_traverse(opts, cb, sch[i], jsonPtr + ''/'' + key + ''/'' + i, rootSchema, jsonPtr, key, schema, i);
}
} else if (key in traverse.propsKeywords) {
if (sch && typeof sch == ''object'') {
for (var prop in sch)
_traverse(opts, cb, sch[prop], jsonPtr + ''/'' + key + ''/'' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
}
} else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
_traverse(opts, cb, sch, jsonPtr + ''/'' + key, rootSchema, jsonPtr, key, schema);
}
}
}
}
function escapeJsonPtr(str) {
return str.replace(/~/g, ''~0'').replace(/\\\\//g, ''~1'');
}
},{}],51:[function(require,module,exports){
var json = typeof JSON !== ''undefined'' ? JSON : require(''jsonify'');
module.exports = function (obj, opts) {
if (!opts) opts = {};
if (typeof opts === ''function'') opts = { cmp: opts };
var space = opts.space || '''';
if (typeof space === ''number'') space = Array(space+1).join('' '');
var cycles = (typeof opts.cycles === ''boolean'') ? opts.cycles : false;
var replacer = opts.replacer || function(key, value) { return value; };
var cmp = opts.cmp && (function (f) {
return function (node) {
return function (a, b) {
var aobj = { key: a, value: node[a] };
var bobj = { key: b, value: node[b] };
return f(aobj, bobj);
};
};
})(opts.cmp);
var seen = [];
return (function stringify (parent, key, node, level) {
var indent = space ? (''\\\\n'' + new Array(level + 1).join(space)) : '''';
var colonSeparator = space ? '': '' : '':'';
if (node && node.toJSON && typeof node.toJSON === ''function'') {
node = node.toJSON();
}
node = replacer.call(parent, key, node);
if (node === undefined) {
return;
}
if (typeof node !== ''object'' || node === null) {
return json.stringify(node);
}
if (isArray(node)) {
var out = [];
for (var i = 0; i < node.length; i++) {
var item = stringify(node, i, node[i], level+1) || json.stringify(null);
out.push(indent + space + item);
}
return ''['' + out.join('','') + indent + '']'';
}
else {
if (seen.indexOf(node) !== -1) {
if (cycles) return json.stringify(''__cycle__'');
throw new TypeError(''Converting circular structure to JSON'');
}
else seen.push(node);
var keys = objectKeys(node).sort(cmp && cmp(node));
var out = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var value = stringify(node, key, node[key], level+1);
if(!value) continue;
var keyValue = json.stringify(key)
+ colonSeparator
+ value;
;
out.push(indent + space + keyValue);
}
seen.splice(seen.indexOf(node), 1);
return ''{'' + out.join('','') + indent + ''}'';
}
})({ '''': obj }, '''', obj, 0);
};
var isArray = Array.isArray || function (x) {
return {}.toString.call(x) === ''[object Array]'';
};
var objectKeys = Object.keys || function (obj) {
var has = Object.prototype.hasOwnProperty || function () { return true };
var keys = [];
for (var key in obj) {
if (has.call(obj, key)) keys.push(key);
}
return keys;
};
},{\\" jsonify \\":52}],52:[function(require,module,exports){
exports.parse = require(''./lib/parse'');
exports.stringify = require(''./lib/stringify'');
},{\\"./ lib / parse \\":53,\\"./ lib / stringify \\":54}],53:[function(require,module,exports){
var at, // The index of the current character
ch, // The current character
escapee = {
''\\" '':  '' \\"'',
''\\\\\\\\'': ''\\\\\\\\'',
''/'':  ''/'',
b:    ''\\\\b'',
f:    ''\\\\f'',
n:    ''\\\\n'',
r:    ''\\\\r'',
t:    ''\\\\t''
},
text,
error = function (m) {
// Call error when something is wrong.
throw {
name:    ''SyntaxError'',
message: m,
at:      at,
text:    text
};
},
next = function (c) {
// If a c parameter is provided, verify that it matches the current character.
if (c && c !== ch) {
error(\\" Expected ''\\" + c + \\"'' INSTEAD OF ''\\" + ch + \\"'' \\");
}
// Get the next character. When there are no more characters,
// return the empty string.
ch = text.charAt(at);
at += 1;
return ch;
},
number = function () {
// Parse a number value.
var number,
string = '''';
if (ch === ''-'') {
string = ''-'';
next(''-'');
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
if (ch === ''.'') {
string += ''.'';
while (next() && ch >= ''0'' && ch <= ''9'') {
string += ch;
}
}
if (ch === ''e'' || ch === ''E'') {
string += ch;
next();
if (ch === ''-'' || ch === ''+'') {
string += ch;
next();
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
}
number = +string;
if (!isFinite(number)) {
error(\\" Bad number \\");
} else {
return number;
}
},
string = function () {
// Parse a string value.
var hex,
i,
string = '''',
uffff;
// When parsing for string values, we must look for \\" AND characters. IF (ch == = ''\\"'') { while (NEXT ()) { IF (ch == = ''\\"'') { NEXT (); RETURN string; }
ELSE
IF (ch == = ''\\\\\\\\'') { NEXT (); IF (ch == = ''u'') { uffff = 0; FOR (i = 0; i < 4; i + = 1) { hex = parseInt (NEXT (), 16); IF (! isFinite(hex)) { break; } uffff = uffff * 16 + hex; } string + = String.fromCharCode (uffff); }
ELSE
IF (typeof escapee[ch] == = ''string'') { string + = escapee[ch]; }
ELSE
{ break; } }
ELSE
{ string + = ch; } } } error (\\"Bad string\\"); }, white = FUNCTION () { / / SKIP whitespace. while (ch && ch <= '' '') { NEXT (); } }, word = FUNCTION () { / / TRUE, FALSE, OR null. switch (ch) { CASE ''t'' : NEXT (''t''); NEXT (''r''); NEXT (''u''); NEXT (''e''); RETURN TRUE; CASE ''f'' : NEXT (''f''); NEXT (''a''); NEXT (''l''); NEXT (''s''); NEXT (''e''); RETURN FALSE; CASE ''n'' : NEXT (''n''); NEXT (''u''); NEXT (''l''); NEXT (''l''); RETURN NULL; } error (\\"Unexpected ''\\" + ch + \\"''\\"); }, value, / / Place holder FOR the value function. ARRAY = FUNCTION () { / / Parse an ARRAY value. var ARRAY =[]; IF (ch == = ''['') { NEXT (''[''); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; / / empty ARRAY } while (ch) { array.push (value ()); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; } NEXT ('',''); white (); } } error (\\"Bad array\\"); }, object = FUNCTION () { / / Parse an object value. var KEY, object = {}; IF (ch == = ''{'') { NEXT (''{''); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; / / empty object } while (ch) { KEY = string (); white (); NEXT ('':''); IF (Object.hasOwnProperty.call (object, KEY)) { error (''Duplicate key \\"'' + KEY + ''\\"''); } object[KEY] = value (); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; } NEXT ('',''); white (); } } error (\\"Bad object\\"); }; value = FUNCTION () { / / Parse a json value. It could be an object, an ARRAY, a string, a number, / / OR a word. white (); switch (ch) { CASE ''{'' : RETURN object (); CASE ''['' : RETURN ARRAY (); CASE ''\\"'' : RETURN string (); CASE ''-'' : RETURN number (); default: RETURN ch >= ''0'' && ch <= ''9'' ? number () : word (); } }; / / RETURN the json_parse function. It will have access TO ALL OF the above / / functions AND variables. module.exports = FUNCTION (source, reviver) { var result; text = source; at = 0; ch = '' ''; result = value (); white (); IF (ch) { error (\\"Syntax error\\"); } / / IF there IS a reviver FUNCTION, we recursively walk the new structure, / / passing EACH name / value pair TO the reviver FUNCTION FOR possible / / transformation, starting WITH a TEMPORARY root object that holds the result / / IN an empty key. IF there IS NOT a reviver FUNCTION, we simply RETURN the / / result. RETURN typeof reviver == = ''function'' ? (
FUNCTION walk (
holder, KEY
) { var k, v, value = holder[KEY]; IF (
value && typeof value == = ''object''
) { FOR (
k IN value
) { IF (
Object.prototype.hasOwnProperty.call (
value, k
)
) { v = walk (
value, k
); IF (
v != = undefined
) { value[k] = v; }
ELSE
{ DELETE value[k]; } } } } RETURN reviver.call (
holder, KEY, value
); }({'''' : result }, '''')) : result; }; }, {}], 54:[FUNCTION (require, module, exports) { var cx = /[u0000 u00ad u0600 - u0604 u070f u17b4 u17b5 u200c - u200f u2028 - u202f u2060 - u206f ufeff ufff0 - uffff] / g, escapable = /[\\\\\\\\ \\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,
gap,
indent,
meta = {    // table of character substitutions
''\\\\b'': ''\\\\\\\\b'',
''\\\\t'': ''\\\\\\\\t'',
''\\\\n'': ''\\\\\\\\n'',
''\\\\f'': ''\\\\\\\\f'',
''\\\\r'': ''\\\\\\\\r'',
''\\" '' : '' \\\\\\\\ \\"'',
''\\\\\\\\'': ''\\\\\\\\\\\\\\\\''
},
rep;
function quote(string) {
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
escapable.lastIndex = 0;
return escapable.test(string) ? ''\\" '' + string.replace(escapable, function (a) {
var c = meta[a];
return typeof c === '' string '' ? c :
'' \\\\\\\\u '' + ('' 0000 '' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '' \\"'' : ''\\" '' + string + '' \\"''; } FUNCTION str (KEY, holder) { / / Produce a string FROM holder[KEY].var i, / / The LOOP
counter. k, / / The member key. v, / / The member value. length, mind = gap, partial, value = holder[KEY]; / / IF the value has a toJSON method, CALL it TO obtain a replacement value. IF (value && typeof value == = ''object'' && typeof value.toJSON == = ''function'') { value = value.toJSON (KEY); } / / IF we were called WITH a replacer FUNCTION, THEN
CALL the replacer TO / / obtain a replacement value. IF (
typeof rep == = ''function'') { value = rep.call (holder, KEY, value); } / / What happens NEXT depends ON the value ''s type.
switch (typeof value) {
case '' string '':
return quote(value);
case '' number '':
// JSON numbers must be finite. Encode non-finite numbers as null.
return isFinite(value) ? String(value) : '' NULL '';
case '' boolean '':
case '' NULL '':
// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce '' NULL ''. The case is included here in
// the remote chance that this gets fixed someday.
return String(value);
case '' object '':
if (!value) return '' NULL '';
gap += indent;
partial = [];
// Array.isArray
if (Object.prototype.toString.apply(value) === ''[object ARRAY] '') {
length = value.length;
for (i = 0; i < length; i += 1) {
partial[i] = str(i, value) || '' NULL '';
}
// Join all of the elements together, separated with commas, and
// wrap them in brackets.
v = partial.length === 0 ? ''[] '' : gap ?
''[n '' + gap + partial.join('', n '' + gap) + '' n '' + mind + ''] '' :
''['' + partial.join('', '') + ''] '';
gap = mind;
return v;
}
// If the replacer is an array, use it to select the members to be
// stringified.
if (rep && typeof rep === '' object '') {
length = rep.length;
for (i = 0; i < length; i += 1) {
k = rep[i];
if (typeof k === '' string '') {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
else {
// Otherwise, iterate through all of the keys in the object.
for (k in value) {
if (Object.prototype.hasOwnProperty.call(value, k)) {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
// Join all of the member texts together, separated with commas,
// and wrap them in braces.
v = partial.length === 0 ? '' {}'' : gap ? ''{\\\\n'' + gap + partial.join ('',\\\\n'' + gap) + ''\\\\n'' + mind + ''}'' :''{'' + partial.join ('','') + ''}''; gap = mind; RETURN v; } } module.exports = FUNCTION (value, replacer, space) { var i; gap = ''''; indent = ''''; / / IF the space parameter IS a number, make an indent string containing that / / many spaces. IF (typeof space == = ''number'') { FOR (i = 0; i < space; i + = 1) { indent + = '' ''; } } / / IF the space parameter IS a string, it will be used AS the
indent string.
ELSE
IF (typeof space == = ''string'') { indent = space; } / / IF there IS a replacer, it must be a FUNCTION OR an array. / / Otherwise, throw an error. rep = replacer; IF (replacer && typeof replacer != = ''function'' && (typeof replacer != = ''object'' || typeof replacer.length != = ''number'')) { throw new Error (''JSON.stringify''); } / / Make a fake root object containing our value under
the KEY OF ''''. / / RETURN the result OF stringifying the value. RETURN str ('''', {'''' : value }); }; }, {}]}, {},[7]) (7) });
/* plv8 bundle ends */
RETURN module; })(); ');"
`;

exports[`kitchen sink policies 1`] = `
"CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY select_user ON users.\\"user\\" FOR SELECT TO PUBLIC USING ( TRUE );
CREATE POLICY delete_own ON myschema.mytable FOR DELETE TO PUBLIC USING ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY insert_own ON myschema.mytable FOR ALL TO PUBLIC WITH CHECK ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY select_any ON myschema.mytable FOR SELECT TO PUBLIC USING ( TRUE );
CREATE POLICY update_own ON myschema.mytable FOR UPDATE TO PUBLIC USING ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY delete_pol_permissive ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_pol_restrictive ON users.\\"user\\" AS RESTRICTIVE FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );"
`;

exports[`kitchen sink policies 2`] = `
"CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY select_user ON users.\\"user\\" FOR SELECT TO PUBLIC USING ( (TRUE) );
CREATE POLICY delete_own ON myschema.mytable FOR DELETE TO PUBLIC USING ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY insert_own ON myschema.mytable FOR ALL TO PUBLIC WITH CHECK ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY select_any ON myschema.mytable FOR SELECT TO PUBLIC USING ( (TRUE) );
CREATE POLICY update_own ON myschema.mytable FOR UPDATE TO PUBLIC USING ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY delete_pol_permissive ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_pol_restrictive ON users.\\"user\\" AS RESTRICTIVE FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );"
`;

exports[`kitchen sink roles create 1`] = `
"CREATE ROLE app_anonymous;
CREATE ROLE app_authenticated;
CREATE ROLE app_user WITH LOGIN PASSWORD 'xyz';
CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
CREATE ROLE admin1 WITH LOGIN PASSWORD 'jw8s0F4' CREATEDB CREATEROLE INHERIT;
CREATE ROLE admin2 WITH NOLOGIN NOCREATEDB NOCREATEROLE;
CREATE ROLE authy WITH ADMIN app_authenticated;"
`;

exports[`kitchen sink roles create 2`] = `
"CREATE ROLE \\"app_anonymous\\";
CREATE ROLE \\"app_authenticated\\";
CREATE ROLE \\"app_user\\" WITH LOGIN PASSWORD 'xyz';
CREATE ROLE \\"miriam\\" WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
CREATE ROLE \\"admin1\\" WITH LOGIN PASSWORD 'jw8s0F4' CREATEDB CREATEROLE INHERIT;
CREATE ROLE \\"admin2\\" WITH NOLOGIN NOCREATEDB NOCREATEROLE;
CREATE ROLE \\"authy\\" WITH ADMIN app_authenticated;"
`;

exports[`kitchen sink roles grants 1`] = `
"GRANT APP_AUTHENTICATED TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user, super_app_user;"
`;

exports[`kitchen sink roles grants 2`] = `
"GRANT APP_AUTHENTICATED TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user, super_app_user;"
`;

exports[`kitchen sink rules create 1`] = `
"CREATE RULE collections_ins_protect AS ON INSERT TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_upd_protect AS ON UPDATE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_del_protect AS ON DELETE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
CREATE RULE \\"_RETURN\\" AS ON SELECT TO t2 DO INSTEAD SELECT * FROM t1;
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE new.sl_avail <> old.sl_avail DO INSERT INTO shoelace_log VALUES (new.sl_name, new.sl_avail, CURRENT_USER, CURRENT_TIMESTAMP);
CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);"
`;

exports[`kitchen sink rules create 2`] = `
"CREATE RULE collections_ins_protect AS ON INSERT TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_upd_protect AS ON UPDATE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_del_protect AS ON DELETE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name,sl_avail = new.sl_avail,sl_color = new.sl_color,sl_len = new.sl_len,sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
CREATE RULE \\"_RETURN\\" AS ON SELECT TO t2 DO INSTEAD SELECT * FROM t1;
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE new.sl_avail <> old.sl_avail DO INSERT INTO shoelace_log VALUES (new.sl_name, new.sl_avail, CURRENT_USER, CURRENT_TIMESTAMP);
CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);"
`;

exports[`kitchen sink sequences 1`] = `
"CREATE SEQUENCE foo.bar;
CREATE SEQUENCE mysequence increment 5 start 100;
CREATE SEQUENCE three increment -1 minvalue 1 maxvalue 3 start 3 CYCLE;
CREATE SEQUENCE three3 increment -1 minvalue 1 maxvalue 3 start 3 NO CYCLE;
CREATE SEQUENCE app_jobs.jobs_id_seq start 1 increment 1 NO MINVALUE NO MAXVALUE cache 1;"
`;

exports[`kitchen sink sequences 2`] = `
"CREATE SEQUENCE foo.bar;
CREATE SEQUENCE mysequence increment 5 start 100;
CREATE SEQUENCE three increment -1 minvalue 1 maxvalue 3 start 3 CYCLE;
CREATE SEQUENCE three3 increment -1 minvalue 1 maxvalue 3 start 3 NO CYCLE;
CREATE SEQUENCE app_jobs.jobs_id_seq start 1 increment 1 NO MINVALUE NO MAXVALUE cache 1;"
`;

exports[`kitchen sink set 1`] = `
"SET var FROM CURRENT;
RESET client_min_messages;
SET search_path = 'alt_nsp1', 'public';
SET session_authorization = 'regtest_alter_user1';
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
RESET session_authorization;"
`;

exports[`kitchen sink set 2`] = `
"SET var FROM CURRENT;
RESET client_min_messages;
SET search_path = 'alt_nsp1', 'public';
SET session_authorization = 'regtest_alter_user1';
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
RESET session_authorization;"
`;

exports[`kitchen sink tables check 1`] = `
"CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CONSTRAINT positive_price CHECK (price > 0)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0),
discounted_price numeric CHECK (discounted_price > 0),
CHECK (price > discounted_price)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0),
discounted_price numeric CONSTRAINT check_price CHECK (discounted_price > 0),
CHECK (price > discounted_price)
);
CREATE TABLE boomin (
d date,
CHECK (FALSE) NO INHERIT NOT VALID
);
CREATE TABLE boomin (
d date,
CHECK (TRUE) NO INHERIT NOT VALID
);
ALTER TABLE checkitout ADD CHECK (d BETWEEN '2010-01-01'::date AND '2010-12-31'::date) NOT VALID;
ALTER TABLE checkitout2 ADD CHECK (d NOT BETWEEN '2010-01-01'::date AND '2010-12-31'::date) NOT VALID;
CREATE TABLE atacc3 (
test3 int
) INHERITS (atacc1, atacc2);"
`;

exports[`kitchen sink tables check 2`] = `
"CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( price > 0 )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CONSTRAINT positive_price CHECK ( price > 0 )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( price > 0 ),
discounted_price numeric CHECK ( discounted_price > 0 ),
CHECK ( price > discounted_price )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( price > 0 ),
discounted_price numeric CONSTRAINT check_price CHECK ( discounted_price > 0 ),
CHECK ( price > discounted_price )
);
CREATE TABLE boomin (
d date,
CHECK ( (FALSE) ) NO INHERIT NOT VALID
);
CREATE TABLE boomin (
d date,
CHECK ( (TRUE) ) NO INHERIT NOT VALID
);
ALTER TABLE checkitout ADD CHECK ( d BETWEEN '2010-01-01'::date AND '2010-12-31'::date ) NOT VALID;
ALTER TABLE checkitout2 ADD CHECK ( d NOT BETWEEN '2010-01-01'::date AND '2010-12-31'::date ) NOT VALID;
CREATE TABLE atacc3 (
test3 int
) INHERITS ( atacc1, atacc2 );"
`;

exports[`kitchen sink tables custom 1`] = `
"ALTER TABLE myschema.role ADD CONSTRAINT fk_myschema_role_actor_id FOREIGN KEY (actor_id) REFERENCES actors.actor (id) ON DELETE CASCADE ;
CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE actors_private.actor_info (
actor_id uuid PRIMARY KEY REFERENCES actors.actor (id) ON DELETE CASCADE ,
email text NOT NULL UNIQUE CHECK (email ~* '^.+@.+\\\\..+$'),
password_hash text NOT NULL
);
CREATE TABLE foo (
a int,
b int,
PRIMARY KEY (a, b)
);
CREATE TABLE t_full (
a int,
b int,
FOREIGN KEY (a, b) REFERENCES foo   MATCH FULL
);
CREATE TABLE t_simple (
a int,
b int,
FOREIGN KEY (a, b) REFERENCES foo
);"
`;

exports[`kitchen sink tables custom 2`] = `
"ALTER TABLE myschema.role ADD CONSTRAINT fk_myschema_role_actor_id FOREIGN KEY ( actor_id ) REFERENCES actors.actor ( id ) ON DELETE CASCADE;
CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE actors_private.actor_info (
actor_id uuid PRIMARY KEY REFERENCES actors.actor ( id ) ON DELETE CASCADE,
email text NOT NULL UNIQUE CHECK ( email ~* '^.+@.+\\\\..+$' ),
password_hash text NOT NULL
);
CREATE TABLE foo (
a int,
b int,
PRIMARY KEY ( a, b )
);
CREATE TABLE t_full (
a int,
b int,
FOREIGN KEY ( a, b ) REFERENCES foo MATCH FULL
);
CREATE TABLE t_simple (
a int,
b int,
FOREIGN KEY ( a, b ) REFERENCES foo
);"
`;

exports[`kitchen sink tables defaults 1`] = `
"CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ('[-infinity,infinity]')
)"
`;

exports[`kitchen sink tables defaults 2`] = `
"CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ( '[-infinity,infinity]' )
)"
`;

exports[`kitchen sink tables exclude 1`] = `
"CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ('[-infinity,infinity]'),
EXCLUDE USING gist ( lower(name) WITH =, effective WITH && )
)"
`;

exports[`kitchen sink tables exclude 2`] = `
"CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ( '[-infinity,infinity]' ),
EXCLUDE USING gist ( lower(name) WITH =, effective WITH && )
)"
`;

exports[`kitchen sink tables foreign 1`] = `
"CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products (product_no)  ,
quantity int
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products  ,
quantity int
);
CREATE TABLE t1 (
a int PRIMARY KEY,
b int,
c int,
FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
CREATE TABLE products (
product_no int PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
shipping_address text
);
CREATE TABLE order_items (
product_no int REFERENCES products  ,
order_id int REFERENCES orders  ,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables foreign 2`] = `
"CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products ( product_no ),
quantity int
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products,
quantity int
);
CREATE TABLE t1 (
a int PRIMARY KEY,
b int,
c int,
FOREIGN KEY ( b, c ) REFERENCES other_table ( c1, c2 )
);
CREATE TABLE products (
product_no int PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
shipping_address text
);
CREATE TABLE order_items (
product_no int REFERENCES products,
order_id int REFERENCES orders,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables match 1`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables match 2`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables nulls 1`] = `
"CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric
);
CREATE TABLE products (
product_no int NULL,
name text NULL,
price numeric NULL
);
CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK (price > 0)
);"
`;

exports[`kitchen sink tables nulls 2`] = `
"CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric
);
CREATE TABLE products (
product_no int NULL,
name text NULL,
price numeric NULL
);
CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK ( price > 0 )
);"
`;

exports[`kitchen sink tables on_delete 1`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON DELETE RESTRICT ,
order_id int REFERENCES orders ON DELETE CASCADE ,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables on_delete 2`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON DELETE RESTRICT,
order_id int REFERENCES orders ON DELETE CASCADE,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables on_update 1`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products  ON UPDATE RESTRICT,
order_id int REFERENCES orders  ON UPDATE CASCADE,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables on_update 2`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON UPDATE RESTRICT,
order_id int REFERENCES orders ON UPDATE CASCADE,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables temp 1`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TEMPORARY TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TEMPORARY TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TEMPORARY TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables temp 2`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TEMPORARY TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TEMPORARY TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TEMPORARY TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables unique 1`] = `
"CREATE TABLE products (
product_no int UNIQUE,
name text,
price numeric
);
CREATE TABLE products (
product_no int,
name text,
price numeric,
UNIQUE (product_no)
);
CREATE TABLE example (
a int,
b int,
c int,
UNIQUE (a, c)
);
CREATE TABLE products (
product_no int CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);"
`;

exports[`kitchen sink tables unique 2`] = `
"CREATE TABLE products (
product_no int UNIQUE,
name text,
price numeric
);
CREATE TABLE products (
product_no int,
name text,
price numeric,
UNIQUE ( product_no )
);
CREATE TABLE example (
a int,
b int,
c int,
UNIQUE ( a, c )
);
CREATE TABLE products (
product_no int CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);"
`;

exports[`kitchen sink transactions begin_commit 1`] = `
"BEGIN;
CREATE TABLE products (
product_no int,
name text
);
COMMIT;"
`;

exports[`kitchen sink transactions begin_commit 2`] = `
"BEGIN;
CREATE TABLE products (
product_no int,
name text
);
COMMIT;"
`;

exports[`kitchen sink triggers create 1`] = `
"CREATE TRIGGER _100_timestamps
BEFORE INSERT OR UPDATE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.update_timestamps ( );
CREATE TRIGGER _500_increase_job_queue_count
AFTER INSERT ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.jobs__increase_job_queue_count ( );
CREATE TRIGGER _500_decrease_job_queue_count
BEFORE DELETE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.jobs__decrease_job_queue_count ( );
CREATE TRIGGER _900_notify_worker
AFTER INSERT ON app_jobs.jobs
FOR EACH STATEMENT
EXECUTE PROCEDURE app_jobs.do_notify ( 'jobs:insert' );
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.* IS DISTINCT FROM NEW.*)
EXECUTE PROCEDURE log_account_update ( );
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE PROCEDURE view_insert_row ( );
CREATE TRIGGER transfer_insert
AFTER INSERT ON transfer
REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT
EXECUTE PROCEDURE check_transfer_balances_to_zero ( );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs ( );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING OLD TABLE AS oldtab NEW TABLE AS newtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs ( );"
`;

exports[`kitchen sink triggers create 2`] = `
"CREATE TRIGGER _100_timestamps
BEFORE INSERT OR UPDATE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. update_timestamps (  );
CREATE TRIGGER _500_increase_job_queue_count
AFTER INSERT ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. jobs__increase_job_queue_count (  );
CREATE TRIGGER _500_decrease_job_queue_count
BEFORE DELETE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. jobs__decrease_job_queue_count (  );
CREATE TRIGGER _900_notify_worker
AFTER INSERT ON app_jobs.jobs
FOR EACH STATEMENT
EXECUTE PROCEDURE app_jobs. do_notify ( 'jobs:insert' );
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN ( OLD.balance IS DISTINCT FROM NEW.balance )
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN ( OLD.* IS DISTINCT FROM NEW.* )
EXECUTE PROCEDURE log_account_update (  );
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE PROCEDURE view_insert_row (  );
CREATE TRIGGER transfer_insert
AFTER INSERT ON transfer
REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT
EXECUTE PROCEDURE check_transfer_balances_to_zero (  );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs (  );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING OLD TABLE AS oldtab NEW TABLE AS newtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs (  );"
`;

exports[`kitchen sink triggers custom 1`] = `
"DROP SCHEMA IF EXISTS fb;
DROP SCHEMA IF EXISTS fb CASCADE;
CREATE SCHEMA fb;
SET search_path = 'fb', '$user', 'public';
CREATE EXTENSION \\"uuid-ossp\\";
CREATE TABLE \\"user\\" (
id uuid PRIMARY KEY DEFAULT (uuid_generate_v4()),
created timestamptz NOT NULL DEFAULT (now()),
full_name text NOT NULL DEFAULT ('')
);
CREATE TABLE post (
id uuid PRIMARY KEY DEFAULT (uuid_generate_v4()),
created timestamptz NOT NULL DEFAULT (now()),
content text NOT NULL DEFAULT (''),
\\"user\\" uuid REFERENCES \\"user\\"   NOT NULL
);
CREATE TABLE friendship (
first uuid REFERENCES \\"user\\"   NOT NULL,
second uuid REFERENCES \\"user\\"   NOT NULL,
created timestamptz NOT NULL DEFAULT (now()),
UNIQUE (first, second)
);
CREATE FUNCTION check_friendship_symmetry ( ) RETURNS TRIGGER AS $LQLCODEZ$
DECLARE
link friendship;
BEGIN
SELECT * INTO link FROM friendship
WHERE second = NEW.first AND first = NEW.second;
IF NOT FOUND THEN
RAISE EXCEPTION 'Friendships must be INSERTed as pairs.';
END IF;
RETURN NEW;
END
$LQLCODEZ$ LANGUAGE plpgsql IMMUTABLE SET search_path FROM CURRENT;
CREATE CONSTRAINT TRIGGER friendship_symmetry
AFTER INSERT ON friendship
DEFERRABLE INITIALLY DEFERRED FOR EACH ROW
EXECUTE PROCEDURE check_friendship_symmetry ( );
CREATE TRIGGER _500_increase_job_queue_count_update
AFTER UPDATE OF queue_name ON app.jobs
FOR EACH ROW
EXECUTE PROCEDURE app.jobs__increase_job_queue_count ( );"
`;

exports[`kitchen sink triggers custom 2`] = `
"DROP SCHEMA IF EXISTS fb;
DROP SCHEMA IF EXISTS fb CASCADE;
CREATE SCHEMA fb;
SET search_path = 'fb', '$user', 'public';
CREATE EXTENSION \\"uuid-ossp\\";
CREATE TABLE \\"user\\" (
id uuid PRIMARY KEY DEFAULT ( uuid_generate_v4() ),
created timestamptz NOT NULL DEFAULT ( now() ),
full_name text NOT NULL DEFAULT ( '' )
);
CREATE TABLE post (
id uuid PRIMARY KEY DEFAULT ( uuid_generate_v4() ),
created timestamptz NOT NULL DEFAULT ( now() ),
content text NOT NULL DEFAULT ( '' ),
\\"user\\" uuid REFERENCES \\"user\\" NOT NULL
);
CREATE TABLE friendship (
first uuid REFERENCES \\"user\\" NOT NULL,
second uuid REFERENCES \\"user\\" NOT NULL,
created timestamptz NOT NULL DEFAULT ( now() ),
UNIQUE ( first, second )
);
CREATE FUNCTION check_friendship_symmetry (  ) RETURNS trigger AS $EOFCODE$DECLARE
link friendship;
BEGIN
SELECT * INTO link FROM friendship
WHERE second = NEW.first AND first = NEW.second;
IF NOT FOUND THEN
RAISE EXCEPTION 'Friendships must be INSERTed as pairs.';
END IF;
RETURN NEW;
END$EOFCODE$ LANGUAGE plpgsql IMMUTABLE SET search_path FROM CURRENT;
CREATE CONSTRAINT TRIGGER friendship_symmetry
AFTER INSERT ON friendship
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE PROCEDURE check_friendship_symmetry (  );
CREATE TRIGGER _500_increase_job_queue_count_update
AFTER UPDATE OF queue_name ON app.jobs
FOR EACH ROW
EXECUTE PROCEDURE app. jobs__increase_job_queue_count (  );"
`;

exports[`kitchen sink types 1`] = `"CREATE TYPE myschema.mycustomtype AS (id uuid,verify_code text,verify_code_expires_on timestamptz,actor_id uuid);"`;

exports[`kitchen sink types 2`] = `
"CREATE TYPE myschema.mycustomtype AS ( 	id uuid,
verify_code text,
verify_code_expires_on timestamptz,
actor_id uuid );"
`;

exports[`kitchen sink update 1`] = `
"UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
UPDATE update_test SET (b, a) = (SELECT a + 1,
b FROM update_test WHERE a = 1000) WHERE a = 11;
UPDATE something SET (b, a) = (1, 2) WHERE a = 11;
UPDATE update_test SET (c, b, a) = ('bugle', b + 11, DEFAULT) WHERE c = 'foo';
UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
UPDATE something SET a = 1 RETURNING a;
UPDATE something SET a = 1 RETURNING a AS b, c;
UPDATE something SET a = 1 FROM b;
UPDATE something SET a = 1, b = 'b' FROM c INNER JOIN d ON x = d.y, (SELECT * FROM e) AS f WHERE something.x = d.x AND LEAST(something.y, 0) = (f.z + 1);
UPDATE something SET a = 1 RETURNING b AS \\"b#1\\";
UPDATE something SET a = 1 FROM b WHERE c RETURNING *;
UPDATE foo SET f2 = lower(f2), f3 = DEFAULT RETURNING foo.*, f1 + f3 AS sum13;"
`;

exports[`kitchen sink update 2`] = `
"UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
UPDATE update_test SET ( b,a ) = (SELECT a + 1,
b FROM update_test WHERE a = 1000) WHERE a = 11;
UPDATE something SET ( b,a ) = (1, 2) WHERE a = 11;
UPDATE update_test SET ( c,b,a ) = ('bugle', b + 11, DEFAULT) WHERE c = 'foo';
UPDATE shoelace_data SET sl_name = new.sl_name,sl_avail = new.sl_avail,sl_color = new.sl_color,sl_len = new.sl_len,sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
UPDATE something SET a = 1 RETURNING a;
UPDATE something SET a = 1 RETURNING a AS b,c;
UPDATE something SET a = 1 FROM b;
UPDATE something SET a = 1,b = 'b' FROM c INNER JOIN d ON x = d.y, (SELECT * FROM e) AS f WHERE something.x = d.x AND LEAST(something.y, 0) = (f.z + 1);
UPDATE something SET a = 1 RETURNING b AS \\"b#1\\";
UPDATE something SET a = 1 FROM b WHERE c RETURNING *;
UPDATE foo SET f2 = lower(f2),f3 = DEFAULT RETURNING foo.*,f1 + f3 AS sum13;"
`;

exports[`kitchen sink upstream upstream/abstime.sql 1`] = `
"CREATE TABLE abstime_tbl (
f1 abstime
);
BEGIN;
INSERT INTO abstime_tbl (f1) VALUES ('now'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('now'::abstime);
SELECT count(*) AS two FROM abstime_tbl WHERE f1 = 'now';
COMMIT;
DELETE FROM abstime_tbl;
INSERT INTO abstime_tbl (f1) VALUES ('Jan 14, 1973 03:14:21');
INSERT INTO abstime_tbl (f1) VALUES ('Mon May  1 00:30:30 1995'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('epoch'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('infinity'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('-infinity'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('May 10, 1947 23:59:12'::abstime);
INSERT INTO abstime_tbl (f1) VALUES ('Feb 35, 1946 10:00:00');
INSERT INTO abstime_tbl (f1) VALUES ('Feb 28, 1984 25:08:10');
INSERT INTO abstime_tbl (f1) VALUES ('bad date format');
INSERT INTO abstime_tbl (f1) VALUES ('Jun 10, 1843');
SELECT '' AS eight,
* FROM abstime_tbl;
SELECT '' AS six,
* FROM abstime_tbl WHERE abstime_tbl.f1 < 'Jun 30, 2001'::abstime;
SELECT '' AS six,
* FROM abstime_tbl WHERE abstime_tbl.f1 > '-infinity'::abstime;
SELECT '' AS six,
* FROM abstime_tbl WHERE 'May 10, 1947 23:59:12'::abstime <> abstime_tbl.f1;
SELECT '' AS three,
* FROM abstime_tbl WHERE 'epoch'::abstime >= abstime_tbl.f1;
SELECT '' AS four,
* FROM abstime_tbl WHERE abstime_tbl.f1 <= 'Jan 14, 1973 03:14:21'::abstime;
SELECT '' AS four,
f1 AS abstime,
date_part('year', f1) AS year,
date_part('month', f1) AS month,
date_part('day', f1) AS day,
date_part('hour', f1) AS hour,
date_part('minute', f1) AS minute,
date_part('second', f1) AS second FROM abstime_tbl WHERE isfinite(f1) ORDER BY abstime;"
`;

exports[`kitchen sink upstream upstream/abstime.sql 2`] = `
"CREATE TABLE abstime_tbl (
f1 abstime
);
BEGIN;
INSERT INTO abstime_tbl ( f1 ) VALUES ('now'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('now'::abstime);
SELECT count(*) AS two FROM abstime_tbl WHERE f1 = 'now';
COMMIT;
DELETE FROM abstime_tbl;
INSERT INTO abstime_tbl ( f1 ) VALUES ('Jan 14, 1973 03:14:21');
INSERT INTO abstime_tbl ( f1 ) VALUES ('Mon May  1 00:30:30 1995'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('epoch'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('infinity'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('-infinity'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('May 10, 1947 23:59:12'::abstime);
INSERT INTO abstime_tbl ( f1 ) VALUES ('Feb 35, 1946 10:00:00');
INSERT INTO abstime_tbl ( f1 ) VALUES ('Feb 28, 1984 25:08:10');
INSERT INTO abstime_tbl ( f1 ) VALUES ('bad date format');
INSERT INTO abstime_tbl ( f1 ) VALUES ('Jun 10, 1843');
SELECT '' AS eight,
* FROM abstime_tbl;
SELECT '' AS six,
* FROM abstime_tbl WHERE abstime_tbl.f1 < 'Jun 30, 2001'::abstime;
SELECT '' AS six,
* FROM abstime_tbl WHERE abstime_tbl.f1 > '-infinity'::abstime;
SELECT '' AS six,
* FROM abstime_tbl WHERE 'May 10, 1947 23:59:12'::abstime <> abstime_tbl.f1;
SELECT '' AS three,
* FROM abstime_tbl WHERE 'epoch'::abstime >= abstime_tbl.f1;
SELECT '' AS four,
* FROM abstime_tbl WHERE abstime_tbl.f1 <= 'Jan 14, 1973 03:14:21'::abstime;
SELECT '' AS four,
f1 AS abstime,
date_part('year', f1) AS year,
date_part('month', f1) AS month,
date_part('day', f1) AS day,
date_part('hour', f1) AS hour,
date_part('minute', f1) AS minute,
date_part('second', f1) AS second FROM abstime_tbl WHERE isfinite(f1) ORDER BY abstime;"
`;

exports[`kitchen sink upstream upstream/advisory_lock.sql 1`] = `
"BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2);
COMMIT;
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2);
ROLLBACK;
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock(1),
pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2),
pg_advisory_unlock_shared(2, 2);
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
ROLLBACK;
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
COMMIT;
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_lock(1),
pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock(1),
pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2),
pg_advisory_unlock_shared(2, 2);
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_lock(1),
pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';"
`;

exports[`kitchen sink upstream upstream/advisory_lock.sql 2`] = `
"BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2);
COMMIT;
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2);
ROLLBACK;
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock(1),
pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2),
pg_advisory_unlock_shared(2, 2);
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2);
ROLLBACK;
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
BEGIN;
SELECT pg_advisory_xact_lock(1),
pg_advisory_xact_lock(1),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock_shared(2),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock(1, 1),
pg_advisory_xact_lock_shared(2, 2),
pg_advisory_xact_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
COMMIT;
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_lock(1),
pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock(1),
pg_advisory_unlock(1),
pg_advisory_unlock_shared(2),
pg_advisory_unlock_shared(2),
pg_advisory_unlock(1, 1),
pg_advisory_unlock(1, 1),
pg_advisory_unlock_shared(2, 2),
pg_advisory_unlock_shared(2, 2);
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';
SELECT pg_advisory_lock(1),
pg_advisory_lock(1),
pg_advisory_lock_shared(2),
pg_advisory_lock_shared(2),
pg_advisory_lock(1, 1),
pg_advisory_lock(1, 1),
pg_advisory_lock_shared(2, 2),
pg_advisory_lock_shared(2, 2);
SELECT locktype,
classid,
objid,
objsubid,
mode,
granted FROM pg_locks WHERE locktype = 'advisory' ORDER BY classid,
objid,
objsubid;
SELECT pg_advisory_unlock_all();
SELECT count(*) FROM pg_locks WHERE locktype = 'advisory';"
`;

exports[`kitchen sink upstream upstream/bitmapops.sql 1`] = `
"CREATE TABLE bmscantest (
a int,
b int,
t text
);
INSERT INTO bmscantest SELECT r % 53,
r % 59,
'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1, 70000) AS r;
CREATE INDEX i_bmtest_a ON bmscantest (a);
CREATE INDEX i_bmtest_b ON bmscantest (b);
SET enable_indexscan = 'false';
SET enable_seqscan = 'false';
SET work_mem = 64;
SELECT count(*) FROM bmscantest WHERE a = 1 AND b = 1;
SELECT count(*) FROM bmscantest WHERE a = 1 OR b = 1;
DROP TABLE bmscantest;"
`;

exports[`kitchen sink upstream upstream/bitmapops.sql 2`] = `
"CREATE TABLE bmscantest (
a int,
b int,
t text
);
INSERT INTO bmscantest SELECT r % 53,
r % 59,
'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1, 70000) AS r;
CREATE INDEX i_bmtest_a ON bmscantest ( a );
CREATE INDEX i_bmtest_b ON bmscantest ( b );
SET enable_indexscan = 'false';
SET enable_seqscan = 'false';
SET work_mem = 64;
SELECT count(*) FROM bmscantest WHERE a = 1 AND b = 1;
SELECT count(*) FROM bmscantest WHERE a = 1 OR b = 1;
DROP TABLE bmscantest;"
`;

exports[`kitchen sink upstream upstream/boolean.sql 1`] = `
"SELECT 1 AS one;
SELECT TRUE AS \\"true\\";
SELECT FALSE AS \\"false\\";
SELECT 't'::bool AS \\"true\\";
SELECT '   f           '::bool AS \\"false\\";
SELECT 'true'::bool AS \\"true\\";
SELECT 'test'::bool AS error;
SELECT 'false'::bool AS \\"false\\";
SELECT 'foo'::bool AS error;
SELECT 'y'::bool AS \\"true\\";
SELECT 'yes'::bool AS \\"true\\";
SELECT 'yeah'::bool AS error;
SELECT 'n'::bool AS \\"false\\";
SELECT 'no'::bool AS \\"false\\";
SELECT 'nay'::bool AS error;
SELECT 'on'::bool AS \\"true\\";
SELECT 'off'::bool AS \\"false\\";
SELECT 'of'::bool AS \\"false\\";
SELECT 'o'::bool AS error;
SELECT 'on_'::bool AS error;
SELECT 'off_'::bool AS error;
SELECT '1'::bool AS \\"true\\";
SELECT '11'::bool AS error;
SELECT '0'::bool AS \\"false\\";
SELECT '000'::bool AS error;
SELECT ''::bool AS error;
SELECT 't'::bool OR 'f'::bool AS \\"true\\";
SELECT 't'::bool AND 'f'::bool AS \\"false\\";
SELECT NOT ('f'::bool) AS \\"true\\";
SELECT 't'::bool = 'f'::bool AS \\"false\\";
SELECT 't'::bool <> 'f'::bool AS \\"true\\";
SELECT 't'::bool > 'f'::bool AS \\"true\\";
SELECT 't'::bool >= 'f'::bool AS \\"true\\";
SELECT 'f'::bool < 't'::bool AS \\"true\\";
SELECT 'f'::bool <= 't'::bool AS \\"true\\";
SELECT 'TrUe'::text::boolean AS \\"true\\",
'fAlse'::text::boolean AS \\"false\\";
SELECT '    true   '::text::boolean AS \\"true\\",
'     FALSE'::text::boolean AS \\"false\\";
SELECT TRUE::boolean::text AS \\"true\\",
FALSE::boolean::text AS \\"false\\";
SELECT '  tru e '::text::boolean AS invalid;
SELECT ''::text::boolean AS invalid;
CREATE TABLE booltbl1 (
f1 bool
);
INSERT INTO booltbl1 (f1) VALUES ('t'::bool);
INSERT INTO booltbl1 (f1) VALUES ('True'::bool);
INSERT INTO booltbl1 (f1) VALUES ('true'::bool);
SELECT '' AS t_3,
booltbl1.* FROM booltbl1;
SELECT '' AS t_3,
booltbl1.* FROM booltbl1 WHERE f1 = 'true'::bool;
SELECT '' AS t_3,
booltbl1.* FROM booltbl1 WHERE f1 <> 'false'::bool;
SELECT '' AS zero,
booltbl1.* FROM booltbl1 WHERE booleq('false'::bool, f1);
INSERT INTO booltbl1 (f1) VALUES ('f'::bool);
SELECT '' AS f_1,
booltbl1.* FROM booltbl1 WHERE f1 = 'false'::bool;
CREATE TABLE booltbl2 (
f1 bool
);
INSERT INTO booltbl2 (f1) VALUES ('f'::bool);
INSERT INTO booltbl2 (f1) VALUES ('false'::bool);
INSERT INTO booltbl2 (f1) VALUES ('False'::bool);
INSERT INTO booltbl2 (f1) VALUES ('FALSE'::bool);
INSERT INTO booltbl2 (f1) VALUES ('XXX'::bool);
SELECT '' AS f_4,
booltbl2.* FROM booltbl2;
SELECT '' AS tf_12,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 <> booltbl1.f1;
SELECT '' AS tf_12,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE boolne(booltbl2.f1, booltbl1.f1);
SELECT '' AS ff_4,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 = booltbl1.f1 AND booltbl1.f1 = 'false'::bool;
SELECT '' AS tf_12_ff_4,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 = booltbl1.f1 OR booltbl1.f1 = 'true'::bool ORDER BY booltbl1.f1,
booltbl2.f1;
SELECT '' AS \\"True\\",
f1 FROM booltbl1 WHERE f1 IS TRUE;
SELECT '' AS \\"Not False\\",
f1 FROM booltbl1 WHERE f1 IS NOT FALSE;
SELECT '' AS \\"False\\",
f1 FROM booltbl1 WHERE f1 IS FALSE;
SELECT '' AS \\"Not True\\",
f1 FROM booltbl1 WHERE f1 IS NOT TRUE;
SELECT '' AS \\"True\\",
f1 FROM booltbl2 WHERE f1 IS TRUE;
SELECT '' AS \\"Not False\\",
f1 FROM booltbl2 WHERE f1 IS NOT FALSE;
SELECT '' AS \\"False\\",
f1 FROM booltbl2 WHERE f1 IS FALSE;
SELECT '' AS \\"Not True\\",
f1 FROM booltbl2 WHERE f1 IS NOT TRUE;
DROP TABLE booltbl1;
DROP TABLE booltbl2;"
`;

exports[`kitchen sink upstream upstream/boolean.sql 2`] = `
"SELECT 1 AS one;
SELECT (TRUE) AS \\"true\\";
SELECT (FALSE) AS \\"false\\";
SELECT 't'::bool AS \\"true\\";
SELECT '   f           '::bool AS \\"false\\";
SELECT 'true'::bool AS \\"true\\";
SELECT 'test'::bool AS error;
SELECT 'false'::bool AS \\"false\\";
SELECT 'foo'::bool AS error;
SELECT 'y'::bool AS \\"true\\";
SELECT 'yes'::bool AS \\"true\\";
SELECT 'yeah'::bool AS error;
SELECT 'n'::bool AS \\"false\\";
SELECT 'no'::bool AS \\"false\\";
SELECT 'nay'::bool AS error;
SELECT 'on'::bool AS \\"true\\";
SELECT 'off'::bool AS \\"false\\";
SELECT 'of'::bool AS \\"false\\";
SELECT 'o'::bool AS error;
SELECT 'on_'::bool AS error;
SELECT 'off_'::bool AS error;
SELECT '1'::bool AS \\"true\\";
SELECT '11'::bool AS error;
SELECT '0'::bool AS \\"false\\";
SELECT '000'::bool AS error;
SELECT ''::bool AS error;
SELECT 't'::bool OR 'f'::bool AS \\"true\\";
SELECT 't'::bool AND 'f'::bool AS \\"false\\";
SELECT NOT ('f'::bool) AS \\"true\\";
SELECT 't'::bool = 'f'::bool AS \\"false\\";
SELECT 't'::bool <> 'f'::bool AS \\"true\\";
SELECT 't'::bool > 'f'::bool AS \\"true\\";
SELECT 't'::bool >= 'f'::bool AS \\"true\\";
SELECT 'f'::bool < 't'::bool AS \\"true\\";
SELECT 'f'::bool <= 't'::bool AS \\"true\\";
SELECT 'TrUe'::text::boolean AS \\"true\\",
'fAlse'::text::boolean AS \\"false\\";
SELECT '    true   '::text::boolean AS \\"true\\",
'     FALSE'::text::boolean AS \\"false\\";
SELECT (TRUE)::boolean::text AS \\"true\\",
(FALSE)::boolean::text AS \\"false\\";
SELECT '  tru e '::text::boolean AS invalid;
SELECT ''::text::boolean AS invalid;
CREATE TABLE booltbl1 (
f1 bool
);
INSERT INTO booltbl1 ( f1 ) VALUES ('t'::bool);
INSERT INTO booltbl1 ( f1 ) VALUES ('True'::bool);
INSERT INTO booltbl1 ( f1 ) VALUES ('true'::bool);
SELECT '' AS t_3,
booltbl1.* FROM booltbl1;
SELECT '' AS t_3,
booltbl1.* FROM booltbl1 WHERE f1 = 'true'::bool;
SELECT '' AS t_3,
booltbl1.* FROM booltbl1 WHERE f1 <> 'false'::bool;
SELECT '' AS zero,
booltbl1.* FROM booltbl1 WHERE booleq('false'::bool, f1);
INSERT INTO booltbl1 ( f1 ) VALUES ('f'::bool);
SELECT '' AS f_1,
booltbl1.* FROM booltbl1 WHERE f1 = 'false'::bool;
CREATE TABLE booltbl2 (
f1 bool
);
INSERT INTO booltbl2 ( f1 ) VALUES ('f'::bool);
INSERT INTO booltbl2 ( f1 ) VALUES ('false'::bool);
INSERT INTO booltbl2 ( f1 ) VALUES ('False'::bool);
INSERT INTO booltbl2 ( f1 ) VALUES ('FALSE'::bool);
INSERT INTO booltbl2 ( f1 ) VALUES ('XXX'::bool);
SELECT '' AS f_4,
booltbl2.* FROM booltbl2;
SELECT '' AS tf_12,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 <> booltbl1.f1;
SELECT '' AS tf_12,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE boolne(booltbl2.f1, booltbl1.f1);
SELECT '' AS ff_4,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 = booltbl1.f1 AND booltbl1.f1 = 'false'::bool;
SELECT '' AS tf_12_ff_4,
booltbl1.*,
booltbl2.* FROM booltbl1,
booltbl2 WHERE booltbl2.f1 = booltbl1.f1 OR booltbl1.f1 = 'true'::bool ORDER BY booltbl1.f1,
booltbl2.f1;
SELECT '' AS \\"True\\",
f1 FROM booltbl1 WHERE f1 IS TRUE;
SELECT '' AS \\"Not False\\",
f1 FROM booltbl1 WHERE f1 IS NOT FALSE;
SELECT '' AS \\"False\\",
f1 FROM booltbl1 WHERE f1 IS FALSE;
SELECT '' AS \\"Not True\\",
f1 FROM booltbl1 WHERE f1 IS NOT TRUE;
SELECT '' AS \\"True\\",
f1 FROM booltbl2 WHERE f1 IS TRUE;
SELECT '' AS \\"Not False\\",
f1 FROM booltbl2 WHERE f1 IS NOT FALSE;
SELECT '' AS \\"False\\",
f1 FROM booltbl2 WHERE f1 IS FALSE;
SELECT '' AS \\"Not True\\",
f1 FROM booltbl2 WHERE f1 IS NOT TRUE;
DROP TABLE booltbl1;
DROP TABLE booltbl2;"
`;

exports[`kitchen sink upstream upstream/char.sql 1`] = `
"SELECT 'c'::pg_catalog.bpchar = 'c'::pg_catalog.bpchar AS \\"true\\";
CREATE TABLE char_tbl (
f1 char(1)
);
INSERT INTO char_tbl (f1) VALUES ('a');
INSERT INTO char_tbl (f1) VALUES ('A');
INSERT INTO char_tbl (f1) VALUES ('1');
INSERT INTO char_tbl (f1) VALUES (2);
INSERT INTO char_tbl (f1) VALUES ('3');
INSERT INTO char_tbl (f1) VALUES ('');
INSERT INTO char_tbl (f1) VALUES ('cd');
INSERT INTO char_tbl (f1) VALUES ('c     ');
SELECT '' AS seven,
* FROM char_tbl;
SELECT '' AS six,
c.* FROM char_tbl AS c WHERE c.f1 <> 'a';
SELECT '' AS one,
c.* FROM char_tbl AS c WHERE c.f1 = 'a';
SELECT '' AS five,
c.* FROM char_tbl AS c WHERE c.f1 < 'a';
SELECT '' AS six,
c.* FROM char_tbl AS c WHERE c.f1 <= 'a';
SELECT '' AS one,
c.* FROM char_tbl AS c WHERE c.f1 > 'a';
SELECT '' AS two,
c.* FROM char_tbl AS c WHERE c.f1 >= 'a';
DROP TABLE char_tbl;
CREATE TABLE char_tbl (
f1 char(4)
);
INSERT INTO char_tbl (f1) VALUES ('a');
INSERT INTO char_tbl (f1) VALUES ('ab');
INSERT INTO char_tbl (f1) VALUES ('abcd');
INSERT INTO char_tbl (f1) VALUES ('abcde');
INSERT INTO char_tbl (f1) VALUES ('abcd    ');
SELECT '' AS four,
* FROM char_tbl;"
`;

exports[`kitchen sink upstream upstream/char.sql 2`] = `
"SELECT 'c'::pg_catalog.bpchar = 'c'::pg_catalog.bpchar AS \\"true\\";
CREATE TABLE char_tbl (
f1 char(1)
);
INSERT INTO char_tbl ( f1 ) VALUES ('a');
INSERT INTO char_tbl ( f1 ) VALUES ('A');
INSERT INTO char_tbl ( f1 ) VALUES ('1');
INSERT INTO char_tbl ( f1 ) VALUES (2);
INSERT INTO char_tbl ( f1 ) VALUES ('3');
INSERT INTO char_tbl ( f1 ) VALUES ('');
INSERT INTO char_tbl ( f1 ) VALUES ('cd');
INSERT INTO char_tbl ( f1 ) VALUES ('c     ');
SELECT '' AS seven,
* FROM char_tbl;
SELECT '' AS six,
c.* FROM char_tbl AS c WHERE c.f1 <> 'a';
SELECT '' AS one,
c.* FROM char_tbl AS c WHERE c.f1 = 'a';
SELECT '' AS five,
c.* FROM char_tbl AS c WHERE c.f1 < 'a';
SELECT '' AS six,
c.* FROM char_tbl AS c WHERE c.f1 <= 'a';
SELECT '' AS one,
c.* FROM char_tbl AS c WHERE c.f1 > 'a';
SELECT '' AS two,
c.* FROM char_tbl AS c WHERE c.f1 >= 'a';
DROP TABLE char_tbl;
CREATE TABLE char_tbl (
f1 char(4)
);
INSERT INTO char_tbl ( f1 ) VALUES ('a');
INSERT INTO char_tbl ( f1 ) VALUES ('ab');
INSERT INTO char_tbl ( f1 ) VALUES ('abcd');
INSERT INTO char_tbl ( f1 ) VALUES ('abcde');
INSERT INTO char_tbl ( f1 ) VALUES ('abcd    ');
SELECT '' AS four,
* FROM char_tbl;"
`;

exports[`kitchen sink upstream upstream/circle.sql 1`] = `
"CREATE TABLE circle_tbl (
f1 circle
);
INSERT INTO circle_tbl VALUES ('<(5,1),3>');
INSERT INTO circle_tbl VALUES ('<(1,2),100>');
INSERT INTO circle_tbl VALUES ('1,3,5');
INSERT INTO circle_tbl VALUES ('((1,2),3)');
INSERT INTO circle_tbl VALUES ('<(100,200),10>');
INSERT INTO circle_tbl VALUES ('<(100,1),115>');
INSERT INTO circle_tbl VALUES ('<(-100,0),-100>');
INSERT INTO circle_tbl VALUES ('1abc,3,5');
INSERT INTO circle_tbl VALUES ('(3,(1,2),3)');
SELECT * FROM circle_tbl;
SELECT '' AS six,
center(f1) AS center FROM circle_tbl;
SELECT '' AS six,
radius(f1) AS radius FROM circle_tbl;
SELECT '' AS six,
diameter(f1) AS diameter FROM circle_tbl;
SELECT '' AS two,
f1 FROM circle_tbl WHERE radius(f1) < 5;
SELECT '' AS four,
f1 FROM circle_tbl WHERE diameter(f1) >= 10;
SELECT '' AS five,
c1.f1 AS one,
c2.f1 AS two,
c1.f1 <-> c2.f1 AS distance FROM circle_tbl AS c1,
circle_tbl AS c2 WHERE c1.f1 < c2.f1 AND (c1.f1 <-> c2.f1) > 0 ORDER BY distance,
area(c1.f1),
area(c2.f1);"
`;

exports[`kitchen sink upstream upstream/circle.sql 2`] = `
"CREATE TABLE circle_tbl (
f1 circle
);
INSERT INTO circle_tbl VALUES ('<(5,1),3>');
INSERT INTO circle_tbl VALUES ('<(1,2),100>');
INSERT INTO circle_tbl VALUES ('1,3,5');
INSERT INTO circle_tbl VALUES ('((1,2),3)');
INSERT INTO circle_tbl VALUES ('<(100,200),10>');
INSERT INTO circle_tbl VALUES ('<(100,1),115>');
INSERT INTO circle_tbl VALUES ('<(-100,0),-100>');
INSERT INTO circle_tbl VALUES ('1abc,3,5');
INSERT INTO circle_tbl VALUES ('(3,(1,2),3)');
SELECT * FROM circle_tbl;
SELECT '' AS six,
center(f1) AS center FROM circle_tbl;
SELECT '' AS six,
radius(f1) AS radius FROM circle_tbl;
SELECT '' AS six,
diameter(f1) AS diameter FROM circle_tbl;
SELECT '' AS two,
f1 FROM circle_tbl WHERE radius(f1) < 5;
SELECT '' AS four,
f1 FROM circle_tbl WHERE diameter(f1) >= 10;
SELECT '' AS five,
c1.f1 AS one,
c2.f1 AS two,
c1.f1 <-> c2.f1 AS distance FROM circle_tbl AS c1,
circle_tbl AS c2 WHERE c1.f1 < c2.f1 AND (c1.f1 <-> c2.f1) > 0 ORDER BY distance,
area(c1.f1),
area(c2.f1);"
`;

exports[`kitchen sink upstream upstream/comments.sql 1`] = `
"SELECT 'trailing' AS first;
SELECT 'embedded' AS second;
SELECT 'both' AS third;
SELECT 'before multi-line' AS fourth;
SELECT 'after multi-line' AS fifth;
SELECT 'deeply nested example' AS sixth;"
`;

exports[`kitchen sink upstream upstream/comments.sql 2`] = `
"SELECT 'trailing' AS first;
SELECT 'embedded' AS second;
SELECT 'both' AS third;
SELECT 'before multi-line' AS fourth;
SELECT 'after multi-line' AS fifth;
SELECT 'deeply nested example' AS sixth;"
`;

exports[`kitchen sink upstream upstream/create_misc.sql 1`] = `
"INSERT INTO tenk2 SELECT * FROM tenk1;
SELECT * INTO onek2 FROM onek;
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
SELECT * INTO bprime FROM tenk1 WHERE unique2 < 1000;
INSERT INTO hobbies_r (name, person) SELECT 'posthacking',
p.name FROM person AS p WHERE p.name = 'mike' OR p.name = 'jeff';
INSERT INTO hobbies_r (name, person) SELECT 'basketball',
p.name FROM person AS p WHERE p.name = 'joe' OR p.name = 'sally';
INSERT INTO hobbies_r (name) VALUES ('skywalking');
INSERT INTO equipment_r (name, hobby) VALUES ('advil', 'posthacking');
INSERT INTO equipment_r (name, hobby) VALUES ('peet''s coffee', 'posthacking');
INSERT INTO equipment_r (name, hobby) VALUES ('hightops', 'basketball');
INSERT INTO equipment_r (name, hobby) VALUES ('guts', 'skywalking');
SELECT * INTO ramp FROM road WHERE name ~ '.*Ramp';
INSERT INTO ihighway SELECT * FROM road WHERE name ~ 'I- .*';
INSERT INTO shighway SELECT * FROM road WHERE name ~ 'State Hwy.*';
UPDATE shighway SET surface = 'asphalt';
INSERT INTO a_star (class, a) VALUES ('a', 1);
INSERT INTO a_star (class, a) VALUES ('a', 2);
INSERT INTO a_star (class) VALUES ('a');
INSERT INTO b_star (class, a, b) VALUES ('b', 3, 'mumble'::text);
INSERT INTO b_star (class, a) VALUES ('b', 4);
INSERT INTO b_star (class, b) VALUES ('b', 'bumble'::text);
INSERT INTO b_star (class) VALUES ('b');
INSERT INTO c_star (class, a, c) VALUES ('c', 5, 'hi mom'::name);
INSERT INTO c_star (class, a) VALUES ('c', 6);
INSERT INTO c_star (class, c) VALUES ('c', 'hi paul'::name);
INSERT INTO c_star (class) VALUES ('c');
INSERT INTO d_star (class, a, b, c, d) VALUES ('d', 7, 'grumble'::text, 'hi sunita'::name, '0.0'::float8);
INSERT INTO d_star (class, a, b, c) VALUES ('d', 8, 'stumble'::text, 'hi koko'::name);
INSERT INTO d_star (class, a, b, d) VALUES ('d', 9, 'rumble'::text, '1.1'::float8);
INSERT INTO d_star (class, a, c, d) VALUES ('d', 10, 'hi kristin'::name, '10.01'::float8);
INSERT INTO d_star (class, b, c, d) VALUES ('d', 'crumble'::text, 'hi boris'::name, '100.001'::float8);
INSERT INTO d_star (class, a, b) VALUES ('d', 11, 'fumble'::text);
INSERT INTO d_star (class, a, c) VALUES ('d', 12, 'hi avi'::name);
INSERT INTO d_star (class, a, d) VALUES ('d', 13, '1000.0001'::float8);
INSERT INTO d_star (class, b, c) VALUES ('d', 'tumble'::text, 'hi andrew'::name);
INSERT INTO d_star (class, b, d) VALUES ('d', 'humble'::text, '10000.00001'::float8);
INSERT INTO d_star (class, c, d) VALUES ('d', 'hi ginger'::name, '100000.000001'::float8);
INSERT INTO d_star (class, a) VALUES ('d', 14);
INSERT INTO d_star (class, b) VALUES ('d', 'jumble'::text);
INSERT INTO d_star (class, c) VALUES ('d', 'hi jolly'::name);
INSERT INTO d_star (class, d) VALUES ('d', '1000000.0000001'::float8);
INSERT INTO d_star (class) VALUES ('d');
INSERT INTO e_star (class, a, c, e) VALUES ('e', 15, 'hi carol'::name, '-1'::int2);
INSERT INTO e_star (class, a, c) VALUES ('e', 16, 'hi bob'::name);
INSERT INTO e_star (class, a, e) VALUES ('e', 17, '-2'::int2);
INSERT INTO e_star (class, c, e) VALUES ('e', 'hi michelle'::name, '-3'::int2);
INSERT INTO e_star (class, a) VALUES ('e', 18);
INSERT INTO e_star (class, c) VALUES ('e', 'hi elisa'::name);
INSERT INTO e_star (class, e) VALUES ('e', '-4'::int2);
INSERT INTO f_star (class, a, c, e, f) VALUES ('f', 19, 'hi claire'::name, '-5'::int2, '(1,3),(2,4)'::polygon);
INSERT INTO f_star (class, a, c, e) VALUES ('f', 20, 'hi mike'::name, '-6'::int2);
INSERT INTO f_star (class, a, c, f) VALUES ('f', 21, 'hi marcel'::name, '(11,44),(22,55),(33,66)'::polygon);
INSERT INTO f_star (class, a, e, f) VALUES ('f', 22, '-7'::int2, '(111,555),(222,666),(333,777),(444,888)'::polygon);
INSERT INTO f_star (class, c, e, f) VALUES ('f', 'hi keith'::name, '-8'::int2, '(1111,3333),(2222,4444)'::polygon);
INSERT INTO f_star (class, a, c) VALUES ('f', 24, 'hi marc'::name);
INSERT INTO f_star (class, a, e) VALUES ('f', 25, '-9'::int2);
INSERT INTO f_star (class, a, f) VALUES ('f', 26, '(11111,33333),(22222,44444)'::polygon);
INSERT INTO f_star (class, c, e) VALUES ('f', 'hi allison'::name, '-10'::int2);
INSERT INTO f_star (class, c, f) VALUES ('f', 'hi jeff'::name, '(111111,333333),(222222,444444)'::polygon);
INSERT INTO f_star (class, e, f) VALUES ('f', '-11'::int2, '(1111111,3333333),(2222222,4444444)'::polygon);
INSERT INTO f_star (class, a) VALUES ('f', 27);
INSERT INTO f_star (class, c) VALUES ('f', 'hi carl'::name);
INSERT INTO f_star (class, e) VALUES ('f', '-12'::int2);
INSERT INTO f_star (class, f) VALUES ('f', '(11111111,33333333),(22222222,44444444)'::polygon);
INSERT INTO f_star (class) VALUES ('f');
CREATE TABLE iportaltest (
i int4,
d float4,
p polygon
);
INSERT INTO iportaltest (i, d, p) VALUES (1, 3.567, '(3.0,1.0),(4.0,2.0)'::polygon);
INSERT INTO iportaltest (i, d, p) VALUES (2, 89.05, '(4.0,2.0),(3.0,1.0)'::polygon);"
`;

exports[`kitchen sink upstream upstream/create_misc.sql 2`] = `
"INSERT INTO tenk2 SELECT * FROM tenk1;
SELECT * INTO onek2 FROM onek;
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
SELECT * INTO bprime FROM tenk1 WHERE unique2 < 1000;
INSERT INTO hobbies_r ( name, person ) SELECT 'posthacking',
p.name FROM person AS p WHERE p.name = 'mike' OR p.name = 'jeff';
INSERT INTO hobbies_r ( name, person ) SELECT 'basketball',
p.name FROM person AS p WHERE p.name = 'joe' OR p.name = 'sally';
INSERT INTO hobbies_r ( name ) VALUES ('skywalking');
INSERT INTO equipment_r ( name, hobby ) VALUES ('advil', 'posthacking');
INSERT INTO equipment_r ( name, hobby ) VALUES ('peet''s coffee', 'posthacking');
INSERT INTO equipment_r ( name, hobby ) VALUES ('hightops', 'basketball');
INSERT INTO equipment_r ( name, hobby ) VALUES ('guts', 'skywalking');
SELECT * INTO ramp FROM road WHERE name ~ '.*Ramp';
INSERT INTO ihighway SELECT * FROM road WHERE name ~ 'I- .*';
INSERT INTO shighway SELECT * FROM road WHERE name ~ 'State Hwy.*';
UPDATE shighway SET surface = 'asphalt';
INSERT INTO a_star ( class, a ) VALUES ('a', 1);
INSERT INTO a_star ( class, a ) VALUES ('a', 2);
INSERT INTO a_star ( class ) VALUES ('a');
INSERT INTO b_star ( class, a, b ) VALUES ('b', 3, 'mumble'::text);
INSERT INTO b_star ( class, a ) VALUES ('b', 4);
INSERT INTO b_star ( class, b ) VALUES ('b', 'bumble'::text);
INSERT INTO b_star ( class ) VALUES ('b');
INSERT INTO c_star ( class, a, c ) VALUES ('c', 5, 'hi mom'::name);
INSERT INTO c_star ( class, a ) VALUES ('c', 6);
INSERT INTO c_star ( class, c ) VALUES ('c', 'hi paul'::name);
INSERT INTO c_star ( class ) VALUES ('c');
INSERT INTO d_star ( class, a, b, c, d ) VALUES ('d', 7, 'grumble'::text, 'hi sunita'::name, '0.0'::float8);
INSERT INTO d_star ( class, a, b, c ) VALUES ('d', 8, 'stumble'::text, 'hi koko'::name);
INSERT INTO d_star ( class, a, b, d ) VALUES ('d', 9, 'rumble'::text, '1.1'::float8);
INSERT INTO d_star ( class, a, c, d ) VALUES ('d', 10, 'hi kristin'::name, '10.01'::float8);
INSERT INTO d_star ( class, b, c, d ) VALUES ('d', 'crumble'::text, 'hi boris'::name, '100.001'::float8);
INSERT INTO d_star ( class, a, b ) VALUES ('d', 11, 'fumble'::text);
INSERT INTO d_star ( class, a, c ) VALUES ('d', 12, 'hi avi'::name);
INSERT INTO d_star ( class, a, d ) VALUES ('d', 13, '1000.0001'::float8);
INSERT INTO d_star ( class, b, c ) VALUES ('d', 'tumble'::text, 'hi andrew'::name);
INSERT INTO d_star ( class, b, d ) VALUES ('d', 'humble'::text, '10000.00001'::float8);
INSERT INTO d_star ( class, c, d ) VALUES ('d', 'hi ginger'::name, '100000.000001'::float8);
INSERT INTO d_star ( class, a ) VALUES ('d', 14);
INSERT INTO d_star ( class, b ) VALUES ('d', 'jumble'::text);
INSERT INTO d_star ( class, c ) VALUES ('d', 'hi jolly'::name);
INSERT INTO d_star ( class, d ) VALUES ('d', '1000000.0000001'::float8);
INSERT INTO d_star ( class ) VALUES ('d');
INSERT INTO e_star ( class, a, c, e ) VALUES ('e', 15, 'hi carol'::name, '-1'::int2);
INSERT INTO e_star ( class, a, c ) VALUES ('e', 16, 'hi bob'::name);
INSERT INTO e_star ( class, a, e ) VALUES ('e', 17, '-2'::int2);
INSERT INTO e_star ( class, c, e ) VALUES ('e', 'hi michelle'::name, '-3'::int2);
INSERT INTO e_star ( class, a ) VALUES ('e', 18);
INSERT INTO e_star ( class, c ) VALUES ('e', 'hi elisa'::name);
INSERT INTO e_star ( class, e ) VALUES ('e', '-4'::int2);
INSERT INTO f_star ( class, a, c, e, f ) VALUES ('f', 19, 'hi claire'::name, '-5'::int2, '(1,3),(2,4)'::polygon);
INSERT INTO f_star ( class, a, c, e ) VALUES ('f', 20, 'hi mike'::name, '-6'::int2);
INSERT INTO f_star ( class, a, c, f ) VALUES ('f', 21, 'hi marcel'::name, '(11,44),(22,55),(33,66)'::polygon);
INSERT INTO f_star ( class, a, e, f ) VALUES ('f', 22, '-7'::int2, '(111,555),(222,666),(333,777),(444,888)'::polygon);
INSERT INTO f_star ( class, c, e, f ) VALUES ('f', 'hi keith'::name, '-8'::int2, '(1111,3333),(2222,4444)'::polygon);
INSERT INTO f_star ( class, a, c ) VALUES ('f', 24, 'hi marc'::name);
INSERT INTO f_star ( class, a, e ) VALUES ('f', 25, '-9'::int2);
INSERT INTO f_star ( class, a, f ) VALUES ('f', 26, '(11111,33333),(22222,44444)'::polygon);
INSERT INTO f_star ( class, c, e ) VALUES ('f', 'hi allison'::name, '-10'::int2);
INSERT INTO f_star ( class, c, f ) VALUES ('f', 'hi jeff'::name, '(111111,333333),(222222,444444)'::polygon);
INSERT INTO f_star ( class, e, f ) VALUES ('f', '-11'::int2, '(1111111,3333333),(2222222,4444444)'::polygon);
INSERT INTO f_star ( class, a ) VALUES ('f', 27);
INSERT INTO f_star ( class, c ) VALUES ('f', 'hi carl'::name);
INSERT INTO f_star ( class, e ) VALUES ('f', '-12'::int2);
INSERT INTO f_star ( class, f ) VALUES ('f', '(11111111,33333333),(22222222,44444444)'::polygon);
INSERT INTO f_star ( class ) VALUES ('f');
CREATE TABLE iportaltest (
i int4,
d float4,
p polygon
);
INSERT INTO iportaltest ( i, d, p ) VALUES (1, 3.567, '(3.0,1.0),(4.0,2.0)'::polygon);
INSERT INTO iportaltest ( i, d, p ) VALUES (2, 89.05, '(4.0,2.0),(3.0,1.0)'::polygon);"
`;

exports[`kitchen sink upstream upstream/date.sql 1`] = `
"CREATE TABLE date_tbl (
f1 date
);
INSERT INTO date_tbl VALUES ('1957-04-09');
INSERT INTO date_tbl VALUES ('1957-06-13');
INSERT INTO date_tbl VALUES ('1996-02-28');
INSERT INTO date_tbl VALUES ('1996-02-29');
INSERT INTO date_tbl VALUES ('1996-03-01');
INSERT INTO date_tbl VALUES ('1996-03-02');
INSERT INTO date_tbl VALUES ('1997-02-28');
INSERT INTO date_tbl VALUES ('1997-02-29');
INSERT INTO date_tbl VALUES ('1997-03-01');
INSERT INTO date_tbl VALUES ('1997-03-02');
INSERT INTO date_tbl VALUES ('2000-04-01');
INSERT INTO date_tbl VALUES ('2000-04-02');
INSERT INTO date_tbl VALUES ('2000-04-03');
INSERT INTO date_tbl VALUES ('2038-04-08');
INSERT INTO date_tbl VALUES ('2039-04-09');
INSERT INTO date_tbl VALUES ('2040-04-10');
SELECT f1 AS \\"Fifteen\\" FROM date_tbl;
SELECT f1 AS \\"Nine\\" FROM date_tbl WHERE f1 < '2000-01-01';
SELECT f1 AS \\"Three\\" FROM date_tbl WHERE f1 BETWEEN '2000-01-01' AND '2001-01-01';
SET datestyle = 'iso';
SET datestyle = 'ymd';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SET datestyle = 'dmy';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SET datestyle = 'mdy';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SELECT '4714-11-24 BC'::date;
SELECT '4714-11-23 BC'::date;
SELECT '5874897-12-31'::date;
SELECT '5874898-01-01'::date;
RESET datestyle;
SELECT f1 - '2000-01-01'::date AS \\"Days From 2K\\" FROM date_tbl;
SELECT f1 - 'epoch'::date AS \\"Days From Epoch\\" FROM date_tbl;
SELECT 'yesterday'::date - 'today'::date AS \\"One day\\";
SELECT 'today'::date - 'tomorrow'::date AS \\"One day\\";
SELECT 'yesterday'::date - 'tomorrow'::date AS \\"Two days\\";
SELECT 'tomorrow'::date - 'today'::date AS \\"One day\\";
SELECT 'today'::date - 'yesterday'::date AS \\"One day\\";
SELECT 'tomorrow'::date - 'yesterday'::date AS \\"Two days\\";
SELECT pg_catalog.date_part('epoch', '1970-01-01'::date);
SELECT pg_catalog.date_part('epoch', '1970-01-01'::timestamp);
SELECT pg_catalog.date_part('epoch', '1970-01-01+00'::timestamptz);
SELECT pg_catalog.date_part('century', '0101-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0100-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0001-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0001-01-01'::date);
SELECT pg_catalog.date_part('century', '0001-01-01 AD'::date);
SELECT pg_catalog.date_part('century', '1900-12-31'::date);
SELECT pg_catalog.date_part('century', '1901-01-01'::date);
SELECT pg_catalog.date_part('century', '2000-12-31'::date);
SELECT pg_catalog.date_part('century', '2001-01-01'::date);
SELECT pg_catalog.date_part('century', CURRENT_DATE) >= 21 AS \\"true\\";
SELECT pg_catalog.date_part('millennium', '0001-12-31 BC'::date);
SELECT pg_catalog.date_part('millennium', '0001-01-01 AD'::date);
SELECT pg_catalog.date_part('millennium', '1000-12-31'::date);
SELECT pg_catalog.date_part('millennium', '1001-01-01'::date);
SELECT pg_catalog.date_part('millennium', '2000-12-31'::date);
SELECT pg_catalog.date_part('millennium', '2001-01-01'::date);
SELECT pg_catalog.date_part('millennium', CURRENT_DATE);
SELECT pg_catalog.date_part('decade', '1994-12-25'::date);
SELECT pg_catalog.date_part('decade', '0010-01-01'::date);
SELECT pg_catalog.date_part('decade', '0009-12-31'::date);
SELECT pg_catalog.date_part('decade', '0001-01-01 BC'::date);
SELECT pg_catalog.date_part('decade', '0002-12-31 BC'::date);
SELECT pg_catalog.date_part('decade', '0011-01-01 BC'::date);
SELECT pg_catalog.date_part('decade', '0012-12-31 BC'::date);
SELECT pg_catalog.date_part('century', now()) >= 21 AS \\"true\\";
SELECT pg_catalog.date_part('century', '1970-03-20 04:30:00.00000'::timestamp);
SELECT pg_catalog.date_part('century', '100 y'::interval);
SELECT pg_catalog.date_part('century', '99 y'::interval);
SELECT pg_catalog.date_part('century', '-99 y'::interval);
SELECT pg_catalog.date_part('century', '-100 y'::interval);
SELECT date_trunc('MILLENNIUM', '1970-03-20 04:30:00.00000'::timestamp);
SELECT date_trunc('MILLENNIUM', '1970-03-20'::date);
SELECT date_trunc('CENTURY', '1970-03-20 04:30:00.00000'::timestamp);
SELECT date_trunc('CENTURY', '1970-03-20'::date);
SELECT date_trunc('CENTURY', '2004-08-10'::date);
SELECT date_trunc('CENTURY', '0002-02-04'::date);
SELECT date_trunc('CENTURY', '0055-08-10 BC'::date);
SELECT date_trunc('DECADE', '1993-12-25'::date);
SELECT date_trunc('DECADE', '0004-12-25'::date);
SELECT date_trunc('DECADE', '0002-12-31 BC'::date);
SELECT 'infinity'::date,
'-infinity'::date;
SELECT 'infinity'::date > 'today'::date AS t;
SELECT '-infinity'::date < 'today'::date AS t;
SELECT isfinite('infinity'::date),
isfinite('-infinity'::date),
isfinite('today'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::date);
SELECT pg_catalog.date_part('hour', '-infinity'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::timestamp);
SELECT pg_catalog.date_part('hour', '-infinity'::timestamp);
SELECT pg_catalog.date_part('hour', 'infinity'::timestamptz);
SELECT pg_catalog.date_part('hour', '-infinity'::timestamptz);
SELECT pg_catalog.date_part('microseconds', 'infinity'::date);
SELECT pg_catalog.date_part('milliseconds', 'infinity'::date);
SELECT pg_catalog.date_part('second', 'infinity'::date);
SELECT pg_catalog.date_part('minute', 'infinity'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::date);
SELECT pg_catalog.date_part('day', 'infinity'::date);
SELECT pg_catalog.date_part('month', 'infinity'::date);
SELECT pg_catalog.date_part('quarter', 'infinity'::date);
SELECT pg_catalog.date_part('week', 'infinity'::date);
SELECT pg_catalog.date_part('dow', 'infinity'::date);
SELECT pg_catalog.date_part('isodow', 'infinity'::date);
SELECT pg_catalog.date_part('doy', 'infinity'::date);
SELECT pg_catalog.date_part('timezone', 'infinity'::date);
SELECT pg_catalog.date_part('timezone_m', 'infinity'::date);
SELECT pg_catalog.date_part('timezone_h', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', '-infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::timestamp);
SELECT pg_catalog.date_part('epoch', '-infinity'::timestamp);
SELECT pg_catalog.date_part('epoch', 'infinity'::timestamptz);
SELECT pg_catalog.date_part('epoch', '-infinity'::timestamptz);
SELECT pg_catalog.date_part('year', 'infinity'::date);
SELECT pg_catalog.date_part('decade', 'infinity'::date);
SELECT pg_catalog.date_part('century', 'infinity'::date);
SELECT pg_catalog.date_part('millennium', 'infinity'::date);
SELECT pg_catalog.date_part('julian', 'infinity'::date);
SELECT pg_catalog.date_part('isoyear', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::date);
SELECT pg_catalog.date_part('microsec', 'infinity'::date);
SELECT pg_catalog.date_part('undefined', 'infinity'::date);
SELECT make_date(2013, 7, 15);
SELECT make_time(8, 20, 0.0);
SELECT make_date(2013, 2, 30);
SELECT make_date(2013, 13, 1);
SELECT make_date(2013, 11, (-1));
SELECT make_date((-44), 3, 15);
SELECT make_time(10, 55, 100.1);
SELECT make_time(24, 0, 2.1);"
`;

exports[`kitchen sink upstream upstream/date.sql 2`] = `
"CREATE TABLE date_tbl (
f1 date
);
INSERT INTO date_tbl VALUES ('1957-04-09');
INSERT INTO date_tbl VALUES ('1957-06-13');
INSERT INTO date_tbl VALUES ('1996-02-28');
INSERT INTO date_tbl VALUES ('1996-02-29');
INSERT INTO date_tbl VALUES ('1996-03-01');
INSERT INTO date_tbl VALUES ('1996-03-02');
INSERT INTO date_tbl VALUES ('1997-02-28');
INSERT INTO date_tbl VALUES ('1997-02-29');
INSERT INTO date_tbl VALUES ('1997-03-01');
INSERT INTO date_tbl VALUES ('1997-03-02');
INSERT INTO date_tbl VALUES ('2000-04-01');
INSERT INTO date_tbl VALUES ('2000-04-02');
INSERT INTO date_tbl VALUES ('2000-04-03');
INSERT INTO date_tbl VALUES ('2038-04-08');
INSERT INTO date_tbl VALUES ('2039-04-09');
INSERT INTO date_tbl VALUES ('2040-04-10');
SELECT f1 AS \\"Fifteen\\" FROM date_tbl;
SELECT f1 AS \\"Nine\\" FROM date_tbl WHERE f1 < '2000-01-01';
SELECT f1 AS \\"Three\\" FROM date_tbl WHERE f1 BETWEEN '2000-01-01' AND '2001-01-01';
SET datestyle = 'iso';
SET datestyle = 'ymd';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SET datestyle = 'dmy';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SET datestyle = 'mdy';
SELECT 'January 8, 1999'::date;
SELECT '1999-01-08'::date;
SELECT '1999-01-18'::date;
SELECT '1/8/1999'::date;
SELECT '1/18/1999'::date;
SELECT '18/1/1999'::date;
SELECT '01/02/03'::date;
SELECT '19990108'::date;
SELECT '990108'::date;
SELECT '1999.008'::date;
SELECT 'J2451187'::date;
SELECT 'January 8, 99 BC'::date;
SELECT '99-Jan-08'::date;
SELECT '1999-Jan-08'::date;
SELECT '08-Jan-99'::date;
SELECT '08-Jan-1999'::date;
SELECT 'Jan-08-99'::date;
SELECT 'Jan-08-1999'::date;
SELECT '99-08-Jan'::date;
SELECT '1999-08-Jan'::date;
SELECT '99 Jan 08'::date;
SELECT '1999 Jan 08'::date;
SELECT '08 Jan 99'::date;
SELECT '08 Jan 1999'::date;
SELECT 'Jan 08 99'::date;
SELECT 'Jan 08 1999'::date;
SELECT '99 08 Jan'::date;
SELECT '1999 08 Jan'::date;
SELECT '99-01-08'::date;
SELECT '1999-01-08'::date;
SELECT '08-01-99'::date;
SELECT '08-01-1999'::date;
SELECT '01-08-99'::date;
SELECT '01-08-1999'::date;
SELECT '99-08-01'::date;
SELECT '1999-08-01'::date;
SELECT '99 01 08'::date;
SELECT '1999 01 08'::date;
SELECT '08 01 99'::date;
SELECT '08 01 1999'::date;
SELECT '01 08 99'::date;
SELECT '01 08 1999'::date;
SELECT '99 08 01'::date;
SELECT '1999 08 01'::date;
SELECT '4714-11-24 BC'::date;
SELECT '4714-11-23 BC'::date;
SELECT '5874897-12-31'::date;
SELECT '5874898-01-01'::date;
RESET datestyle;
SELECT f1 - '2000-01-01'::date AS \\"Days From 2K\\" FROM date_tbl;
SELECT f1 - 'epoch'::date AS \\"Days From Epoch\\" FROM date_tbl;
SELECT 'yesterday'::date - 'today'::date AS \\"One day\\";
SELECT 'today'::date - 'tomorrow'::date AS \\"One day\\";
SELECT 'yesterday'::date - 'tomorrow'::date AS \\"Two days\\";
SELECT 'tomorrow'::date - 'today'::date AS \\"One day\\";
SELECT 'today'::date - 'yesterday'::date AS \\"One day\\";
SELECT 'tomorrow'::date - 'yesterday'::date AS \\"Two days\\";
SELECT pg_catalog.date_part('epoch', '1970-01-01'::date);
SELECT pg_catalog.date_part('epoch', '1970-01-01'::timestamp);
SELECT pg_catalog.date_part('epoch', '1970-01-01+00'::timestamptz);
SELECT pg_catalog.date_part('century', '0101-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0100-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0001-12-31 BC'::date);
SELECT pg_catalog.date_part('century', '0001-01-01'::date);
SELECT pg_catalog.date_part('century', '0001-01-01 AD'::date);
SELECT pg_catalog.date_part('century', '1900-12-31'::date);
SELECT pg_catalog.date_part('century', '1901-01-01'::date);
SELECT pg_catalog.date_part('century', '2000-12-31'::date);
SELECT pg_catalog.date_part('century', '2001-01-01'::date);
SELECT pg_catalog.date_part('century', CURRENT_DATE) >= 21 AS \\"true\\";
SELECT pg_catalog.date_part('millennium', '0001-12-31 BC'::date);
SELECT pg_catalog.date_part('millennium', '0001-01-01 AD'::date);
SELECT pg_catalog.date_part('millennium', '1000-12-31'::date);
SELECT pg_catalog.date_part('millennium', '1001-01-01'::date);
SELECT pg_catalog.date_part('millennium', '2000-12-31'::date);
SELECT pg_catalog.date_part('millennium', '2001-01-01'::date);
SELECT pg_catalog.date_part('millennium', CURRENT_DATE);
SELECT pg_catalog.date_part('decade', '1994-12-25'::date);
SELECT pg_catalog.date_part('decade', '0010-01-01'::date);
SELECT pg_catalog.date_part('decade', '0009-12-31'::date);
SELECT pg_catalog.date_part('decade', '0001-01-01 BC'::date);
SELECT pg_catalog.date_part('decade', '0002-12-31 BC'::date);
SELECT pg_catalog.date_part('decade', '0011-01-01 BC'::date);
SELECT pg_catalog.date_part('decade', '0012-12-31 BC'::date);
SELECT pg_catalog.date_part('century', now()) >= 21 AS \\"true\\";
SELECT pg_catalog.date_part('century', '1970-03-20 04:30:00.00000'::timestamp);
SELECT pg_catalog.date_part('century', '100 y'::interval);
SELECT pg_catalog.date_part('century', '99 y'::interval);
SELECT pg_catalog.date_part('century', '-99 y'::interval);
SELECT pg_catalog.date_part('century', '-100 y'::interval);
SELECT date_trunc('MILLENNIUM', '1970-03-20 04:30:00.00000'::timestamp);
SELECT date_trunc('MILLENNIUM', '1970-03-20'::date);
SELECT date_trunc('CENTURY', '1970-03-20 04:30:00.00000'::timestamp);
SELECT date_trunc('CENTURY', '1970-03-20'::date);
SELECT date_trunc('CENTURY', '2004-08-10'::date);
SELECT date_trunc('CENTURY', '0002-02-04'::date);
SELECT date_trunc('CENTURY', '0055-08-10 BC'::date);
SELECT date_trunc('DECADE', '1993-12-25'::date);
SELECT date_trunc('DECADE', '0004-12-25'::date);
SELECT date_trunc('DECADE', '0002-12-31 BC'::date);
SELECT 'infinity'::date,
'-infinity'::date;
SELECT 'infinity'::date > 'today'::date AS t;
SELECT '-infinity'::date < 'today'::date AS t;
SELECT isfinite('infinity'::date),
isfinite('-infinity'::date),
isfinite('today'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::date);
SELECT pg_catalog.date_part('hour', '-infinity'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::timestamp);
SELECT pg_catalog.date_part('hour', '-infinity'::timestamp);
SELECT pg_catalog.date_part('hour', 'infinity'::timestamptz);
SELECT pg_catalog.date_part('hour', '-infinity'::timestamptz);
SELECT pg_catalog.date_part('microseconds', 'infinity'::date);
SELECT pg_catalog.date_part('milliseconds', 'infinity'::date);
SELECT pg_catalog.date_part('second', 'infinity'::date);
SELECT pg_catalog.date_part('minute', 'infinity'::date);
SELECT pg_catalog.date_part('hour', 'infinity'::date);
SELECT pg_catalog.date_part('day', 'infinity'::date);
SELECT pg_catalog.date_part('month', 'infinity'::date);
SELECT pg_catalog.date_part('quarter', 'infinity'::date);
SELECT pg_catalog.date_part('week', 'infinity'::date);
SELECT pg_catalog.date_part('dow', 'infinity'::date);
SELECT pg_catalog.date_part('isodow', 'infinity'::date);
SELECT pg_catalog.date_part('doy', 'infinity'::date);
SELECT pg_catalog.date_part('timezone', 'infinity'::date);
SELECT pg_catalog.date_part('timezone_m', 'infinity'::date);
SELECT pg_catalog.date_part('timezone_h', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', '-infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::timestamp);
SELECT pg_catalog.date_part('epoch', '-infinity'::timestamp);
SELECT pg_catalog.date_part('epoch', 'infinity'::timestamptz);
SELECT pg_catalog.date_part('epoch', '-infinity'::timestamptz);
SELECT pg_catalog.date_part('year', 'infinity'::date);
SELECT pg_catalog.date_part('decade', 'infinity'::date);
SELECT pg_catalog.date_part('century', 'infinity'::date);
SELECT pg_catalog.date_part('millennium', 'infinity'::date);
SELECT pg_catalog.date_part('julian', 'infinity'::date);
SELECT pg_catalog.date_part('isoyear', 'infinity'::date);
SELECT pg_catalog.date_part('epoch', 'infinity'::date);
SELECT pg_catalog.date_part('microsec', 'infinity'::date);
SELECT pg_catalog.date_part('undefined', 'infinity'::date);
SELECT make_date(2013, 7, 15);
SELECT make_time(8, 20, 0.0);
SELECT make_date(2013, 2, 30);
SELECT make_date(2013, 13, 1);
SELECT make_date(2013, 11, (-1));
SELECT make_date((-44), 3, 15);
SELECT make_time(10, 55, 100.1);
SELECT make_time(24, 0, 2.1);"
`;

exports[`kitchen sink upstream upstream/dbsize.sql 1`] = `
"SELECT size,
pg_size_pretty(size),
pg_size_pretty((-1) * size) FROM (VALUES (10::bigint), (1000::bigint), (1000000::bigint), (1000000000::bigint), (1000000000000::bigint), (1000000000000000::bigint)) AS x (size);
SELECT size,
pg_size_pretty(size),
pg_size_pretty((-1) * size) FROM (VALUES (10::numeric), (1000::numeric), (1000000::numeric), (1000000000::numeric), (1000000000000::numeric), (1000000000000000::numeric), (10.5::numeric), (1000.5::numeric), (1000000.5::numeric), (1000000000.5::numeric), (1000000000000.5::numeric), (1000000000000000.5::numeric)) AS x (size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('1'), ('123bytes'), ('1kB'), ('1MB'), (' 1 GB'), ('1.5 GB '), ('1TB'), ('3000 TB'), ('1e6 MB')) AS x (size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('1'), ('123bYteS'), ('1kb'), ('1mb'), (' 1 Gb'), ('1.5 gB '), ('1tb'), ('3000 tb'), ('1e6 mb')) AS x (size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('-1'), ('-123bytes'), ('-1kb'), ('-1mb'), (' -1 Gb'), ('-1.5 gB '), ('-1tb'), ('-3000 TB'), ('-10e-1 MB')) AS x (size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('-1.'), ('-1.kb'), ('-1. kb'), ('-0. gb'), ('-.1'), ('-.1kb'), ('-.1 kb'), ('-.0 gb')) AS x (size);
SELECT pg_size_bytes('1 AB');
SELECT pg_size_bytes('1 AB A');
SELECT pg_size_bytes('1 AB A    ');
SELECT pg_size_bytes('9223372036854775807.9');
SELECT pg_size_bytes('1e100');
SELECT pg_size_bytes('1e1000000000000000000');
SELECT pg_size_bytes('1 byte');
SELECT pg_size_bytes('');
SELECT pg_size_bytes('kb');
SELECT pg_size_bytes('..');
SELECT pg_size_bytes('-.');
SELECT pg_size_bytes('-.kb');
SELECT pg_size_bytes('-. kb');
SELECT pg_size_bytes('.+912');
SELECT pg_size_bytes('+912+ kB');
SELECT pg_size_bytes('++123 kB');"
`;

exports[`kitchen sink upstream upstream/dbsize.sql 2`] = `
"SELECT size,
pg_size_pretty(size),
pg_size_pretty((-1) * size) FROM (VALUES (10::bigint), (1000::bigint), (1000000::bigint), (1000000000::bigint), (1000000000000::bigint), (1000000000000000::bigint)) AS x(size);
SELECT size,
pg_size_pretty(size),
pg_size_pretty((-1) * size) FROM (VALUES (10::numeric), (1000::numeric), (1000000::numeric), (1000000000::numeric), (1000000000000::numeric), (1000000000000000::numeric), (10.5::numeric), (1000.5::numeric), (1000000.5::numeric), (1000000000.5::numeric), (1000000000000.5::numeric), (1000000000000000.5::numeric)) AS x(size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('1'), ('123bytes'), ('1kB'), ('1MB'), (' 1 GB'), ('1.5 GB '), ('1TB'), ('3000 TB'), ('1e6 MB')) AS x(size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('1'), ('123bYteS'), ('1kb'), ('1mb'), (' 1 Gb'), ('1.5 gB '), ('1tb'), ('3000 tb'), ('1e6 mb')) AS x(size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('-1'), ('-123bytes'), ('-1kb'), ('-1mb'), (' -1 Gb'), ('-1.5 gB '), ('-1tb'), ('-3000 TB'), ('-10e-1 MB')) AS x(size);
SELECT size,
pg_size_bytes(size) FROM (VALUES ('-1.'), ('-1.kb'), ('-1. kb'), ('-0. gb'), ('-.1'), ('-.1kb'), ('-.1 kb'), ('-.0 gb')) AS x(size);
SELECT pg_size_bytes('1 AB');
SELECT pg_size_bytes('1 AB A');
SELECT pg_size_bytes('1 AB A    ');
SELECT pg_size_bytes('9223372036854775807.9');
SELECT pg_size_bytes('1e100');
SELECT pg_size_bytes('1e1000000000000000000');
SELECT pg_size_bytes('1 byte');
SELECT pg_size_bytes('');
SELECT pg_size_bytes('kb');
SELECT pg_size_bytes('..');
SELECT pg_size_bytes('-.');
SELECT pg_size_bytes('-.kb');
SELECT pg_size_bytes('-. kb');
SELECT pg_size_bytes('.+912');
SELECT pg_size_bytes('+912+ kB');
SELECT pg_size_bytes('++123 kB');"
`;

exports[`kitchen sink upstream upstream/delete.sql 1`] = `
"CREATE TABLE delete_test (
id serial PRIMARY KEY,
a int,
b text
);
INSERT INTO delete_test (a) VALUES (10);
INSERT INTO delete_test (a, b) VALUES (50, repeat('x', 10000));
INSERT INTO delete_test (a) VALUES (100);
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test AS dt WHERE delete_test.a > 25;
SELECT id,
a,
char_length(b) FROM delete_test;
DELETE FROM delete_test WHERE a > 25;
SELECT id,
a,
char_length(b) FROM delete_test;
DROP TABLE delete_test;"
`;

exports[`kitchen sink upstream upstream/delete.sql 2`] = `
"CREATE TABLE delete_test (
id serial PRIMARY KEY,
a int,
b text
);
INSERT INTO delete_test ( a ) VALUES (10);
INSERT INTO delete_test ( a, b ) VALUES (50, repeat('x', 10000));
INSERT INTO delete_test ( a ) VALUES (100);
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test AS dt WHERE delete_test.a > 25;
SELECT id,
a,
char_length(b) FROM delete_test;
DELETE FROM delete_test WHERE a > 25;
SELECT id,
a,
char_length(b) FROM delete_test;
DROP TABLE delete_test;"
`;

exports[`kitchen sink upstream upstream/float4.sql 1`] = `
"CREATE TABLE float4_tbl (
f1 float4
);
INSERT INTO float4_tbl (f1) VALUES ('    0.0');
INSERT INTO float4_tbl (f1) VALUES ('1004.30   ');
INSERT INTO float4_tbl (f1) VALUES ('     -34.84    ');
INSERT INTO float4_tbl (f1) VALUES ('1.2345678901234e+20');
INSERT INTO float4_tbl (f1) VALUES ('1.2345678901234e-20');
INSERT INTO float4_tbl (f1) VALUES ('10e70');
INSERT INTO float4_tbl (f1) VALUES ('-10e70');
INSERT INTO float4_tbl (f1) VALUES ('10e-70');
INSERT INTO float4_tbl (f1) VALUES ('-10e-70');
INSERT INTO float4_tbl (f1) VALUES ('');
INSERT INTO float4_tbl (f1) VALUES ('       ');
INSERT INTO float4_tbl (f1) VALUES ('xyz');
INSERT INTO float4_tbl (f1) VALUES ('5.0.0');
INSERT INTO float4_tbl (f1) VALUES ('5 . 0');
INSERT INTO float4_tbl (f1) VALUES ('5.   0');
INSERT INTO float4_tbl (f1) VALUES ('     - 3.0');
INSERT INTO float4_tbl (f1) VALUES ('123            5');
SELECT 'NaN'::float4;
SELECT 'nan'::float4;
SELECT '   NAN  '::float4;
SELECT 'infinity'::float4;
SELECT '          -INFINiTY   '::float4;
SELECT 'N A N'::float4;
SELECT 'NaN x'::float4;
SELECT ' INFINITY    x'::float4;
SELECT 'Infinity'::float4 + 100.0;
SELECT 'Infinity'::float4 / 'Infinity'::float4;
SELECT 'nan'::float4 / 'nan'::float4;
SELECT 'nan'::numeric::float4;
SELECT '' AS five,
* FROM float4_tbl;
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE f.f1 <> '1004.3';
SELECT '' AS one,
f.* FROM float4_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS three,
f.* FROM float4_tbl AS f WHERE '1004.3' > f.f1;
SELECT '' AS three,
f.* FROM float4_tbl AS f WHERE f.f1 < '1004.3';
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE '1004.3' >= f.f1;
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE f.f1 <= '1004.3';
SELECT '' AS three,
f.f1,
f.f1 * '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 + '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 / '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 - '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS bad,
f.f1 / '0.0' FROM float4_tbl AS f;
SELECT '' AS five,
* FROM float4_tbl;
SELECT '' AS five,
f.f1,
@f.f1 AS abs_f1 FROM float4_tbl AS f;
UPDATE float4_tbl SET f1 = float4_tbl.f1 * '-1' WHERE float4_tbl.f1 > '0.0';
SELECT '' AS five,
* FROM float4_tbl;"
`;

exports[`kitchen sink upstream upstream/float4.sql 2`] = `
"CREATE TABLE float4_tbl (
f1 float4
);
INSERT INTO float4_tbl ( f1 ) VALUES ('    0.0');
INSERT INTO float4_tbl ( f1 ) VALUES ('1004.30   ');
INSERT INTO float4_tbl ( f1 ) VALUES ('     -34.84    ');
INSERT INTO float4_tbl ( f1 ) VALUES ('1.2345678901234e+20');
INSERT INTO float4_tbl ( f1 ) VALUES ('1.2345678901234e-20');
INSERT INTO float4_tbl ( f1 ) VALUES ('10e70');
INSERT INTO float4_tbl ( f1 ) VALUES ('-10e70');
INSERT INTO float4_tbl ( f1 ) VALUES ('10e-70');
INSERT INTO float4_tbl ( f1 ) VALUES ('-10e-70');
INSERT INTO float4_tbl ( f1 ) VALUES ('');
INSERT INTO float4_tbl ( f1 ) VALUES ('       ');
INSERT INTO float4_tbl ( f1 ) VALUES ('xyz');
INSERT INTO float4_tbl ( f1 ) VALUES ('5.0.0');
INSERT INTO float4_tbl ( f1 ) VALUES ('5 . 0');
INSERT INTO float4_tbl ( f1 ) VALUES ('5.   0');
INSERT INTO float4_tbl ( f1 ) VALUES ('     - 3.0');
INSERT INTO float4_tbl ( f1 ) VALUES ('123            5');
SELECT 'NaN'::float4;
SELECT 'nan'::float4;
SELECT '   NAN  '::float4;
SELECT 'infinity'::float4;
SELECT '          -INFINiTY   '::float4;
SELECT 'N A N'::float4;
SELECT 'NaN x'::float4;
SELECT ' INFINITY    x'::float4;
SELECT 'Infinity'::float4 + 100.0;
SELECT 'Infinity'::float4 / 'Infinity'::float4;
SELECT 'nan'::float4 / 'nan'::float4;
SELECT 'nan'::numeric::float4;
SELECT '' AS five,
* FROM float4_tbl;
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE f.f1 <> '1004.3';
SELECT '' AS one,
f.* FROM float4_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS three,
f.* FROM float4_tbl AS f WHERE '1004.3' > f.f1;
SELECT '' AS three,
f.* FROM float4_tbl AS f WHERE f.f1 < '1004.3';
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE '1004.3' >= f.f1;
SELECT '' AS four,
f.* FROM float4_tbl AS f WHERE f.f1 <= '1004.3';
SELECT '' AS three,
f.f1,
f.f1 * '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 + '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 / '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 - '-10' AS x FROM float4_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS bad,
f.f1 / '0.0' FROM float4_tbl AS f;
SELECT '' AS five,
* FROM float4_tbl;
SELECT '' AS five,
f.f1,
@f.f1 AS abs_f1 FROM float4_tbl AS f;
UPDATE float4_tbl SET f1 = float4_tbl.f1 * '-1' WHERE float4_tbl.f1 > '0.0';
SELECT '' AS five,
* FROM float4_tbl;"
`;

exports[`kitchen sink upstream upstream/float8.sql 1`] = `
"CREATE TABLE float8_tbl (
f1 float8
);
INSERT INTO float8_tbl (f1) VALUES ('    0.0   ');
INSERT INTO float8_tbl (f1) VALUES ('1004.30  ');
INSERT INTO float8_tbl (f1) VALUES ('   -34.84');
INSERT INTO float8_tbl (f1) VALUES ('1.2345678901234e+200');
INSERT INTO float8_tbl (f1) VALUES ('1.2345678901234e-200');
SELECT '10e400'::float8;
SELECT '-10e400'::float8;
SELECT '10e-400'::float8;
SELECT '-10e-400'::float8;
INSERT INTO float8_tbl (f1) VALUES ('');
INSERT INTO float8_tbl (f1) VALUES ('     ');
INSERT INTO float8_tbl (f1) VALUES ('xyz');
INSERT INTO float8_tbl (f1) VALUES ('5.0.0');
INSERT INTO float8_tbl (f1) VALUES ('5 . 0');
INSERT INTO float8_tbl (f1) VALUES ('5.   0');
INSERT INTO float8_tbl (f1) VALUES ('    - 3');
INSERT INTO float8_tbl (f1) VALUES ('123           5');
SELECT 'NaN'::float8;
SELECT 'nan'::float8;
SELECT '   NAN  '::float8;
SELECT 'infinity'::float8;
SELECT '          -INFINiTY   '::float8;
SELECT 'N A N'::float8;
SELECT 'NaN x'::float8;
SELECT ' INFINITY    x'::float8;
SELECT 'Infinity'::float8 + 100.0;
SELECT 'Infinity'::float8 / 'Infinity'::float8;
SELECT 'nan'::float8 / 'nan'::float8;
SELECT 'nan'::numeric::float8;
SELECT '' AS five,
* FROM float8_tbl;
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE f.f1 <> '1004.3';
SELECT '' AS one,
f.* FROM float8_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS three,
f.* FROM float8_tbl AS f WHERE '1004.3' > f.f1;
SELECT '' AS three,
f.* FROM float8_tbl AS f WHERE f.f1 < '1004.3';
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE '1004.3' >= f.f1;
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE f.f1 <= '1004.3';
SELECT '' AS three,
f.f1,
f.f1 * '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 + '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 / '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 - '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS one,
f.f1 ^ '2.0' AS square_f1 FROM float8_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS five,
f.f1,
@f.f1 AS abs_f1 FROM float8_tbl AS f;
SELECT '' AS five,
f.f1,
trunc(f.f1) AS trunc_f1 FROM float8_tbl AS f;
SELECT '' AS five,
f.f1,
round(f.f1) AS round_f1 FROM float8_tbl AS f;
SELECT ceil(f1) AS ceil_f1 FROM float8_tbl AS f;
SELECT ceiling(f1) AS ceiling_f1 FROM float8_tbl AS f;
SELECT floor(f1) AS floor_f1 FROM float8_tbl AS f;
SELECT sign(f1) AS sign_f1 FROM float8_tbl AS f;
SELECT sqrt('64'::float8) AS eight;
SELECT |/'64'::float8 AS eight;
SELECT '' AS three,
f.f1,
|/f.f1 AS sqrt_f1 FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT power('144'::float8, '0.5'::float8);
SELECT '' AS three,
f.f1,
exp(ln(f.f1)) AS exp_ln_f1 FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT ||/'27'::float8 AS three;
SELECT '' AS five,
f.f1,
||/f.f1 AS cbrt_f1 FROM float8_tbl AS f;
SELECT '' AS five,
* FROM float8_tbl;
UPDATE float8_tbl SET f1 = float8_tbl.f1 * '-1' WHERE float8_tbl.f1 > '0.0';
SELECT '' AS bad,
f.f1 * '1e200' FROM float8_tbl AS f;
SELECT '' AS bad,
f.f1 ^ '1e200' FROM float8_tbl AS f;
SELECT (((0 ^ 0) + (0 ^ 1)) + (0 ^ 0.0)) + (0 ^ 0.5);
SELECT '' AS bad,
ln(f.f1) FROM float8_tbl AS f WHERE f.f1 = '0.0';
SELECT '' AS bad,
ln(f.f1) FROM float8_tbl AS f WHERE f.f1 < '0.0';
SELECT '' AS bad,
exp(f.f1) FROM float8_tbl AS f;
SELECT '' AS bad,
f.f1 / '0.0' FROM float8_tbl AS f;
SELECT '' AS five,
* FROM float8_tbl;
INSERT INTO float8_tbl (f1) VALUES ('10e400');
INSERT INTO float8_tbl (f1) VALUES ('-10e400');
INSERT INTO float8_tbl (f1) VALUES ('10e-400');
INSERT INTO float8_tbl (f1) VALUES ('-10e-400');
DELETE FROM float8_tbl;
INSERT INTO float8_tbl (f1) VALUES ('0.0');
INSERT INTO float8_tbl (f1) VALUES ('-34.84');
INSERT INTO float8_tbl (f1) VALUES ('-1004.30');
INSERT INTO float8_tbl (f1) VALUES ('-1.2345678901234e+200');
INSERT INTO float8_tbl (f1) VALUES ('-1.2345678901234e-200');
SELECT '' AS five,
* FROM float8_tbl;
SET extra_float_digits = 3;
SELECT x,
sind(x),
sind(x) IN ( (-1), (-0.5), 0, 0.5, 1 ) AS sind_exact FROM (VALUES (0), (30), (90), (150), (180), (210), (270), (330), (360)) AS t (x);
SELECT x,
cosd(x),
cosd(x) IN ( (-1), (-0.5), 0, 0.5, 1 ) AS cosd_exact FROM (VALUES (0), (60), (90), (120), (180), (240), (270), (300), (360)) AS t (x);
SELECT x,
tand(x),
tand(x) IN ( '-Infinity'::float8, (-1), 0, 1, 'Infinity'::float8 ) AS tand_exact,
cotd(x),
cotd(x) IN ( '-Infinity'::float8, (-1), 0, 1, 'Infinity'::float8 ) AS cotd_exact FROM (VALUES (0), (45), (90), (135), (180), (225), (270), (315), (360)) AS t (x);
SELECT x,
asind(x),
asind(x) IN ( (-90), (-30), 0, 30, 90 ) AS asind_exact,
acosd(x),
acosd(x) IN ( 0, 60, 90, 120, 180 ) AS acosd_exact FROM (VALUES ((-1)), ((-0.5)), (0), (0.5), (1)) AS t (x);
SELECT x,
atand(x),
atand(x) IN ( (-90), (-45), 0, 45, 90 ) AS atand_exact FROM (VALUES ('-Infinity'::float8), ((-1)), (0), (1), ('Infinity'::float8)) AS t (x);
SELECT x,
y,
atan2d(y, x),
atan2d(y, x) IN ( (-90), 0, 90, 180 ) AS atan2d_exact FROM (SELECT 10 * cosd(a),
10 * sind(a) FROM generate_series(0, 360, 90) AS t (a)) AS t (x, y);
RESET extra_float_digits;"
`;

exports[`kitchen sink upstream upstream/float8.sql 2`] = `
"CREATE TABLE float8_tbl (
f1 float8
);
INSERT INTO float8_tbl ( f1 ) VALUES ('    0.0   ');
INSERT INTO float8_tbl ( f1 ) VALUES ('1004.30  ');
INSERT INTO float8_tbl ( f1 ) VALUES ('   -34.84');
INSERT INTO float8_tbl ( f1 ) VALUES ('1.2345678901234e+200');
INSERT INTO float8_tbl ( f1 ) VALUES ('1.2345678901234e-200');
SELECT '10e400'::float8;
SELECT '-10e400'::float8;
SELECT '10e-400'::float8;
SELECT '-10e-400'::float8;
INSERT INTO float8_tbl ( f1 ) VALUES ('');
INSERT INTO float8_tbl ( f1 ) VALUES ('     ');
INSERT INTO float8_tbl ( f1 ) VALUES ('xyz');
INSERT INTO float8_tbl ( f1 ) VALUES ('5.0.0');
INSERT INTO float8_tbl ( f1 ) VALUES ('5 . 0');
INSERT INTO float8_tbl ( f1 ) VALUES ('5.   0');
INSERT INTO float8_tbl ( f1 ) VALUES ('    - 3');
INSERT INTO float8_tbl ( f1 ) VALUES ('123           5');
SELECT 'NaN'::float8;
SELECT 'nan'::float8;
SELECT '   NAN  '::float8;
SELECT 'infinity'::float8;
SELECT '          -INFINiTY   '::float8;
SELECT 'N A N'::float8;
SELECT 'NaN x'::float8;
SELECT ' INFINITY    x'::float8;
SELECT 'Infinity'::float8 + 100.0;
SELECT 'Infinity'::float8 / 'Infinity'::float8;
SELECT 'nan'::float8 / 'nan'::float8;
SELECT 'nan'::numeric::float8;
SELECT '' AS five,
* FROM float8_tbl;
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE f.f1 <> '1004.3';
SELECT '' AS one,
f.* FROM float8_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS three,
f.* FROM float8_tbl AS f WHERE '1004.3' > f.f1;
SELECT '' AS three,
f.* FROM float8_tbl AS f WHERE f.f1 < '1004.3';
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE '1004.3' >= f.f1;
SELECT '' AS four,
f.* FROM float8_tbl AS f WHERE f.f1 <= '1004.3';
SELECT '' AS three,
f.f1,
f.f1 * '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 + '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 / '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS three,
f.f1,
f.f1 - '-10' AS x FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT '' AS one,
f.f1 ^ '2.0' AS square_f1 FROM float8_tbl AS f WHERE f.f1 = '1004.3';
SELECT '' AS five,
f.f1,
@f.f1 AS abs_f1 FROM float8_tbl AS f;
SELECT '' AS five,
f.f1,
trunc(f.f1) AS trunc_f1 FROM float8_tbl AS f;
SELECT '' AS five,
f.f1,
round(f.f1) AS round_f1 FROM float8_tbl AS f;
SELECT ceil(f1) AS ceil_f1 FROM float8_tbl AS f;
SELECT ceiling(f1) AS ceiling_f1 FROM float8_tbl AS f;
SELECT floor(f1) AS floor_f1 FROM float8_tbl AS f;
SELECT sign(f1) AS sign_f1 FROM float8_tbl AS f;
SELECT sqrt('64'::float8) AS eight;
SELECT |/'64'::float8 AS eight;
SELECT '' AS three,
f.f1,
|/f.f1 AS sqrt_f1 FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT power('144'::float8, '0.5'::float8);
SELECT '' AS three,
f.f1,
exp(ln(f.f1)) AS exp_ln_f1 FROM float8_tbl AS f WHERE f.f1 > '0.0';
SELECT ||/'27'::float8 AS three;
SELECT '' AS five,
f.f1,
||/f.f1 AS cbrt_f1 FROM float8_tbl AS f;
SELECT '' AS five,
* FROM float8_tbl;
UPDATE float8_tbl SET f1 = float8_tbl.f1 * '-1' WHERE float8_tbl.f1 > '0.0';
SELECT '' AS bad,
f.f1 * '1e200' FROM float8_tbl AS f;
SELECT '' AS bad,
f.f1 ^ '1e200' FROM float8_tbl AS f;
SELECT (((0 ^ 0) + (0 ^ 1)) + (0 ^ 0.0)) + (0 ^ 0.5);
SELECT '' AS bad,
ln(f.f1) FROM float8_tbl AS f WHERE f.f1 = '0.0';
SELECT '' AS bad,
ln(f.f1) FROM float8_tbl AS f WHERE f.f1 < '0.0';
SELECT '' AS bad,
exp(f.f1) FROM float8_tbl AS f;
SELECT '' AS bad,
f.f1 / '0.0' FROM float8_tbl AS f;
SELECT '' AS five,
* FROM float8_tbl;
INSERT INTO float8_tbl ( f1 ) VALUES ('10e400');
INSERT INTO float8_tbl ( f1 ) VALUES ('-10e400');
INSERT INTO float8_tbl ( f1 ) VALUES ('10e-400');
INSERT INTO float8_tbl ( f1 ) VALUES ('-10e-400');
DELETE FROM float8_tbl;
INSERT INTO float8_tbl ( f1 ) VALUES ('0.0');
INSERT INTO float8_tbl ( f1 ) VALUES ('-34.84');
INSERT INTO float8_tbl ( f1 ) VALUES ('-1004.30');
INSERT INTO float8_tbl ( f1 ) VALUES ('-1.2345678901234e+200');
INSERT INTO float8_tbl ( f1 ) VALUES ('-1.2345678901234e-200');
SELECT '' AS five,
* FROM float8_tbl;
SET extra_float_digits = 3;
SELECT x,
sind(x),
sind(x) IN ((-1), (-0.5), 0, 0.5, 1) AS sind_exact FROM (VALUES (0), (30), (90), (150), (180), (210), (270), (330), (360)) AS t(x);
SELECT x,
cosd(x),
cosd(x) IN ((-1), (-0.5), 0, 0.5, 1) AS cosd_exact FROM (VALUES (0), (60), (90), (120), (180), (240), (270), (300), (360)) AS t(x);
SELECT x,
tand(x),
tand(x) IN ('-Infinity'::float8, (-1), 0, 1, 'Infinity'::float8) AS tand_exact,
cotd(x),
cotd(x) IN ('-Infinity'::float8, (-1), 0, 1, 'Infinity'::float8) AS cotd_exact FROM (VALUES (0), (45), (90), (135), (180), (225), (270), (315), (360)) AS t(x);
SELECT x,
asind(x),
asind(x) IN ((-90), (-30), 0, 30, 90) AS asind_exact,
acosd(x),
acosd(x) IN (0, 60, 90, 120, 180) AS acosd_exact FROM (VALUES ((-1)), ((-0.5)), (0), (0.5), (1)) AS t(x);
SELECT x,
atand(x),
atand(x) IN ((-90), (-45), 0, 45, 90) AS atand_exact FROM (VALUES ('-Infinity'::float8), ((-1)), (0), (1), ('Infinity'::float8)) AS t(x);
SELECT x,
y,
atan2d(y, x),
atan2d(y, x) IN ((-90), 0, 90, 180) AS atan2d_exact FROM (SELECT 10 * cosd(a),
10 * sind(a) FROM generate_series(0, 360, 90) AS t(a)) AS t(x, y);
RESET extra_float_digits;"
`;

exports[`kitchen sink upstream upstream/geometry.sql 1`] = `
"SET extra_float_digits = -3;
SELECT '' AS four,
center(f1) AS center FROM box_tbl;
SELECT '' AS four,
@@f1 AS center FROM box_tbl;
SELECT '' AS six,
point(f1) AS center FROM circle_tbl;
SELECT '' AS six,
@@f1 AS center FROM circle_tbl;
SELECT '' AS two,
@@f1 AS center FROM polygon_tbl WHERE (#f1) > 2;
SELECT '' AS two,
p1.f1 FROM point_tbl AS p1 WHERE ishorizontal(p1.f1, '(0,0)'::point);
SELECT '' AS two,
p1.f1 FROM point_tbl AS p1 WHERE p1.f1 ?- '(0,0)'::point;
SELECT '' AS one,
p1.f1 FROM point_tbl AS p1 WHERE isvertical(p1.f1, '(5.1,34.5)'::point);
SELECT '' AS one,
p1.f1 FROM point_tbl AS p1 WHERE p1.f1 ?| '(5.1,34.5)'::point;
SELECT '' AS count,
p.f1,
l.s,
l.s # p.f1 AS intersection FROM lseg_tbl AS l,
point_tbl AS p;
SELECT '' AS thirty,
p.f1,
l.s,
p.f1 ## l.s AS closest FROM lseg_tbl AS l,
point_tbl AS p;
SELECT '' AS six,
box(f1) AS box FROM circle_tbl;
SELECT '' AS twentyfour,
b.f1 + p.f1 AS translation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twentyfour,
b.f1 - p.f1 AS translation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twentyfour,
b.f1 * p.f1 AS rotation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twenty,
b.f1 / p.f1 AS rotation FROM box_tbl AS b,
point_tbl AS p WHERE (p.f1 <-> '(0,0)'::point) >= 1;
SELECT f1::box FROM point_tbl;
SELECT bound_box(a.f1, b.f1) FROM box_tbl AS a,
box_tbl AS b;
SELECT '' AS eight,
npoints(f1) AS npoints,
f1 AS path FROM path_tbl;
SELECT '' AS four,
path(f1) FROM polygon_tbl;
SELECT '' AS eight,
p1.f1 + '(10,10)'::point AS dist_add FROM path_tbl AS p1;
SELECT '' AS eight,
p1.f1 * '(2,-1)'::point AS dist_mul FROM path_tbl AS p1;
SELECT '' AS twentyfour,
p.f1,
poly.f1,
poly.f1 @> p.f1 AS contains FROM polygon_tbl AS poly,
point_tbl AS p;
SELECT '' AS twentyfour,
p.f1,
poly.f1,
p.f1 <@ poly.f1 AS contained FROM polygon_tbl AS poly,
point_tbl AS p;
SELECT '' AS four,
npoints(f1) AS npoints,
f1 AS polygon FROM polygon_tbl;
SELECT '' AS four,
polygon(f1) FROM box_tbl;
SELECT '' AS four,
polygon(f1) FROM path_tbl WHERE isclosed(f1);
SELECT '' AS four,
f1 AS open_path,
polygon(pclose(f1)) AS polygon FROM path_tbl WHERE isopen(f1);
SELECT '' AS six,
polygon(f1) FROM circle_tbl;
SELECT '' AS six,
polygon(8, f1) FROM circle_tbl;
SELECT '' AS six,
circle(f1, 50.0) FROM point_tbl;
SELECT '' AS four,
circle(f1) FROM box_tbl;
SELECT '' AS two,
circle(f1) FROM polygon_tbl WHERE (#f1) >= 3;
SELECT '' AS twentyfour,
c1.f1 AS circle,
p1.f1 AS point,
p1.f1 <-> c1.f1 AS distance FROM circle_tbl AS c1,
point_tbl AS p1 WHERE (p1.f1 <-> c1.f1) > 0 ORDER BY distance,
area(c1.f1),
(p1.f1)[0];"
`;

exports[`kitchen sink upstream upstream/geometry.sql 2`] = `
"SET extra_float_digits = -3;
SELECT '' AS four,
center(f1) AS center FROM box_tbl;
SELECT '' AS four,
@@f1 AS center FROM box_tbl;
SELECT '' AS six,
point(f1) AS center FROM circle_tbl;
SELECT '' AS six,
@@f1 AS center FROM circle_tbl;
SELECT '' AS two,
@@f1 AS center FROM polygon_tbl WHERE (#f1) > 2;
SELECT '' AS two,
p1.f1 FROM point_tbl AS p1 WHERE ishorizontal(p1.f1, '(0,0)'::point);
SELECT '' AS two,
p1.f1 FROM point_tbl AS p1 WHERE p1.f1 ?- '(0,0)'::point;
SELECT '' AS one,
p1.f1 FROM point_tbl AS p1 WHERE isvertical(p1.f1, '(5.1,34.5)'::point);
SELECT '' AS one,
p1.f1 FROM point_tbl AS p1 WHERE p1.f1 ?| '(5.1,34.5)'::point;
SELECT '' AS count,
p.f1,
l.s,
l.s # p.f1 AS intersection FROM lseg_tbl AS l,
point_tbl AS p;
SELECT '' AS thirty,
p.f1,
l.s,
p.f1 ## l.s AS closest FROM lseg_tbl AS l,
point_tbl AS p;
SELECT '' AS six,
box(f1) AS box FROM circle_tbl;
SELECT '' AS twentyfour,
b.f1 + p.f1 AS translation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twentyfour,
b.f1 - p.f1 AS translation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twentyfour,
b.f1 * p.f1 AS rotation FROM box_tbl AS b,
point_tbl AS p;
SELECT '' AS twenty,
b.f1 / p.f1 AS rotation FROM box_tbl AS b,
point_tbl AS p WHERE (p.f1 <-> '(0,0)'::point) >= 1;
SELECT f1::box FROM point_tbl;
SELECT bound_box(a.f1, b.f1) FROM box_tbl AS a,
box_tbl AS b;
SELECT '' AS eight,
npoints(f1) AS npoints,
f1 AS path FROM path_tbl;
SELECT '' AS four,
path(f1) FROM polygon_tbl;
SELECT '' AS eight,
p1.f1 + '(10,10)'::point AS dist_add FROM path_tbl AS p1;
SELECT '' AS eight,
p1.f1 * '(2,-1)'::point AS dist_mul FROM path_tbl AS p1;
SELECT '' AS twentyfour,
p.f1,
poly.f1,
poly.f1 @> p.f1 AS contains FROM polygon_tbl AS poly,
point_tbl AS p;
SELECT '' AS twentyfour,
p.f1,
poly.f1,
p.f1 <@ poly.f1 AS contained FROM polygon_tbl AS poly,
point_tbl AS p;
SELECT '' AS four,
npoints(f1) AS npoints,
f1 AS polygon FROM polygon_tbl;
SELECT '' AS four,
polygon(f1) FROM box_tbl;
SELECT '' AS four,
polygon(f1) FROM path_tbl WHERE isclosed(f1);
SELECT '' AS four,
f1 AS open_path,
polygon(pclose(f1)) AS polygon FROM path_tbl WHERE isopen(f1);
SELECT '' AS six,
polygon(f1) FROM circle_tbl;
SELECT '' AS six,
polygon(8, f1) FROM circle_tbl;
SELECT '' AS six,
circle(f1, 50.0) FROM point_tbl;
SELECT '' AS four,
circle(f1) FROM box_tbl;
SELECT '' AS two,
circle(f1) FROM polygon_tbl WHERE (#f1) >= 3;
SELECT '' AS twentyfour,
c1.f1 AS circle,
p1.f1 AS point,
p1.f1 <-> c1.f1 AS distance FROM circle_tbl AS c1,
point_tbl AS p1 WHERE (p1.f1 <-> c1.f1) > 0 ORDER BY distance,
area(c1.f1),
(p1.f1)[0];"
`;

exports[`kitchen sink upstream upstream/hash_index.sql 1`] = `
"SELECT * FROM hash_i4_heap WHERE hash_i4_heap.random = 843938989;
SELECT * FROM hash_i4_heap WHERE hash_i4_heap.random = 66766766;
SELECT * FROM hash_name_heap WHERE hash_name_heap.random = '1505703298'::name;
SELECT * FROM hash_name_heap WHERE hash_name_heap.random = '7777777'::name;
SELECT * FROM hash_txt_heap WHERE hash_txt_heap.random = '1351610853'::text;
SELECT * FROM hash_txt_heap WHERE hash_txt_heap.random = '111111112222222233333333'::text;
SELECT * FROM hash_f8_heap WHERE hash_f8_heap.random = '444705537'::float8;
SELECT * FROM hash_f8_heap WHERE hash_f8_heap.random = '88888888'::float8;
UPDATE hash_i4_heap SET random = 1 WHERE hash_i4_heap.seqno = 1492;
SELECT h.seqno AS i1492,
h.random AS i1 FROM hash_i4_heap AS h WHERE h.random = 1;
UPDATE hash_i4_heap SET seqno = 20000 WHERE hash_i4_heap.random = 1492795354;
SELECT h.seqno AS i20000 FROM hash_i4_heap AS h WHERE h.random = 1492795354;
UPDATE hash_name_heap SET random = '0123456789abcdef'::name WHERE hash_name_heap.seqno = 6543;
SELECT h.seqno AS i6543,
h.random AS c0_to_f FROM hash_name_heap AS h WHERE h.random = '0123456789abcdef'::name;
UPDATE hash_name_heap SET seqno = 20000 WHERE hash_name_heap.random = '76652222'::name;
SELECT h.seqno AS emptyset FROM hash_name_heap AS h WHERE h.random = '76652222'::name;
UPDATE hash_txt_heap SET random = '0123456789abcdefghijklmnop'::text WHERE hash_txt_heap.seqno = 4002;
SELECT h.seqno AS i4002,
h.random AS c0_to_p FROM hash_txt_heap AS h WHERE h.random = '0123456789abcdefghijklmnop'::text;
UPDATE hash_txt_heap SET seqno = 20000 WHERE hash_txt_heap.random = '959363399'::text;
SELECT h.seqno AS t20000 FROM hash_txt_heap AS h WHERE h.random = '959363399'::text;
UPDATE hash_f8_heap SET random = '-1234.1234'::float8 WHERE hash_f8_heap.seqno = 8906;
SELECT h.seqno AS i8096,
h.random AS f1234_1234 FROM hash_f8_heap AS h WHERE h.random = '-1234.1234'::float8;
UPDATE hash_f8_heap SET seqno = 20000 WHERE hash_f8_heap.random = '488912369'::float8;
SELECT h.seqno AS f20000 FROM hash_f8_heap AS h WHERE h.random = '488912369'::float8;"
`;

exports[`kitchen sink upstream upstream/hash_index.sql 2`] = `
"SELECT * FROM hash_i4_heap WHERE hash_i4_heap.random = 843938989;
SELECT * FROM hash_i4_heap WHERE hash_i4_heap.random = 66766766;
SELECT * FROM hash_name_heap WHERE hash_name_heap.random = '1505703298'::name;
SELECT * FROM hash_name_heap WHERE hash_name_heap.random = '7777777'::name;
SELECT * FROM hash_txt_heap WHERE hash_txt_heap.random = '1351610853'::text;
SELECT * FROM hash_txt_heap WHERE hash_txt_heap.random = '111111112222222233333333'::text;
SELECT * FROM hash_f8_heap WHERE hash_f8_heap.random = '444705537'::float8;
SELECT * FROM hash_f8_heap WHERE hash_f8_heap.random = '88888888'::float8;
UPDATE hash_i4_heap SET random = 1 WHERE hash_i4_heap.seqno = 1492;
SELECT h.seqno AS i1492,
h.random AS i1 FROM hash_i4_heap AS h WHERE h.random = 1;
UPDATE hash_i4_heap SET seqno = 20000 WHERE hash_i4_heap.random = 1492795354;
SELECT h.seqno AS i20000 FROM hash_i4_heap AS h WHERE h.random = 1492795354;
UPDATE hash_name_heap SET random = '0123456789abcdef'::name WHERE hash_name_heap.seqno = 6543;
SELECT h.seqno AS i6543,
h.random AS c0_to_f FROM hash_name_heap AS h WHERE h.random = '0123456789abcdef'::name;
UPDATE hash_name_heap SET seqno = 20000 WHERE hash_name_heap.random = '76652222'::name;
SELECT h.seqno AS emptyset FROM hash_name_heap AS h WHERE h.random = '76652222'::name;
UPDATE hash_txt_heap SET random = '0123456789abcdefghijklmnop'::text WHERE hash_txt_heap.seqno = 4002;
SELECT h.seqno AS i4002,
h.random AS c0_to_p FROM hash_txt_heap AS h WHERE h.random = '0123456789abcdefghijklmnop'::text;
UPDATE hash_txt_heap SET seqno = 20000 WHERE hash_txt_heap.random = '959363399'::text;
SELECT h.seqno AS t20000 FROM hash_txt_heap AS h WHERE h.random = '959363399'::text;
UPDATE hash_f8_heap SET random = '-1234.1234'::float8 WHERE hash_f8_heap.seqno = 8906;
SELECT h.seqno AS i8096,
h.random AS f1234_1234 FROM hash_f8_heap AS h WHERE h.random = '-1234.1234'::float8;
UPDATE hash_f8_heap SET seqno = 20000 WHERE hash_f8_heap.random = '488912369'::float8;
SELECT h.seqno AS f20000 FROM hash_f8_heap AS h WHERE h.random = '488912369'::float8;"
`;

exports[`kitchen sink upstream upstream/hs_primary_extremes.sql 1`] = `
"DROP TABLE IF EXISTS hs_extreme;
CREATE TABLE hs_extreme (
col1 int
);
CREATE OR REPLACE FUNCTION hs_subxids ( n int ) RETURNS void LANGUAGE plpgsql AS $LQLCODEZ$
BEGIN
IF n <= 0 THEN RETURN; END IF;
INSERT INTO hs_extreme VALUES (n);
PERFORM hs_subxids(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;
$LQLCODEZ$;
BEGIN;
SELECT hs_subxids(257);
ROLLBACK;
BEGIN;
SELECT hs_subxids(257);
COMMIT;
SET client_min_messages = 'warning';
CREATE OR REPLACE FUNCTION hs_locks_create ( n int ) RETURNS void LANGUAGE plpgsql AS $LQLCODEZ$
BEGIN
IF n <= 0 THEN
CHECKPOINT;
RETURN;
END IF;
EXECUTE 'CREATE TABLE hs_locks_' || n::text || ' ()';
PERFORM hs_locks_create(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;
$LQLCODEZ$;
CREATE OR REPLACE FUNCTION hs_locks_drop ( n int ) RETURNS void LANGUAGE plpgsql AS $LQLCODEZ$
BEGIN
IF n <= 0 THEN
CHECKPOINT;
RETURN;
END IF;
EXECUTE 'DROP TABLE IF EXISTS hs_locks_' || n::text;
PERFORM hs_locks_drop(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;
$LQLCODEZ$;
BEGIN;
SELECT hs_locks_drop(257);
SELECT hs_locks_create(257);
SELECT count(*) > 257 FROM pg_locks;
ROLLBACK;
BEGIN;
SELECT hs_locks_drop(257);
SELECT hs_locks_create(257);
SELECT count(*) > 257 FROM pg_locks;
COMMIT;
SELECT hs_locks_drop(257);
SELECT pg_switch_xlog();"
`;

exports[`kitchen sink upstream upstream/hs_primary_extremes.sql 2`] = `
"DROP TABLE IF EXISTS hs_extreme;
CREATE TABLE hs_extreme (
col1 int
);
CREATE OR REPLACE FUNCTION hs_subxids ( n int ) RETURNS void LANGUAGE plpgsql AS $EOFCODE$BEGIN
IF n <= 0 THEN RETURN; END IF;
INSERT INTO hs_extreme VALUES (n);
PERFORM hs_subxids(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;$EOFCODE$;
BEGIN;
SELECT hs_subxids(257);
ROLLBACK;
BEGIN;
SELECT hs_subxids(257);
COMMIT;
SET client_min_messages = 'warning';
CREATE OR REPLACE FUNCTION hs_locks_create ( n int ) RETURNS void LANGUAGE plpgsql AS $EOFCODE$BEGIN
IF n <= 0 THEN
CHECKPOINT;
RETURN;
END IF;
EXECUTE 'CREATE TABLE hs_locks_' || n::text || ' ()';
PERFORM hs_locks_create(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;$EOFCODE$;
CREATE OR REPLACE FUNCTION hs_locks_drop ( n int ) RETURNS void LANGUAGE plpgsql AS $EOFCODE$BEGIN
IF n <= 0 THEN
CHECKPOINT;
RETURN;
END IF;
EXECUTE 'DROP TABLE IF EXISTS hs_locks_' || n::text;
PERFORM hs_locks_drop(n - 1);
RETURN;
EXCEPTION WHEN raise_exception THEN NULL; END;$EOFCODE$;
BEGIN;
SELECT hs_locks_drop(257);
SELECT hs_locks_create(257);
SELECT count(*) > 257 FROM pg_locks;
ROLLBACK;
BEGIN;
SELECT hs_locks_drop(257);
SELECT hs_locks_create(257);
SELECT count(*) > 257 FROM pg_locks;
COMMIT;
SELECT hs_locks_drop(257);
SELECT pg_switch_xlog();"
`;

exports[`kitchen sink upstream upstream/hs_primary_setup.sql 1`] = `
"DROP TABLE IF EXISTS hs1;
CREATE TABLE hs1 (
col1 int PRIMARY KEY
);
INSERT INTO hs1 VALUES (1);
DROP TABLE IF EXISTS hs2;
CREATE TABLE hs2 (
col1 int PRIMARY KEY
);
INSERT INTO hs2 VALUES (12);
INSERT INTO hs2 VALUES (13);
DROP TABLE IF EXISTS hs3;
CREATE TABLE hs3 (
col1 int PRIMARY KEY
);
INSERT INTO hs3 VALUES (113);
INSERT INTO hs3 VALUES (114);
INSERT INTO hs3 VALUES (115);
DROP SEQUENCE IF EXISTS hsseq;
CREATE SEQUENCE hsseq;
SELECT pg_switch_xlog();"
`;

exports[`kitchen sink upstream upstream/hs_primary_setup.sql 2`] = `
"DROP TABLE IF EXISTS hs1;
CREATE TABLE hs1 (
col1 int PRIMARY KEY
);
INSERT INTO hs1 VALUES (1);
DROP TABLE IF EXISTS hs2;
CREATE TABLE hs2 (
col1 int PRIMARY KEY
);
INSERT INTO hs2 VALUES (12);
INSERT INTO hs2 VALUES (13);
DROP TABLE IF EXISTS hs3;
CREATE TABLE hs3 (
col1 int PRIMARY KEY
);
INSERT INTO hs3 VALUES (113);
INSERT INTO hs3 VALUES (114);
INSERT INTO hs3 VALUES (115);
DROP SEQUENCE IF EXISTS hsseq;
CREATE SEQUENCE hsseq;
SELECT pg_switch_xlog();"
`;

exports[`kitchen sink upstream upstream/hs_standby_check.sql 1`] = `"SELECT CASE pg_is_in_recovery() WHEN FALSE THEN ('These tests are intended only for execution on a standby server that is reading ' || 'WAL from a server upon which the regression database is already created and into ') || 'which src/test/regress/sql/hs_primary_setup.sql has been run' ELSE 'Tests are running on a standby server during recovery' END;"`;

exports[`kitchen sink upstream upstream/hs_standby_check.sql 2`] = `"SELECT CASE pg_is_in_recovery() WHEN (FALSE) THEN ('These tests are intended only for execution on a standby server that is reading ' || 'WAL from a server upon which the regression database is already created and into ') || 'which src/test/regress/sql/hs_primary_setup.sql has been run' ELSE 'Tests are running on a standby server during recovery' END;"`;

exports[`kitchen sink upstream upstream/hs_standby_functions.sql 1`] = `
"SELECT txid_current();
SELECT length(txid_current_snapshot()::text) >= 4;
SELECT pg_start_backup('should fail');
SELECT pg_switch_xlog();
SELECT pg_stop_backup();
SELECT * FROM pg_prepared_xacts;
SELECT locktype,
virtualxid,
virtualtransaction,
mode,
granted FROM pg_locks WHERE virtualxid = '1/1';
SELECT pg_cancel_backend(pg_backend_pid());"
`;

exports[`kitchen sink upstream upstream/hs_standby_functions.sql 2`] = `
"SELECT txid_current();
SELECT length(txid_current_snapshot()::text) >= 4;
SELECT pg_start_backup('should fail');
SELECT pg_switch_xlog();
SELECT pg_stop_backup();
SELECT * FROM pg_prepared_xacts;
SELECT locktype,
virtualxid,
virtualtransaction,
mode,
granted FROM pg_locks WHERE virtualxid = '1/1';
SELECT pg_cancel_backend(pg_backend_pid());"
`;

exports[`kitchen sink upstream upstream/init_privs.sql 1`] = `
"SELECT count(*) > 0 FROM pg_init_privs;
GRANT SELECT ON TABLE pg_proc TO CURRENT_USER;
GRANT SELECT ( prosrc ) ON TABLE pg_proc TO CURRENT_USER;
GRANT SELECT ( rolname, rolsuper ) ON TABLE pg_authid TO CURRENT_USER;"
`;

exports[`kitchen sink upstream upstream/init_privs.sql 2`] = `
"SELECT count(*) > 0 FROM pg_init_privs;
GRANT SELECT ON TABLE pg_proc TO CURRENT_USER;
GRANT SELECT ( prosrc ) ON TABLE pg_proc TO CURRENT_USER;
GRANT SELECT ( rolname, rolsuper ) ON TABLE pg_authid TO CURRENT_USER;"
`;

exports[`kitchen sink upstream upstream/insert.sql 1`] = `
"CREATE TABLE inserttest (
col1 int4,
col2 int4 NOT NULL,
col3 text DEFAULT ('testing')
);
INSERT INTO inserttest (col1, col2, col3) VALUES (DEFAULT, DEFAULT, DEFAULT);
INSERT INTO inserttest (col2, col3) VALUES (3, DEFAULT);
INSERT INTO inserttest (col1, col2, col3) VALUES (DEFAULT, 5, DEFAULT);
INSERT INTO inserttest VALUES (DEFAULT, 5, 'test');
INSERT INTO inserttest VALUES (DEFAULT, 7);
SELECT * FROM inserttest;
INSERT INTO inserttest (col1, col2, col3) VALUES (DEFAULT, DEFAULT);
INSERT INTO inserttest (col1, col2, col3) VALUES (1, 2);
INSERT INTO inserttest (col1) VALUES (1, 2);
INSERT INTO inserttest (col1) VALUES (DEFAULT, DEFAULT);
SELECT * FROM inserttest;
INSERT INTO inserttest VALUES (10, 20, '40'), ((-1), 2, DEFAULT), ((SELECT 2), (SELECT i FROM (VALUES (3)) AS foo (i)), 'values are fun!');
SELECT * FROM inserttest;
INSERT INTO inserttest VALUES (30, 50, repeat('x', 10000));
SELECT col1,
col2,
char_length(col3) FROM inserttest;
DROP TABLE inserttest;"
`;

exports[`kitchen sink upstream upstream/insert.sql 2`] = `
"CREATE TABLE inserttest (
col1 int4,
col2 int4 NOT NULL,
col3 text DEFAULT ( 'testing' )
);
INSERT INTO inserttest ( col1, col2, col3 ) VALUES (DEFAULT, DEFAULT, DEFAULT);
INSERT INTO inserttest ( col2, col3 ) VALUES (3, DEFAULT);
INSERT INTO inserttest ( col1, col2, col3 ) VALUES (DEFAULT, 5, DEFAULT);
INSERT INTO inserttest VALUES (DEFAULT, 5, 'test');
INSERT INTO inserttest VALUES (DEFAULT, 7);
SELECT * FROM inserttest;
INSERT INTO inserttest ( col1, col2, col3 ) VALUES (DEFAULT, DEFAULT);
INSERT INTO inserttest ( col1, col2, col3 ) VALUES (1, 2);
INSERT INTO inserttest ( col1 ) VALUES (1, 2);
INSERT INTO inserttest ( col1 ) VALUES (DEFAULT, DEFAULT);
SELECT * FROM inserttest;
INSERT INTO inserttest VALUES (10, 20, '40'), ((-1), 2, DEFAULT), ((SELECT 2), (SELECT i FROM (VALUES (3)) AS foo(i)), 'values are fun!');
SELECT * FROM inserttest;
INSERT INTO inserttest VALUES (30, 50, repeat('x', 10000));
SELECT col1,
col2,
char_length(col3) FROM inserttest;
DROP TABLE inserttest;"
`;

exports[`kitchen sink upstream upstream/int2.sql 1`] = `
"CREATE TABLE int2_tbl (
f1 int2
);
INSERT INTO int2_tbl (f1) VALUES ('0   ');
INSERT INTO int2_tbl (f1) VALUES ('  1234 ');
INSERT INTO int2_tbl (f1) VALUES ('    -1234');
INSERT INTO int2_tbl (f1) VALUES ('34.5');
INSERT INTO int2_tbl (f1) VALUES ('32767');
INSERT INTO int2_tbl (f1) VALUES ('-32767');
INSERT INTO int2_tbl (f1) VALUES ('100000');
INSERT INTO int2_tbl (f1) VALUES ('asdf');
INSERT INTO int2_tbl (f1) VALUES ('    ');
INSERT INTO int2_tbl (f1) VALUES ('- 1234');
INSERT INTO int2_tbl (f1) VALUES ('4 444');
INSERT INTO int2_tbl (f1) VALUES ('123 dt');
INSERT INTO int2_tbl (f1) VALUES ('');
SELECT '' AS five,
* FROM int2_tbl;
SELECT '' AS four,
i.* FROM int2_tbl AS i WHERE i.f1 <> '0'::int2;
SELECT '' AS four,
i.* FROM int2_tbl AS i WHERE i.f1 <> '0'::int4;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE i.f1 = '0'::int2;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE i.f1 = '0'::int4;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 < '0'::int2;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 < '0'::int4;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 <= '0'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 <= '0'::int4;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 > '0'::int2;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 > '0'::int4;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 >= '0'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 >= '0'::int4;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE (i.f1 % '2'::int2) = '1'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE (i.f1 % '2'::int4) = '0'::int2;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int2_tbl AS i WHERE abs(f1) < 16384;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int2_tbl AS i WHERE f1 < 32766;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int2_tbl AS i WHERE f1 > (-32767);
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int4 AS x FROM int2_tbl AS i;
SELECT ((-1::int2) << 15)::text;
SELECT (((-1::int2) << 15) + 1::int2)::text;
SELECT (-32768)::int2 * (-1)::int2;
SELECT (-32768)::int2 / (-1)::int2;
SELECT (-32768)::int2 % (-1)::int2;
SELECT x,
x::int2 AS int2_value FROM (VALUES (-2.5::float8), (-1.5::float8), (-0.5::float8), (0.0::float8), (0.5::float8), (1.5::float8), (2.5::float8)) AS t (x);
SELECT x,
x::int2 AS int2_value FROM (VALUES (-2.5::numeric), (-1.5::numeric), (-0.5::numeric), (0.0::numeric), (0.5::numeric), (1.5::numeric), (2.5::numeric)) AS t (x);"
`;

exports[`kitchen sink upstream upstream/int2.sql 2`] = `
"CREATE TABLE int2_tbl (
f1 int2
);
INSERT INTO int2_tbl ( f1 ) VALUES ('0   ');
INSERT INTO int2_tbl ( f1 ) VALUES ('  1234 ');
INSERT INTO int2_tbl ( f1 ) VALUES ('    -1234');
INSERT INTO int2_tbl ( f1 ) VALUES ('34.5');
INSERT INTO int2_tbl ( f1 ) VALUES ('32767');
INSERT INTO int2_tbl ( f1 ) VALUES ('-32767');
INSERT INTO int2_tbl ( f1 ) VALUES ('100000');
INSERT INTO int2_tbl ( f1 ) VALUES ('asdf');
INSERT INTO int2_tbl ( f1 ) VALUES ('    ');
INSERT INTO int2_tbl ( f1 ) VALUES ('- 1234');
INSERT INTO int2_tbl ( f1 ) VALUES ('4 444');
INSERT INTO int2_tbl ( f1 ) VALUES ('123 dt');
INSERT INTO int2_tbl ( f1 ) VALUES ('');
SELECT '' AS five,
* FROM int2_tbl;
SELECT '' AS four,
i.* FROM int2_tbl AS i WHERE i.f1 <> '0'::int2;
SELECT '' AS four,
i.* FROM int2_tbl AS i WHERE i.f1 <> '0'::int4;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE i.f1 = '0'::int2;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE i.f1 = '0'::int4;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 < '0'::int2;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 < '0'::int4;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 <= '0'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 <= '0'::int4;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 > '0'::int2;
SELECT '' AS two,
i.* FROM int2_tbl AS i WHERE i.f1 > '0'::int4;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 >= '0'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE i.f1 >= '0'::int4;
SELECT '' AS one,
i.* FROM int2_tbl AS i WHERE (i.f1 % '2'::int2) = '1'::int2;
SELECT '' AS three,
i.* FROM int2_tbl AS i WHERE (i.f1 % '2'::int4) = '0'::int2;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int2_tbl AS i WHERE abs(f1) < 16384;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int2_tbl AS i WHERE f1 < 32766;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int2_tbl AS i WHERE f1 > (-32767);
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int2 AS x FROM int2_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int4 AS x FROM int2_tbl AS i;
SELECT ((-1::int2) << 15)::text;
SELECT (((-1::int2) << 15) + 1::int2)::text;
SELECT (-32768)::int2 * (-1)::int2;
SELECT (-32768)::int2 / (-1)::int2;
SELECT (-32768)::int2 % (-1)::int2;
SELECT x,
x::int2 AS int2_value FROM (VALUES (-2.5::float8), (-1.5::float8), (-0.5::float8), (0.0::float8), (0.5::float8), (1.5::float8), (2.5::float8)) AS t(x);
SELECT x,
x::int2 AS int2_value FROM (VALUES (-2.5::numeric), (-1.5::numeric), (-0.5::numeric), (0.0::numeric), (0.5::numeric), (1.5::numeric), (2.5::numeric)) AS t(x);"
`;

exports[`kitchen sink upstream upstream/int4.sql 1`] = `
"CREATE TABLE int4_tbl (
f1 int4
);
INSERT INTO int4_tbl (f1) VALUES ('   0  ');
INSERT INTO int4_tbl (f1) VALUES ('123456     ');
INSERT INTO int4_tbl (f1) VALUES ('    -123456');
INSERT INTO int4_tbl (f1) VALUES ('34.5');
INSERT INTO int4_tbl (f1) VALUES ('2147483647');
INSERT INTO int4_tbl (f1) VALUES ('-2147483647');
INSERT INTO int4_tbl (f1) VALUES ('1000000000000');
INSERT INTO int4_tbl (f1) VALUES ('asdf');
INSERT INTO int4_tbl (f1) VALUES ('     ');
INSERT INTO int4_tbl (f1) VALUES ('   asdf   ');
INSERT INTO int4_tbl (f1) VALUES ('- 1234');
INSERT INTO int4_tbl (f1) VALUES ('123       5');
INSERT INTO int4_tbl (f1) VALUES ('');
SELECT '' AS five,
* FROM int4_tbl;
SELECT '' AS four,
i.* FROM int4_tbl AS i WHERE i.f1 <> '0'::int2;
SELECT '' AS four,
i.* FROM int4_tbl AS i WHERE i.f1 <> '0'::int4;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE i.f1 = '0'::int2;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE i.f1 = '0'::int4;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 < '0'::int2;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 < '0'::int4;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 <= '0'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 <= '0'::int4;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 > '0'::int2;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 > '0'::int4;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 >= '0'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 >= '0'::int4;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE (i.f1 % '2'::int2) = '1'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE (i.f1 % '2'::int4) = '0'::int2;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int4_tbl AS i WHERE abs(f1) < 1073741824;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int4_tbl AS i WHERE abs(f1) < 1073741824;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int4_tbl AS i WHERE f1 < 2147483646;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int4_tbl AS i WHERE f1 < 2147483646;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int4_tbl AS i WHERE f1 > (-2147483647);
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int4_tbl AS i WHERE f1 > (-2147483647);
SELECT '' AS five,
i.f1,
i.f1 / '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int4 AS x FROM int4_tbl AS i;
SELECT (-2) + 3 AS one;
SELECT 4 - 2 AS two;
SELECT 2 - (-1) AS three;
SELECT 2 - (-2) AS four;
SELECT ('2'::int2 * '2'::int2) = ('16'::int2 / '4'::int2) AS \\"true\\";
SELECT ('2'::int4 * '2'::int2) = ('16'::int2 / '4'::int4) AS \\"true\\";
SELECT ('2'::int2 * '2'::int4) = ('16'::int4 / '4'::int2) AS \\"true\\";
SELECT '1000'::int4 < '999'::int4 AS \\"false\\";
SELECT 4! AS twenty_four;
SELECT !!3 AS six;
SELECT ((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1 AS ten;
SELECT 2 + (2 / 2) AS three;
SELECT (2 + 2) / 2 AS two;
SELECT ((-1::int4) << 31)::text;
SELECT (((-1::int4) << 31) + 1)::text;
SELECT (-2147483648)::int4 * (-1)::int4;
SELECT (-2147483648)::int4 / (-1)::int4;
SELECT (-2147483648)::int4 % (-1)::int4;
SELECT (-2147483648)::int4 * (-1)::int2;
SELECT (-2147483648)::int4 / (-1)::int2;
SELECT (-2147483648)::int4 % (-1)::int2;
SELECT x,
x::int4 AS int4_value FROM (VALUES (-2.5::float8), (-1.5::float8), (-0.5::float8), (0.0::float8), (0.5::float8), (1.5::float8), (2.5::float8)) AS t (x);
SELECT x,
x::int4 AS int4_value FROM (VALUES (-2.5::numeric), (-1.5::numeric), (-0.5::numeric), (0.0::numeric), (0.5::numeric), (1.5::numeric), (2.5::numeric)) AS t (x);"
`;

exports[`kitchen sink upstream upstream/int4.sql 2`] = `
"CREATE TABLE int4_tbl (
f1 int4
);
INSERT INTO int4_tbl ( f1 ) VALUES ('   0  ');
INSERT INTO int4_tbl ( f1 ) VALUES ('123456     ');
INSERT INTO int4_tbl ( f1 ) VALUES ('    -123456');
INSERT INTO int4_tbl ( f1 ) VALUES ('34.5');
INSERT INTO int4_tbl ( f1 ) VALUES ('2147483647');
INSERT INTO int4_tbl ( f1 ) VALUES ('-2147483647');
INSERT INTO int4_tbl ( f1 ) VALUES ('1000000000000');
INSERT INTO int4_tbl ( f1 ) VALUES ('asdf');
INSERT INTO int4_tbl ( f1 ) VALUES ('     ');
INSERT INTO int4_tbl ( f1 ) VALUES ('   asdf   ');
INSERT INTO int4_tbl ( f1 ) VALUES ('- 1234');
INSERT INTO int4_tbl ( f1 ) VALUES ('123       5');
INSERT INTO int4_tbl ( f1 ) VALUES ('');
SELECT '' AS five,
* FROM int4_tbl;
SELECT '' AS four,
i.* FROM int4_tbl AS i WHERE i.f1 <> '0'::int2;
SELECT '' AS four,
i.* FROM int4_tbl AS i WHERE i.f1 <> '0'::int4;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE i.f1 = '0'::int2;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE i.f1 = '0'::int4;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 < '0'::int2;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 < '0'::int4;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 <= '0'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 <= '0'::int4;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 > '0'::int2;
SELECT '' AS two,
i.* FROM int4_tbl AS i WHERE i.f1 > '0'::int4;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 >= '0'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE i.f1 >= '0'::int4;
SELECT '' AS one,
i.* FROM int4_tbl AS i WHERE (i.f1 % '2'::int2) = '1'::int2;
SELECT '' AS three,
i.* FROM int4_tbl AS i WHERE (i.f1 % '2'::int4) = '0'::int2;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int2 AS x FROM int4_tbl AS i WHERE abs(f1) < 1073741824;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 * '2'::int4 AS x FROM int4_tbl AS i WHERE abs(f1) < 1073741824;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int2 AS x FROM int4_tbl AS i WHERE f1 < 2147483646;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 + '2'::int4 AS x FROM int4_tbl AS i WHERE f1 < 2147483646;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int2 AS x FROM int4_tbl AS i WHERE f1 > (-2147483647);
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 - '2'::int4 AS x FROM int4_tbl AS i WHERE f1 > (-2147483647);
SELECT '' AS five,
i.f1,
i.f1 / '2'::int2 AS x FROM int4_tbl AS i;
SELECT '' AS five,
i.f1,
i.f1 / '2'::int4 AS x FROM int4_tbl AS i;
SELECT (-2) + 3 AS one;
SELECT 4 - 2 AS two;
SELECT 2 - (-1) AS three;
SELECT 2 - (-2) AS four;
SELECT ('2'::int2 * '2'::int2) = ('16'::int2 / '4'::int2) AS \\"true\\";
SELECT ('2'::int4 * '2'::int2) = ('16'::int2 / '4'::int4) AS \\"true\\";
SELECT ('2'::int2 * '2'::int4) = ('16'::int4 / '4'::int2) AS \\"true\\";
SELECT '1000'::int4 < '999'::int4 AS \\"false\\";
SELECT 4! AS twenty_four;
SELECT !!3 AS six;
SELECT ((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1 AS ten;
SELECT 2 + (2 / 2) AS three;
SELECT (2 + 2) / 2 AS two;
SELECT ((-1::int4) << 31)::text;
SELECT (((-1::int4) << 31) + 1)::text;
SELECT (-2147483648)::int4 * (-1)::int4;
SELECT (-2147483648)::int4 / (-1)::int4;
SELECT (-2147483648)::int4 % (-1)::int4;
SELECT (-2147483648)::int4 * (-1)::int2;
SELECT (-2147483648)::int4 / (-1)::int2;
SELECT (-2147483648)::int4 % (-1)::int2;
SELECT x,
x::int4 AS int4_value FROM (VALUES (-2.5::float8), (-1.5::float8), (-0.5::float8), (0.0::float8), (0.5::float8), (1.5::float8), (2.5::float8)) AS t(x);
SELECT x,
x::int4 AS int4_value FROM (VALUES (-2.5::numeric), (-1.5::numeric), (-0.5::numeric), (0.0::numeric), (0.5::numeric), (1.5::numeric), (2.5::numeric)) AS t(x);"
`;

exports[`kitchen sink upstream upstream/json_encoding.sql 1`] = `
"SELECT '\\"\\\\u\\"'::json;
SELECT '\\"\\\\u00\\"'::json;
SELECT '\\"\\\\u000g\\"'::json;
SELECT '\\"\\\\u0000\\"'::json;
SELECT '\\"\\\\uaBcD\\"'::json;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ude04\\\\ud83d\\\\udc36\\" }'::json->'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ud83d\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04\\\\ud83d\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ud83dX\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04X\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::json AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::json AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::json AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::json AS not_unescaped;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::json AS not_an_escape;
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::json->>'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::json->>'a' AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::json->>'a' AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::json->>'a' AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::json->>'a' AS not_an_escape;
SELECT '\\"\\\\u\\"'::jsonb;
SELECT '\\"\\\\u00\\"'::jsonb;
SELECT '\\"\\\\u000g\\"'::jsonb;
SELECT '\\"\\\\u0045\\"'::jsonb;
SELECT '\\"\\\\u0000\\"'::jsonb;
SELECT octet_length('\\"\\\\uaBcD\\"'::jsonb::text);
SELECT octet_length(('{ \\"a\\":  \\"\\\\ud83d\\\\ude04\\\\ud83d\\\\udc36\\" }'::jsonb->'a')::text) AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ud83d\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04\\\\ud83d\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ud83dX\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04X\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::jsonb AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::jsonb AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::jsonb AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::jsonb AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::jsonb AS not_an_escape;
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::jsonb->>'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::jsonb->>'a' AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::jsonb->>'a' AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::jsonb->>'a' AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::jsonb->>'a' AS not_an_escape;"
`;

exports[`kitchen sink upstream upstream/json_encoding.sql 2`] = `
"SELECT '\\"\\\\u\\"'::json;
SELECT '\\"\\\\u00\\"'::json;
SELECT '\\"\\\\u000g\\"'::json;
SELECT '\\"\\\\u0000\\"'::json;
SELECT '\\"\\\\uaBcD\\"'::json;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ude04\\\\ud83d\\\\udc36\\" }'::json->'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ud83d\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04\\\\ud83d\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ud83dX\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04X\\" }'::json->'a';
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::json AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::json AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::json AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::json AS not_unescaped;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::json AS not_an_escape;
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::json->>'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::json->>'a' AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::json->>'a' AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::json->>'a' AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::json->>'a' AS not_an_escape;
SELECT '\\"\\\\u\\"'::jsonb;
SELECT '\\"\\\\u00\\"'::jsonb;
SELECT '\\"\\\\u000g\\"'::jsonb;
SELECT '\\"\\\\u0045\\"'::jsonb;
SELECT '\\"\\\\u0000\\"'::jsonb;
SELECT octet_length('\\"\\\\uaBcD\\"'::jsonb::text);
SELECT octet_length(('{ \\"a\\":  \\"\\\\ud83d\\\\ude04\\\\ud83d\\\\udc36\\" }'::jsonb->'a')::text) AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"\\\\ud83d\\\\ud83d\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04\\\\ud83d\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ud83dX\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"\\\\ude04X\\" }'::jsonb->'a';
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::jsonb AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::jsonb AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::jsonb AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::jsonb AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::jsonb AS not_an_escape;
SELECT '{ \\"a\\":  \\"the Copyright \\\\u00a9 sign\\" }'::jsonb->>'a' AS correct_in_utf8;
SELECT '{ \\"a\\":  \\"dollar \\\\u0024 character\\" }'::jsonb->>'a' AS correct_everywhere;
SELECT '{ \\"a\\":  \\"dollar \\\\\\\\u0024 character\\" }'::jsonb->>'a' AS not_an_escape;
SELECT '{ \\"a\\":  \\"null \\\\u0000 escape\\" }'::jsonb->>'a' AS fails;
SELECT '{ \\"a\\":  \\"null \\\\\\\\u0000 escape\\" }'::jsonb->>'a' AS not_an_escape;"
`;

exports[`kitchen sink upstream upstream/line.sql 1`] = `
"CREATE TABLE line_tbl (
s line
);
INSERT INTO line_tbl VALUES ('{1,-1,1}');
INSERT INTO line_tbl VALUES ('(0,0),(6,6)');
INSERT INTO line_tbl VALUES ('10,-10 ,-5,-4');
INSERT INTO line_tbl VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO line_tbl VALUES ('(11,22,33,44)');
INSERT INTO line_tbl VALUES ('[(1,0),(1,0)]');
INSERT INTO line_tbl VALUES ('[(1,3),(2,3)]');
INSERT INTO line_tbl VALUES ('[(3,1),(3,2)]');
INSERT INTO line_tbl VALUES ('{0,0,1}');
INSERT INTO line_tbl VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO line_tbl VALUES ('[1,2,3, 4');
INSERT INTO line_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO line_tbl VALUES ('[(1,2),(3,4)');
SELECT * FROM line_tbl;
SELECT * FROM line_tbl WHERE (s <-> '[(1,2),(3,4)]'::line) < 10;
SELECT * FROM line_tbl WHERE ('(0.1,0.1)'::point <-> s) < 1;
SELECT * FROM line_tbl WHERE ('[(0.1,0.1),(0.2,0.2)]'::lseg <-> s) < 1;
SELECT '[(1,1),(2,1)]'::line <-> '[(-1,-1),(-2,-1)]'::line;
SELECT '[(1,1),(2,1)]'::lseg <-> '[(-1,-1),(-2,-1)]'::line;
SELECT '(-1,1)'::point <-> '[(-3,0),(-4,0)]'::line;
SELECT '[(1,1),(5,5)]'::lseg ?# '[(2,0),(0,2)]'::line;
SELECT '[(1,1),(5,5)]'::lseg ?# '[(0,0),(1,0)]'::line;
SELECT '[(0,0),(1,1)]'::line ?# '(0,0,2,2)'::box;
SELECT '[(3,0),(4,1)]'::line ?# '(0,0,2,2)'::box;
SELECT '(1,1)'::point <@ '[(0,0),(2,2)]'::line;
SELECT '(1,1)'::point <@ '[(0,0),(1,0)]'::line;
SELECT '(1,1)'::point @ '[(0,0),(2,2)]'::line;
SELECT '(1,1)'::point @ '[(0,0),(1,0)]'::line;
SELECT '[(1,1),(2,2)]'::lseg <@ '[(0,0),(2,2)]'::line;
SELECT '[(1,1),(2,1)]'::lseg <@ '[(0,0),(1,0)]'::line;
SELECT '[(1,1),(2,2)]'::lseg @ '[(0,0),(2,2)]'::line;
SELECT '[(1,1),(2,1)]'::lseg @ '[(0,0),(1,0)]'::line;
SELECT '(0,1)'::point ## '[(0,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ## '[(1,0),(2,0)]'::lseg;
SELECT '[(0,0),(1,1)]'::line ?# '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?# '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line # '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line # '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?|| '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?|| '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,0)]'::line ?-| '[(0,0),(0,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?-| '[(1,0),(1,1)]'::line;
SELECT ?-'[(0,0),(1,0)]'::line;
SELECT ?-'[(0,0),(1,1)]'::line;
SELECT ?|'[(0,0),(0,1)]'::line;
SELECT ?|'[(0,0),(1,1)]'::line;
SELECT line('(1,2)'::point, '(3,4)'::point);
SELECT '[(1,2),(3,4)]'::line = '[(3,4),(4,5)]'::line;
SELECT '[(1,2),(3,4)]'::line = '[(3,4),(4,4)]'::line;"
`;

exports[`kitchen sink upstream upstream/line.sql 2`] = `
"CREATE TABLE line_tbl (
s line
);
INSERT INTO line_tbl VALUES ('{1,-1,1}');
INSERT INTO line_tbl VALUES ('(0,0),(6,6)');
INSERT INTO line_tbl VALUES ('10,-10 ,-5,-4');
INSERT INTO line_tbl VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO line_tbl VALUES ('(11,22,33,44)');
INSERT INTO line_tbl VALUES ('[(1,0),(1,0)]');
INSERT INTO line_tbl VALUES ('[(1,3),(2,3)]');
INSERT INTO line_tbl VALUES ('[(3,1),(3,2)]');
INSERT INTO line_tbl VALUES ('{0,0,1}');
INSERT INTO line_tbl VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO line_tbl VALUES ('[1,2,3, 4');
INSERT INTO line_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO line_tbl VALUES ('[(1,2),(3,4)');
SELECT * FROM line_tbl;
SELECT * FROM line_tbl WHERE (s <-> '[(1,2),(3,4)]'::line) < 10;
SELECT * FROM line_tbl WHERE ('(0.1,0.1)'::point <-> s) < 1;
SELECT * FROM line_tbl WHERE ('[(0.1,0.1),(0.2,0.2)]'::lseg <-> s) < 1;
SELECT '[(1,1),(2,1)]'::line <-> '[(-1,-1),(-2,-1)]'::line;
SELECT '[(1,1),(2,1)]'::lseg <-> '[(-1,-1),(-2,-1)]'::line;
SELECT '(-1,1)'::point <-> '[(-3,0),(-4,0)]'::line;
SELECT '[(1,1),(5,5)]'::lseg ?# '[(2,0),(0,2)]'::line;
SELECT '[(1,1),(5,5)]'::lseg ?# '[(0,0),(1,0)]'::line;
SELECT '[(0,0),(1,1)]'::line ?# '(0,0,2,2)'::box;
SELECT '[(3,0),(4,1)]'::line ?# '(0,0,2,2)'::box;
SELECT '(1,1)'::point <@ '[(0,0),(2,2)]'::line;
SELECT '(1,1)'::point <@ '[(0,0),(1,0)]'::line;
SELECT '(1,1)'::point @ '[(0,0),(2,2)]'::line;
SELECT '(1,1)'::point @ '[(0,0),(1,0)]'::line;
SELECT '[(1,1),(2,2)]'::lseg <@ '[(0,0),(2,2)]'::line;
SELECT '[(1,1),(2,1)]'::lseg <@ '[(0,0),(1,0)]'::line;
SELECT '[(1,1),(2,2)]'::lseg @ '[(0,0),(2,2)]'::line;
SELECT '[(1,1),(2,1)]'::lseg @ '[(0,0),(1,0)]'::line;
SELECT '(0,1)'::point ## '[(0,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ## '[(1,0),(2,0)]'::lseg;
SELECT '[(0,0),(1,1)]'::line ?# '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?# '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line # '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line # '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?|| '[(1,0),(2,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?|| '[(1,0),(1,1)]'::line;
SELECT '[(0,0),(1,0)]'::line ?-| '[(0,0),(0,1)]'::line;
SELECT '[(0,0),(1,1)]'::line ?-| '[(1,0),(1,1)]'::line;
SELECT ?-'[(0,0),(1,0)]'::line;
SELECT ?-'[(0,0),(1,1)]'::line;
SELECT ?|'[(0,0),(0,1)]'::line;
SELECT ?|'[(0,0),(1,1)]'::line;
SELECT line('(1,2)'::point, '(3,4)'::point);
SELECT '[(1,2),(3,4)]'::line = '[(3,4),(4,5)]'::line;
SELECT '[(1,2),(3,4)]'::line = '[(3,4),(4,4)]'::line;"
`;

exports[`kitchen sink upstream upstream/lseg.sql 1`] = `
"CREATE TABLE lseg_tbl (
s lseg
);
INSERT INTO lseg_tbl VALUES ('[(1,2),(3,4)]');
INSERT INTO lseg_tbl VALUES ('(0,0),(6,6)');
INSERT INTO lseg_tbl VALUES ('10,-10 ,-3,-4');
INSERT INTO lseg_tbl VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO lseg_tbl VALUES ('(11,22,33,44)');
INSERT INTO lseg_tbl VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO lseg_tbl VALUES ('[1,2,3, 4');
INSERT INTO lseg_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO lseg_tbl VALUES ('[(1,2),(3,4)');
SELECT * FROM lseg_tbl;
SELECT * FROM lseg_tbl WHERE s <= '[(1,2),(3,4)]'::lseg;
SELECT * FROM lseg_tbl WHERE (s <-> '[(1,2),(3,4)]'::lseg) < 10;"
`;

exports[`kitchen sink upstream upstream/lseg.sql 2`] = `
"CREATE TABLE lseg_tbl (
s lseg
);
INSERT INTO lseg_tbl VALUES ('[(1,2),(3,4)]');
INSERT INTO lseg_tbl VALUES ('(0,0),(6,6)');
INSERT INTO lseg_tbl VALUES ('10,-10 ,-3,-4');
INSERT INTO lseg_tbl VALUES ('[-1e6,2e2,3e5, -4e1]');
INSERT INTO lseg_tbl VALUES ('(11,22,33,44)');
INSERT INTO lseg_tbl VALUES ('(3asdf,2 ,3,4r2)');
INSERT INTO lseg_tbl VALUES ('[1,2,3, 4');
INSERT INTO lseg_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO lseg_tbl VALUES ('[(1,2),(3,4)');
SELECT * FROM lseg_tbl;
SELECT * FROM lseg_tbl WHERE s <= '[(1,2),(3,4)]'::lseg;
SELECT * FROM lseg_tbl WHERE (s <-> '[(1,2),(3,4)]'::lseg) < 10;"
`;

exports[`kitchen sink upstream upstream/misc_functions.sql 1`] = `
"SELECT num_nonnulls(NULL);
SELECT num_nonnulls('1');
SELECT num_nonnulls(NULL::text);
SELECT num_nonnulls(NULL::text, NULL::int);
SELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', '9'::int8, 1.0 / NULL);
SELECT num_nonnulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nonnulls(VARIADIC '{\\"1\\",\\"2\\",\\"3\\",\\"4\\"}'::text[]);
SELECT num_nonnulls(VARIADIC ARRAY (SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) AS i));
SELECT num_nulls(NULL);
SELECT num_nulls('1');
SELECT num_nulls(NULL::text);
SELECT num_nulls(NULL::text, NULL::int);
SELECT num_nulls(1, 2, NULL::text, NULL::point, '', '9'::int8, 1.0 / NULL);
SELECT num_nulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nulls(VARIADIC '{\\"1\\",\\"2\\",\\"3\\",\\"4\\"}'::text[]);
SELECT num_nulls(VARIADIC ARRAY (SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) AS i));
SELECT num_nonnulls(VARIADIC NULL::text[]);
SELECT num_nonnulls(VARIADIC '{}'::int[]);
SELECT num_nulls(VARIADIC NULL::text[]);
SELECT num_nulls(VARIADIC '{}'::int[]);
SELECT num_nonnulls();
SELECT num_nulls();"
`;

exports[`kitchen sink upstream upstream/misc_functions.sql 2`] = `
"SELECT num_nonnulls(NULL);
SELECT num_nonnulls('1');
SELECT num_nonnulls(NULL::text);
SELECT num_nonnulls(NULL::text, NULL::int);
SELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', '9'::int8, 1.0 / NULL);
SELECT num_nonnulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nonnulls(VARIADIC '{\\"1\\",\\"2\\",\\"3\\",\\"4\\"}'::text[]);
SELECT num_nonnulls(VARIADIC ARRAY (SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) AS i));
SELECT num_nulls(NULL);
SELECT num_nulls('1');
SELECT num_nulls(NULL::text);
SELECT num_nulls(NULL::text, NULL::int);
SELECT num_nulls(1, 2, NULL::text, NULL::point, '', '9'::int8, 1.0 / NULL);
SELECT num_nulls(VARIADIC '{1,2,NULL,3}'::int[]);
SELECT num_nulls(VARIADIC '{\\"1\\",\\"2\\",\\"3\\",\\"4\\"}'::text[]);
SELECT num_nulls(VARIADIC ARRAY (SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) AS i));
SELECT num_nonnulls(VARIADIC NULL::text[]);
SELECT num_nonnulls(VARIADIC '{}'::int[]);
SELECT num_nulls(VARIADIC NULL::text[]);
SELECT num_nulls(VARIADIC '{}'::int[]);
SELECT num_nonnulls();
SELECT num_nulls();"
`;

exports[`kitchen sink upstream upstream/money.sql 1`] = `
"CREATE TABLE money_data (
m money
);
INSERT INTO money_data VALUES ('123');
SELECT * FROM money_data;
SELECT m + '123' FROM money_data;
SELECT m + '123.45' FROM money_data;
SELECT m - '123.45' FROM money_data;
SELECT m * 2 FROM money_data;
SELECT m / 2 FROM money_data;
SELECT m = '$123.00' FROM money_data;
SELECT m <> '$124.00' FROM money_data;
SELECT m <= '$123.00' FROM money_data;
SELECT m >= '$123.00' FROM money_data;
SELECT m < '$124.00' FROM money_data;
SELECT m > '$122.00' FROM money_data;
SELECT m = '$123.01' FROM money_data;
SELECT m <> '$123.00' FROM money_data;
SELECT m <= '$122.99' FROM money_data;
SELECT m >= '$123.01' FROM money_data;
SELECT m > '$124.00' FROM money_data;
SELECT m < '$122.00' FROM money_data;
SELECT cashlarger(m, '$124.00') FROM money_data;
SELECT cashsmaller(m, '$124.00') FROM money_data;
SELECT cash_words(m) FROM money_data;
SELECT cash_words(m + '1.23') FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.45');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.451');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.454');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.455');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.456');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.459');
SELECT * FROM money_data;
SELECT 1234567890::money;
SELECT 12345678901234567::money;
SELECT 123456789012345678::money;
SELECT 9223372036854775807::money;
SELECT (-12345)::money;
SELECT (-1234567890)::money;
SELECT (-12345678901234567)::money;
SELECT (-123456789012345678)::money;
SELECT (-9223372036854775808)::money;
SELECT 1234567890::int4::money;
SELECT 12345678901234567::int8::money;
SELECT (-1234567890)::int4::money;
SELECT (-12345678901234567)::int8::money;"
`;

exports[`kitchen sink upstream upstream/money.sql 2`] = `
"CREATE TABLE money_data (
m money
);
INSERT INTO money_data VALUES ('123');
SELECT * FROM money_data;
SELECT m + '123' FROM money_data;
SELECT m + '123.45' FROM money_data;
SELECT m - '123.45' FROM money_data;
SELECT m * 2 FROM money_data;
SELECT m / 2 FROM money_data;
SELECT m = '$123.00' FROM money_data;
SELECT m <> '$124.00' FROM money_data;
SELECT m <= '$123.00' FROM money_data;
SELECT m >= '$123.00' FROM money_data;
SELECT m < '$124.00' FROM money_data;
SELECT m > '$122.00' FROM money_data;
SELECT m = '$123.01' FROM money_data;
SELECT m <> '$123.00' FROM money_data;
SELECT m <= '$122.99' FROM money_data;
SELECT m >= '$123.01' FROM money_data;
SELECT m > '$124.00' FROM money_data;
SELECT m < '$122.00' FROM money_data;
SELECT cashlarger(m, '$124.00') FROM money_data;
SELECT cashsmaller(m, '$124.00') FROM money_data;
SELECT cash_words(m) FROM money_data;
SELECT cash_words(m + '1.23') FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.45');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.451');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.454');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.455');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.456');
SELECT * FROM money_data;
DELETE FROM money_data;
INSERT INTO money_data VALUES ('$123.459');
SELECT * FROM money_data;
SELECT 1234567890::money;
SELECT 12345678901234567::money;
SELECT 123456789012345678::money;
SELECT 9223372036854775807::money;
SELECT (-12345)::money;
SELECT (-1234567890)::money;
SELECT (-12345678901234567)::money;
SELECT (-123456789012345678)::money;
SELECT (-9223372036854775808)::money;
SELECT 1234567890::int4::money;
SELECT 12345678901234567::int8::money;
SELECT (-1234567890)::int4::money;
SELECT (-12345678901234567)::int8::money;"
`;

exports[`kitchen sink upstream upstream/numerology.sql 1`] = `
"CREATE TABLE temp_float (
f1 float8
);
INSERT INTO temp_float (f1) SELECT float8(f1) FROM int4_tbl;
INSERT INTO temp_float (f1) SELECT float8(f1) FROM int2_tbl;
SELECT '' AS ten,
f1 FROM temp_float ORDER BY f1;
CREATE TABLE temp_int4 (
f1 int4
);
INSERT INTO temp_int4 (f1) SELECT int4(f1) FROM float8_tbl WHERE f1 > (-2147483647) AND f1 < 2147483647;
INSERT INTO temp_int4 (f1) SELECT int4(f1) FROM int2_tbl;
SELECT '' AS nine,
f1 FROM temp_int4 ORDER BY f1;
CREATE TABLE temp_int2 (
f1 int2
);
INSERT INTO temp_int2 (f1) SELECT int2(f1) FROM float8_tbl WHERE f1 >= (-32767) AND f1 <= 32767;
INSERT INTO temp_int2 (f1) SELECT int2(f1) FROM int4_tbl WHERE f1 >= (-32767) AND f1 <= 32767;
SELECT '' AS five,
f1 FROM temp_int2 ORDER BY f1;
CREATE TABLE temp_group (
f1 int4,
f2 int4,
f3 float8
);
INSERT INTO temp_group SELECT 1,
-i.f1,
-f.f1 FROM int4_tbl AS i,
float8_tbl AS f;
INSERT INTO temp_group SELECT 2,
i.f1,
f.f1 FROM int4_tbl AS i,
float8_tbl AS f;
SELECT DISTINCT f1 AS two FROM temp_group ORDER BY 1;
SELECT f1 AS two,
max(f3) AS max_float,
min(f3) AS min_float FROM temp_group GROUP BY f1 ORDER BY two,
max_float,
min_float;
SELECT f1 AS two,
max(f3) AS max_float,
min(f3) AS min_float FROM temp_group GROUP BY two ORDER BY two,
max_float,
min_float;
SELECT f1 AS two,
max(f3) + 1 AS max_plus_1,
min(f3) - 1 AS min_minus_1 FROM temp_group GROUP BY f1 ORDER BY two,
min_minus_1;
SELECT f1 AS two,
max(f2) + min(f2) AS max_plus_min,
min(f3) - 1 AS min_minus_1 FROM temp_group GROUP BY f1 ORDER BY two,
min_minus_1;
DROP TABLE temp_int2;
DROP TABLE temp_int4;
DROP TABLE temp_float;
DROP TABLE temp_group;"
`;

exports[`kitchen sink upstream upstream/numerology.sql 2`] = `
"CREATE TABLE temp_float (
f1 float8
);
INSERT INTO temp_float ( f1 ) SELECT float8(f1) FROM int4_tbl;
INSERT INTO temp_float ( f1 ) SELECT float8(f1) FROM int2_tbl;
SELECT '' AS ten,
f1 FROM temp_float ORDER BY f1;
CREATE TABLE temp_int4 (
f1 int4
);
INSERT INTO temp_int4 ( f1 ) SELECT int4(f1) FROM float8_tbl WHERE f1 > (-2147483647) AND f1 < 2147483647;
INSERT INTO temp_int4 ( f1 ) SELECT int4(f1) FROM int2_tbl;
SELECT '' AS nine,
f1 FROM temp_int4 ORDER BY f1;
CREATE TABLE temp_int2 (
f1 int2
);
INSERT INTO temp_int2 ( f1 ) SELECT int2(f1) FROM float8_tbl WHERE f1 >= (-32767) AND f1 <= 32767;
INSERT INTO temp_int2 ( f1 ) SELECT int2(f1) FROM int4_tbl WHERE f1 >= (-32767) AND f1 <= 32767;
SELECT '' AS five,
f1 FROM temp_int2 ORDER BY f1;
CREATE TABLE temp_group (
f1 int4,
f2 int4,
f3 float8
);
INSERT INTO temp_group SELECT 1,
-i.f1,
-f.f1 FROM int4_tbl AS i,
float8_tbl AS f;
INSERT INTO temp_group SELECT 2,
i.f1,
f.f1 FROM int4_tbl AS i,
float8_tbl AS f;
SELECT DISTINCT f1 AS two FROM temp_group ORDER BY 1;
SELECT f1 AS two,
max(f3) AS max_float,
min(f3) AS min_float FROM temp_group GROUP BY f1 ORDER BY two,
max_float,
min_float;
SELECT f1 AS two,
max(f3) AS max_float,
min(f3) AS min_float FROM temp_group GROUP BY two ORDER BY two,
max_float,
min_float;
SELECT f1 AS two,
max(f3) + 1 AS max_plus_1,
min(f3) - 1 AS min_minus_1 FROM temp_group GROUP BY f1 ORDER BY two,
min_minus_1;
SELECT f1 AS two,
max(f2) + min(f2) AS max_plus_min,
min(f3) - 1 AS min_minus_1 FROM temp_group GROUP BY f1 ORDER BY two,
min_minus_1;
DROP TABLE temp_int2;
DROP TABLE temp_int4;
DROP TABLE temp_float;
DROP TABLE temp_group;"
`;

exports[`kitchen sink upstream upstream/oid.sql 1`] = `
"CREATE TABLE oid_tbl (
f1 oid
);
INSERT INTO oid_tbl (f1) VALUES ('1234');
INSERT INTO oid_tbl (f1) VALUES ('1235');
INSERT INTO oid_tbl (f1) VALUES ('987');
INSERT INTO oid_tbl (f1) VALUES ('-1040');
INSERT INTO oid_tbl (f1) VALUES ('99999999');
INSERT INTO oid_tbl (f1) VALUES ('5     ');
INSERT INTO oid_tbl (f1) VALUES ('   10  ');
INSERT INTO oid_tbl (f1) VALUES ('	  15 	  ');
INSERT INTO oid_tbl (f1) VALUES ('');
INSERT INTO oid_tbl (f1) VALUES ('    ');
INSERT INTO oid_tbl (f1) VALUES ('asdfasd');
INSERT INTO oid_tbl (f1) VALUES ('99asdfasd');
INSERT INTO oid_tbl (f1) VALUES ('5    d');
INSERT INTO oid_tbl (f1) VALUES ('    5d');
INSERT INTO oid_tbl (f1) VALUES ('5    5');
INSERT INTO oid_tbl (f1) VALUES (' - 500');
INSERT INTO oid_tbl (f1) VALUES ('32958209582039852935');
INSERT INTO oid_tbl (f1) VALUES ('-23582358720398502385');
SELECT '' AS six,
* FROM oid_tbl;
SELECT '' AS one,
o.* FROM oid_tbl AS o WHERE o.f1 = 1234;
SELECT '' AS five,
o.* FROM oid_tbl AS o WHERE o.f1 <> '1234';
SELECT '' AS three,
o.* FROM oid_tbl AS o WHERE o.f1 <= '1234';
SELECT '' AS two,
o.* FROM oid_tbl AS o WHERE o.f1 < '1234';
SELECT '' AS four,
o.* FROM oid_tbl AS o WHERE o.f1 >= '1234';
SELECT '' AS three,
o.* FROM oid_tbl AS o WHERE o.f1 > '1234';
DROP TABLE oid_tbl;"
`;

exports[`kitchen sink upstream upstream/oid.sql 2`] = `
"CREATE TABLE oid_tbl (
f1 oid
);
INSERT INTO oid_tbl ( f1 ) VALUES ('1234');
INSERT INTO oid_tbl ( f1 ) VALUES ('1235');
INSERT INTO oid_tbl ( f1 ) VALUES ('987');
INSERT INTO oid_tbl ( f1 ) VALUES ('-1040');
INSERT INTO oid_tbl ( f1 ) VALUES ('99999999');
INSERT INTO oid_tbl ( f1 ) VALUES ('5     ');
INSERT INTO oid_tbl ( f1 ) VALUES ('   10  ');
INSERT INTO oid_tbl ( f1 ) VALUES ('	  15 	  ');
INSERT INTO oid_tbl ( f1 ) VALUES ('');
INSERT INTO oid_tbl ( f1 ) VALUES ('    ');
INSERT INTO oid_tbl ( f1 ) VALUES ('asdfasd');
INSERT INTO oid_tbl ( f1 ) VALUES ('99asdfasd');
INSERT INTO oid_tbl ( f1 ) VALUES ('5    d');
INSERT INTO oid_tbl ( f1 ) VALUES ('    5d');
INSERT INTO oid_tbl ( f1 ) VALUES ('5    5');
INSERT INTO oid_tbl ( f1 ) VALUES (' - 500');
INSERT INTO oid_tbl ( f1 ) VALUES ('32958209582039852935');
INSERT INTO oid_tbl ( f1 ) VALUES ('-23582358720398502385');
SELECT '' AS six,
* FROM oid_tbl;
SELECT '' AS one,
o.* FROM oid_tbl AS o WHERE o.f1 = 1234;
SELECT '' AS five,
o.* FROM oid_tbl AS o WHERE o.f1 <> '1234';
SELECT '' AS three,
o.* FROM oid_tbl AS o WHERE o.f1 <= '1234';
SELECT '' AS two,
o.* FROM oid_tbl AS o WHERE o.f1 < '1234';
SELECT '' AS four,
o.* FROM oid_tbl AS o WHERE o.f1 >= '1234';
SELECT '' AS three,
o.* FROM oid_tbl AS o WHERE o.f1 > '1234';
DROP TABLE oid_tbl;"
`;

exports[`kitchen sink upstream upstream/oidjoins.sql 1`] = `
"SELECT ctid,
aggfnoid FROM pg_catalog.pg_aggregate AS fk WHERE aggfnoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggfnoid));
SELECT ctid,
aggtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggtransfn));
SELECT ctid,
aggfinalfn FROM pg_catalog.pg_aggregate AS fk WHERE aggfinalfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggfinalfn));
SELECT ctid,
aggmtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggmtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggmtransfn));
SELECT ctid,
aggminvtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggminvtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggminvtransfn));
SELECT ctid,
aggmfinalfn FROM pg_catalog.pg_aggregate AS fk WHERE aggmfinalfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggmfinalfn));
SELECT ctid,
aggsortop FROM pg_catalog.pg_aggregate AS fk WHERE aggsortop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.aggsortop));
SELECT ctid,
aggtranstype FROM pg_catalog.pg_aggregate AS fk WHERE aggtranstype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.aggtranstype));
SELECT ctid,
aggmtranstype FROM pg_catalog.pg_aggregate AS fk WHERE aggmtranstype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.aggmtranstype));
SELECT ctid,
amhandler FROM pg_catalog.pg_am AS fk WHERE amhandler <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.amhandler));
SELECT ctid,
amopfamily FROM pg_catalog.pg_amop AS fk WHERE amopfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amopfamily));
SELECT ctid,
amoplefttype FROM pg_catalog.pg_amop AS fk WHERE amoplefttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amoplefttype));
SELECT ctid,
amoprighttype FROM pg_catalog.pg_amop AS fk WHERE amoprighttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amoprighttype));
SELECT ctid,
amopopr FROM pg_catalog.pg_amop AS fk WHERE amopopr <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.amopopr));
SELECT ctid,
amopmethod FROM pg_catalog.pg_amop AS fk WHERE amopmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.amopmethod));
SELECT ctid,
amopsortfamily FROM pg_catalog.pg_amop AS fk WHERE amopsortfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amopsortfamily));
SELECT ctid,
amprocfamily FROM pg_catalog.pg_amproc AS fk WHERE amprocfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amprocfamily));
SELECT ctid,
amproclefttype FROM pg_catalog.pg_amproc AS fk WHERE amproclefttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amproclefttype));
SELECT ctid,
amprocrighttype FROM pg_catalog.pg_amproc AS fk WHERE amprocrighttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amprocrighttype));
SELECT ctid,
amproc FROM pg_catalog.pg_amproc AS fk WHERE amproc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.amproc));
SELECT ctid,
adrelid FROM pg_catalog.pg_attrdef AS fk WHERE adrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.adrelid));
SELECT ctid,
attrelid FROM pg_catalog.pg_attribute AS fk WHERE attrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.attrelid));
SELECT ctid,
atttypid FROM pg_catalog.pg_attribute AS fk WHERE atttypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.atttypid));
SELECT ctid,
attcollation FROM pg_catalog.pg_attribute AS fk WHERE attcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.attcollation));
SELECT ctid,
castsource FROM pg_catalog.pg_cast AS fk WHERE castsource <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.castsource));
SELECT ctid,
casttarget FROM pg_catalog.pg_cast AS fk WHERE casttarget <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.casttarget));
SELECT ctid,
castfunc FROM pg_catalog.pg_cast AS fk WHERE castfunc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.castfunc));
SELECT ctid,
relnamespace FROM pg_catalog.pg_class AS fk WHERE relnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.relnamespace));
SELECT ctid,
reltype FROM pg_catalog.pg_class AS fk WHERE reltype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.reltype));
SELECT ctid,
reloftype FROM pg_catalog.pg_class AS fk WHERE reloftype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.reloftype));
SELECT ctid,
relowner FROM pg_catalog.pg_class AS fk WHERE relowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.relowner));
SELECT ctid,
relam FROM pg_catalog.pg_class AS fk WHERE relam <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.relam));
SELECT ctid,
reltablespace FROM pg_catalog.pg_class AS fk WHERE reltablespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_tablespace AS pk WHERE pk.oid = fk.reltablespace));
SELECT ctid,
reltoastrelid FROM pg_catalog.pg_class AS fk WHERE reltoastrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.reltoastrelid));
SELECT ctid,
collnamespace FROM pg_catalog.pg_collation AS fk WHERE collnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.collnamespace));
SELECT ctid,
collowner FROM pg_catalog.pg_collation AS fk WHERE collowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.collowner));
SELECT ctid,
connamespace FROM pg_catalog.pg_constraint AS fk WHERE connamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.connamespace));
SELECT ctid,
conrelid FROM pg_catalog.pg_constraint AS fk WHERE conrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.conrelid));
SELECT ctid,
contypid FROM pg_catalog.pg_constraint AS fk WHERE contypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.contypid));
SELECT ctid,
conindid FROM pg_catalog.pg_constraint AS fk WHERE conindid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.conindid));
SELECT ctid,
confrelid FROM pg_catalog.pg_constraint AS fk WHERE confrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.confrelid));
SELECT ctid,
connamespace FROM pg_catalog.pg_conversion AS fk WHERE connamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.connamespace));
SELECT ctid,
conowner FROM pg_catalog.pg_conversion AS fk WHERE conowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.conowner));
SELECT ctid,
conproc FROM pg_catalog.pg_conversion AS fk WHERE conproc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.conproc));
SELECT ctid,
datdba FROM pg_catalog.pg_database AS fk WHERE datdba <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.datdba));
SELECT ctid,
dattablespace FROM pg_catalog.pg_database AS fk WHERE dattablespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_tablespace AS pk WHERE pk.oid = fk.dattablespace));
SELECT ctid,
setdatabase FROM pg_catalog.pg_db_role_setting AS fk WHERE setdatabase <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_database AS pk WHERE pk.oid = fk.setdatabase));
SELECT ctid,
classid FROM pg_catalog.pg_depend AS fk WHERE classid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classid));
SELECT ctid,
refclassid FROM pg_catalog.pg_depend AS fk WHERE refclassid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.refclassid));
SELECT ctid,
classoid FROM pg_catalog.pg_description AS fk WHERE classoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classoid));
SELECT ctid,
enumtypid FROM pg_catalog.pg_enum AS fk WHERE enumtypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.enumtypid));
SELECT ctid,
extowner FROM pg_catalog.pg_extension AS fk WHERE extowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.extowner));
SELECT ctid,
extnamespace FROM pg_catalog.pg_extension AS fk WHERE extnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.extnamespace));
SELECT ctid,
fdwowner FROM pg_catalog.pg_foreign_data_wrapper AS fk WHERE fdwowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.fdwowner));
SELECT ctid,
srvowner FROM pg_catalog.pg_foreign_server AS fk WHERE srvowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.srvowner));
SELECT ctid,
srvfdw FROM pg_catalog.pg_foreign_server AS fk WHERE srvfdw <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_foreign_data_wrapper AS pk WHERE pk.oid = fk.srvfdw));
SELECT ctid,
indexrelid FROM pg_catalog.pg_index AS fk WHERE indexrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.indexrelid));
SELECT ctid,
indrelid FROM pg_catalog.pg_index AS fk WHERE indrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.indrelid));
SELECT ctid,
inhrelid FROM pg_catalog.pg_inherits AS fk WHERE inhrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.inhrelid));
SELECT ctid,
inhparent FROM pg_catalog.pg_inherits AS fk WHERE inhparent <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.inhparent));
SELECT ctid,
lanowner FROM pg_catalog.pg_language AS fk WHERE lanowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.lanowner));
SELECT ctid,
lanplcallfoid FROM pg_catalog.pg_language AS fk WHERE lanplcallfoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.lanplcallfoid));
SELECT ctid,
laninline FROM pg_catalog.pg_language AS fk WHERE laninline <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.laninline));
SELECT ctid,
lanvalidator FROM pg_catalog.pg_language AS fk WHERE lanvalidator <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.lanvalidator));
SELECT ctid,
loid FROM pg_catalog.pg_largeobject AS fk WHERE loid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_largeobject_metadata AS pk WHERE pk.oid = fk.loid));
SELECT ctid,
lomowner FROM pg_catalog.pg_largeobject_metadata AS fk WHERE lomowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.lomowner));
SELECT ctid,
nspowner FROM pg_catalog.pg_namespace AS fk WHERE nspowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.nspowner));
SELECT ctid,
opcmethod FROM pg_catalog.pg_opclass AS fk WHERE opcmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.opcmethod));
SELECT ctid,
opcnamespace FROM pg_catalog.pg_opclass AS fk WHERE opcnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.opcnamespace));
SELECT ctid,
opcowner FROM pg_catalog.pg_opclass AS fk WHERE opcowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.opcowner));
SELECT ctid,
opcfamily FROM pg_catalog.pg_opclass AS fk WHERE opcfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.opcfamily));
SELECT ctid,
opcintype FROM pg_catalog.pg_opclass AS fk WHERE opcintype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.opcintype));
SELECT ctid,
opckeytype FROM pg_catalog.pg_opclass AS fk WHERE opckeytype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.opckeytype));
SELECT ctid,
oprnamespace FROM pg_catalog.pg_operator AS fk WHERE oprnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.oprnamespace));
SELECT ctid,
oprowner FROM pg_catalog.pg_operator AS fk WHERE oprowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.oprowner));
SELECT ctid,
oprleft FROM pg_catalog.pg_operator AS fk WHERE oprleft <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprleft));
SELECT ctid,
oprright FROM pg_catalog.pg_operator AS fk WHERE oprright <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprright));
SELECT ctid,
oprresult FROM pg_catalog.pg_operator AS fk WHERE oprresult <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprresult));
SELECT ctid,
oprcom FROM pg_catalog.pg_operator AS fk WHERE oprcom <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.oprcom));
SELECT ctid,
oprnegate FROM pg_catalog.pg_operator AS fk WHERE oprnegate <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.oprnegate));
SELECT ctid,
oprcode FROM pg_catalog.pg_operator AS fk WHERE oprcode <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprcode));
SELECT ctid,
oprrest FROM pg_catalog.pg_operator AS fk WHERE oprrest <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprrest));
SELECT ctid,
oprjoin FROM pg_catalog.pg_operator AS fk WHERE oprjoin <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprjoin));
SELECT ctid,
opfmethod FROM pg_catalog.pg_opfamily AS fk WHERE opfmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.opfmethod));
SELECT ctid,
opfnamespace FROM pg_catalog.pg_opfamily AS fk WHERE opfnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.opfnamespace));
SELECT ctid,
opfowner FROM pg_catalog.pg_opfamily AS fk WHERE opfowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.opfowner));
SELECT ctid,
polrelid FROM pg_catalog.pg_policy AS fk WHERE polrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.polrelid));
SELECT ctid,
pronamespace FROM pg_catalog.pg_proc AS fk WHERE pronamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.pronamespace));
SELECT ctid,
proowner FROM pg_catalog.pg_proc AS fk WHERE proowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.proowner));
SELECT ctid,
prolang FROM pg_catalog.pg_proc AS fk WHERE prolang <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_language AS pk WHERE pk.oid = fk.prolang));
SELECT ctid,
provariadic FROM pg_catalog.pg_proc AS fk WHERE provariadic <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.provariadic));
SELECT ctid,
protransform FROM pg_catalog.pg_proc AS fk WHERE protransform <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.protransform));
SELECT ctid,
prorettype FROM pg_catalog.pg_proc AS fk WHERE prorettype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.prorettype));
SELECT ctid,
rngtypid FROM pg_catalog.pg_range AS fk WHERE rngtypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.rngtypid));
SELECT ctid,
rngsubtype FROM pg_catalog.pg_range AS fk WHERE rngsubtype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.rngsubtype));
SELECT ctid,
rngcollation FROM pg_catalog.pg_range AS fk WHERE rngcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.rngcollation));
SELECT ctid,
rngsubopc FROM pg_catalog.pg_range AS fk WHERE rngsubopc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opclass AS pk WHERE pk.oid = fk.rngsubopc));
SELECT ctid,
rngcanonical FROM pg_catalog.pg_range AS fk WHERE rngcanonical <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.rngcanonical));
SELECT ctid,
rngsubdiff FROM pg_catalog.pg_range AS fk WHERE rngsubdiff <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.rngsubdiff));
SELECT ctid,
ev_class FROM pg_catalog.pg_rewrite AS fk WHERE ev_class <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.ev_class));
SELECT ctid,
refclassid FROM pg_catalog.pg_shdepend AS fk WHERE refclassid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.refclassid));
SELECT ctid,
classoid FROM pg_catalog.pg_shdescription AS fk WHERE classoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classoid));
SELECT ctid,
starelid FROM pg_catalog.pg_statistic AS fk WHERE starelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.starelid));
SELECT ctid,
staop1 FROM pg_catalog.pg_statistic AS fk WHERE staop1 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop1));
SELECT ctid,
staop2 FROM pg_catalog.pg_statistic AS fk WHERE staop2 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop2));
SELECT ctid,
staop3 FROM pg_catalog.pg_statistic AS fk WHERE staop3 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop3));
SELECT ctid,
staop4 FROM pg_catalog.pg_statistic AS fk WHERE staop4 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop4));
SELECT ctid,
staop5 FROM pg_catalog.pg_statistic AS fk WHERE staop5 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop5));
SELECT ctid,
spcowner FROM pg_catalog.pg_tablespace AS fk WHERE spcowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.spcowner));
SELECT ctid,
trftype FROM pg_catalog.pg_transform AS fk WHERE trftype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.trftype));
SELECT ctid,
trflang FROM pg_catalog.pg_transform AS fk WHERE trflang <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_language AS pk WHERE pk.oid = fk.trflang));
SELECT ctid,
trffromsql FROM pg_catalog.pg_transform AS fk WHERE trffromsql <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.trffromsql));
SELECT ctid,
trftosql FROM pg_catalog.pg_transform AS fk WHERE trftosql <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.trftosql));
SELECT ctid,
tgrelid FROM pg_catalog.pg_trigger AS fk WHERE tgrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgrelid));
SELECT ctid,
tgfoid FROM pg_catalog.pg_trigger AS fk WHERE tgfoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tgfoid));
SELECT ctid,
tgconstrrelid FROM pg_catalog.pg_trigger AS fk WHERE tgconstrrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgconstrrelid));
SELECT ctid,
tgconstrindid FROM pg_catalog.pg_trigger AS fk WHERE tgconstrindid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgconstrindid));
SELECT ctid,
tgconstraint FROM pg_catalog.pg_trigger AS fk WHERE tgconstraint <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_constraint AS pk WHERE pk.oid = fk.tgconstraint));
SELECT ctid,
cfgnamespace FROM pg_catalog.pg_ts_config AS fk WHERE cfgnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.cfgnamespace));
SELECT ctid,
cfgowner FROM pg_catalog.pg_ts_config AS fk WHERE cfgowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.cfgowner));
SELECT ctid,
cfgparser FROM pg_catalog.pg_ts_config AS fk WHERE cfgparser <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_parser AS pk WHERE pk.oid = fk.cfgparser));
SELECT ctid,
mapcfg FROM pg_catalog.pg_ts_config_map AS fk WHERE mapcfg <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_config AS pk WHERE pk.oid = fk.mapcfg));
SELECT ctid,
mapdict FROM pg_catalog.pg_ts_config_map AS fk WHERE mapdict <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_dict AS pk WHERE pk.oid = fk.mapdict));
SELECT ctid,
dictnamespace FROM pg_catalog.pg_ts_dict AS fk WHERE dictnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.dictnamespace));
SELECT ctid,
dictowner FROM pg_catalog.pg_ts_dict AS fk WHERE dictowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.dictowner));
SELECT ctid,
dicttemplate FROM pg_catalog.pg_ts_dict AS fk WHERE dicttemplate <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_template AS pk WHERE pk.oid = fk.dicttemplate));
SELECT ctid,
prsnamespace FROM pg_catalog.pg_ts_parser AS fk WHERE prsnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.prsnamespace));
SELECT ctid,
prsstart FROM pg_catalog.pg_ts_parser AS fk WHERE prsstart <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsstart));
SELECT ctid,
prstoken FROM pg_catalog.pg_ts_parser AS fk WHERE prstoken <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prstoken));
SELECT ctid,
prsend FROM pg_catalog.pg_ts_parser AS fk WHERE prsend <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsend));
SELECT ctid,
prsheadline FROM pg_catalog.pg_ts_parser AS fk WHERE prsheadline <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsheadline));
SELECT ctid,
prslextype FROM pg_catalog.pg_ts_parser AS fk WHERE prslextype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prslextype));
SELECT ctid,
tmplnamespace FROM pg_catalog.pg_ts_template AS fk WHERE tmplnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.tmplnamespace));
SELECT ctid,
tmplinit FROM pg_catalog.pg_ts_template AS fk WHERE tmplinit <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tmplinit));
SELECT ctid,
tmpllexize FROM pg_catalog.pg_ts_template AS fk WHERE tmpllexize <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tmpllexize));
SELECT ctid,
typnamespace FROM pg_catalog.pg_type AS fk WHERE typnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.typnamespace));
SELECT ctid,
typowner FROM pg_catalog.pg_type AS fk WHERE typowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.typowner));
SELECT ctid,
typrelid FROM pg_catalog.pg_type AS fk WHERE typrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.typrelid));
SELECT ctid,
typelem FROM pg_catalog.pg_type AS fk WHERE typelem <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typelem));
SELECT ctid,
typarray FROM pg_catalog.pg_type AS fk WHERE typarray <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typarray));
SELECT ctid,
typinput FROM pg_catalog.pg_type AS fk WHERE typinput <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typinput));
SELECT ctid,
typoutput FROM pg_catalog.pg_type AS fk WHERE typoutput <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typoutput));
SELECT ctid,
typreceive FROM pg_catalog.pg_type AS fk WHERE typreceive <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typreceive));
SELECT ctid,
typsend FROM pg_catalog.pg_type AS fk WHERE typsend <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typsend));
SELECT ctid,
typmodin FROM pg_catalog.pg_type AS fk WHERE typmodin <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typmodin));
SELECT ctid,
typmodout FROM pg_catalog.pg_type AS fk WHERE typmodout <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typmodout));
SELECT ctid,
typanalyze FROM pg_catalog.pg_type AS fk WHERE typanalyze <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typanalyze));
SELECT ctid,
typbasetype FROM pg_catalog.pg_type AS fk WHERE typbasetype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typbasetype));
SELECT ctid,
typcollation FROM pg_catalog.pg_type AS fk WHERE typcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.typcollation));
SELECT ctid,
conpfeqop FROM (SELECT ctid,
unnest(conpfeqop) AS conpfeqop FROM pg_catalog.pg_constraint) AS fk WHERE conpfeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conpfeqop));
SELECT ctid,
conppeqop FROM (SELECT ctid,
unnest(conppeqop) AS conppeqop FROM pg_catalog.pg_constraint) AS fk WHERE conppeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conppeqop));
SELECT ctid,
conffeqop FROM (SELECT ctid,
unnest(conffeqop) AS conffeqop FROM pg_catalog.pg_constraint) AS fk WHERE conffeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conffeqop));
SELECT ctid,
conexclop FROM (SELECT ctid,
unnest(conexclop) AS conexclop FROM pg_catalog.pg_constraint) AS fk WHERE conexclop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conexclop));
SELECT ctid,
proallargtypes FROM (SELECT ctid,
unnest(proallargtypes) AS proallargtypes FROM pg_catalog.pg_proc) AS fk WHERE proallargtypes <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.proallargtypes));"
`;

exports[`kitchen sink upstream upstream/oidjoins.sql 2`] = `
"SELECT ctid,
aggfnoid FROM pg_catalog.pg_aggregate AS fk WHERE aggfnoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggfnoid));
SELECT ctid,
aggtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggtransfn));
SELECT ctid,
aggfinalfn FROM pg_catalog.pg_aggregate AS fk WHERE aggfinalfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggfinalfn));
SELECT ctid,
aggmtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggmtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggmtransfn));
SELECT ctid,
aggminvtransfn FROM pg_catalog.pg_aggregate AS fk WHERE aggminvtransfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggminvtransfn));
SELECT ctid,
aggmfinalfn FROM pg_catalog.pg_aggregate AS fk WHERE aggmfinalfn <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.aggmfinalfn));
SELECT ctid,
aggsortop FROM pg_catalog.pg_aggregate AS fk WHERE aggsortop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.aggsortop));
SELECT ctid,
aggtranstype FROM pg_catalog.pg_aggregate AS fk WHERE aggtranstype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.aggtranstype));
SELECT ctid,
aggmtranstype FROM pg_catalog.pg_aggregate AS fk WHERE aggmtranstype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.aggmtranstype));
SELECT ctid,
amhandler FROM pg_catalog.pg_am AS fk WHERE amhandler <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.amhandler));
SELECT ctid,
amopfamily FROM pg_catalog.pg_amop AS fk WHERE amopfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amopfamily));
SELECT ctid,
amoplefttype FROM pg_catalog.pg_amop AS fk WHERE amoplefttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amoplefttype));
SELECT ctid,
amoprighttype FROM pg_catalog.pg_amop AS fk WHERE amoprighttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amoprighttype));
SELECT ctid,
amopopr FROM pg_catalog.pg_amop AS fk WHERE amopopr <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.amopopr));
SELECT ctid,
amopmethod FROM pg_catalog.pg_amop AS fk WHERE amopmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.amopmethod));
SELECT ctid,
amopsortfamily FROM pg_catalog.pg_amop AS fk WHERE amopsortfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amopsortfamily));
SELECT ctid,
amprocfamily FROM pg_catalog.pg_amproc AS fk WHERE amprocfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.amprocfamily));
SELECT ctid,
amproclefttype FROM pg_catalog.pg_amproc AS fk WHERE amproclefttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amproclefttype));
SELECT ctid,
amprocrighttype FROM pg_catalog.pg_amproc AS fk WHERE amprocrighttype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.amprocrighttype));
SELECT ctid,
amproc FROM pg_catalog.pg_amproc AS fk WHERE amproc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.amproc));
SELECT ctid,
adrelid FROM pg_catalog.pg_attrdef AS fk WHERE adrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.adrelid));
SELECT ctid,
attrelid FROM pg_catalog.pg_attribute AS fk WHERE attrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.attrelid));
SELECT ctid,
atttypid FROM pg_catalog.pg_attribute AS fk WHERE atttypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.atttypid));
SELECT ctid,
attcollation FROM pg_catalog.pg_attribute AS fk WHERE attcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.attcollation));
SELECT ctid,
castsource FROM pg_catalog.pg_cast AS fk WHERE castsource <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.castsource));
SELECT ctid,
casttarget FROM pg_catalog.pg_cast AS fk WHERE casttarget <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.casttarget));
SELECT ctid,
castfunc FROM pg_catalog.pg_cast AS fk WHERE castfunc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.castfunc));
SELECT ctid,
relnamespace FROM pg_catalog.pg_class AS fk WHERE relnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.relnamespace));
SELECT ctid,
reltype FROM pg_catalog.pg_class AS fk WHERE reltype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.reltype));
SELECT ctid,
reloftype FROM pg_catalog.pg_class AS fk WHERE reloftype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.reloftype));
SELECT ctid,
relowner FROM pg_catalog.pg_class AS fk WHERE relowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.relowner));
SELECT ctid,
relam FROM pg_catalog.pg_class AS fk WHERE relam <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.relam));
SELECT ctid,
reltablespace FROM pg_catalog.pg_class AS fk WHERE reltablespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_tablespace AS pk WHERE pk.oid = fk.reltablespace));
SELECT ctid,
reltoastrelid FROM pg_catalog.pg_class AS fk WHERE reltoastrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.reltoastrelid));
SELECT ctid,
collnamespace FROM pg_catalog.pg_collation AS fk WHERE collnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.collnamespace));
SELECT ctid,
collowner FROM pg_catalog.pg_collation AS fk WHERE collowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.collowner));
SELECT ctid,
connamespace FROM pg_catalog.pg_constraint AS fk WHERE connamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.connamespace));
SELECT ctid,
conrelid FROM pg_catalog.pg_constraint AS fk WHERE conrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.conrelid));
SELECT ctid,
contypid FROM pg_catalog.pg_constraint AS fk WHERE contypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.contypid));
SELECT ctid,
conindid FROM pg_catalog.pg_constraint AS fk WHERE conindid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.conindid));
SELECT ctid,
confrelid FROM pg_catalog.pg_constraint AS fk WHERE confrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.confrelid));
SELECT ctid,
connamespace FROM pg_catalog.pg_conversion AS fk WHERE connamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.connamespace));
SELECT ctid,
conowner FROM pg_catalog.pg_conversion AS fk WHERE conowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.conowner));
SELECT ctid,
conproc FROM pg_catalog.pg_conversion AS fk WHERE conproc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.conproc));
SELECT ctid,
datdba FROM pg_catalog.pg_database AS fk WHERE datdba <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.datdba));
SELECT ctid,
dattablespace FROM pg_catalog.pg_database AS fk WHERE dattablespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_tablespace AS pk WHERE pk.oid = fk.dattablespace));
SELECT ctid,
setdatabase FROM pg_catalog.pg_db_role_setting AS fk WHERE setdatabase <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_database AS pk WHERE pk.oid = fk.setdatabase));
SELECT ctid,
classid FROM pg_catalog.pg_depend AS fk WHERE classid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classid));
SELECT ctid,
refclassid FROM pg_catalog.pg_depend AS fk WHERE refclassid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.refclassid));
SELECT ctid,
classoid FROM pg_catalog.pg_description AS fk WHERE classoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classoid));
SELECT ctid,
enumtypid FROM pg_catalog.pg_enum AS fk WHERE enumtypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.enumtypid));
SELECT ctid,
extowner FROM pg_catalog.pg_extension AS fk WHERE extowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.extowner));
SELECT ctid,
extnamespace FROM pg_catalog.pg_extension AS fk WHERE extnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.extnamespace));
SELECT ctid,
fdwowner FROM pg_catalog.pg_foreign_data_wrapper AS fk WHERE fdwowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.fdwowner));
SELECT ctid,
srvowner FROM pg_catalog.pg_foreign_server AS fk WHERE srvowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.srvowner));
SELECT ctid,
srvfdw FROM pg_catalog.pg_foreign_server AS fk WHERE srvfdw <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_foreign_data_wrapper AS pk WHERE pk.oid = fk.srvfdw));
SELECT ctid,
indexrelid FROM pg_catalog.pg_index AS fk WHERE indexrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.indexrelid));
SELECT ctid,
indrelid FROM pg_catalog.pg_index AS fk WHERE indrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.indrelid));
SELECT ctid,
inhrelid FROM pg_catalog.pg_inherits AS fk WHERE inhrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.inhrelid));
SELECT ctid,
inhparent FROM pg_catalog.pg_inherits AS fk WHERE inhparent <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.inhparent));
SELECT ctid,
lanowner FROM pg_catalog.pg_language AS fk WHERE lanowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.lanowner));
SELECT ctid,
lanplcallfoid FROM pg_catalog.pg_language AS fk WHERE lanplcallfoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.lanplcallfoid));
SELECT ctid,
laninline FROM pg_catalog.pg_language AS fk WHERE laninline <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.laninline));
SELECT ctid,
lanvalidator FROM pg_catalog.pg_language AS fk WHERE lanvalidator <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.lanvalidator));
SELECT ctid,
loid FROM pg_catalog.pg_largeobject AS fk WHERE loid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_largeobject_metadata AS pk WHERE pk.oid = fk.loid));
SELECT ctid,
lomowner FROM pg_catalog.pg_largeobject_metadata AS fk WHERE lomowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.lomowner));
SELECT ctid,
nspowner FROM pg_catalog.pg_namespace AS fk WHERE nspowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.nspowner));
SELECT ctid,
opcmethod FROM pg_catalog.pg_opclass AS fk WHERE opcmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.opcmethod));
SELECT ctid,
opcnamespace FROM pg_catalog.pg_opclass AS fk WHERE opcnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.opcnamespace));
SELECT ctid,
opcowner FROM pg_catalog.pg_opclass AS fk WHERE opcowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.opcowner));
SELECT ctid,
opcfamily FROM pg_catalog.pg_opclass AS fk WHERE opcfamily <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opfamily AS pk WHERE pk.oid = fk.opcfamily));
SELECT ctid,
opcintype FROM pg_catalog.pg_opclass AS fk WHERE opcintype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.opcintype));
SELECT ctid,
opckeytype FROM pg_catalog.pg_opclass AS fk WHERE opckeytype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.opckeytype));
SELECT ctid,
oprnamespace FROM pg_catalog.pg_operator AS fk WHERE oprnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.oprnamespace));
SELECT ctid,
oprowner FROM pg_catalog.pg_operator AS fk WHERE oprowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.oprowner));
SELECT ctid,
oprleft FROM pg_catalog.pg_operator AS fk WHERE oprleft <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprleft));
SELECT ctid,
oprright FROM pg_catalog.pg_operator AS fk WHERE oprright <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprright));
SELECT ctid,
oprresult FROM pg_catalog.pg_operator AS fk WHERE oprresult <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.oprresult));
SELECT ctid,
oprcom FROM pg_catalog.pg_operator AS fk WHERE oprcom <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.oprcom));
SELECT ctid,
oprnegate FROM pg_catalog.pg_operator AS fk WHERE oprnegate <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.oprnegate));
SELECT ctid,
oprcode FROM pg_catalog.pg_operator AS fk WHERE oprcode <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprcode));
SELECT ctid,
oprrest FROM pg_catalog.pg_operator AS fk WHERE oprrest <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprrest));
SELECT ctid,
oprjoin FROM pg_catalog.pg_operator AS fk WHERE oprjoin <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.oprjoin));
SELECT ctid,
opfmethod FROM pg_catalog.pg_opfamily AS fk WHERE opfmethod <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_am AS pk WHERE pk.oid = fk.opfmethod));
SELECT ctid,
opfnamespace FROM pg_catalog.pg_opfamily AS fk WHERE opfnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.opfnamespace));
SELECT ctid,
opfowner FROM pg_catalog.pg_opfamily AS fk WHERE opfowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.opfowner));
SELECT ctid,
polrelid FROM pg_catalog.pg_policy AS fk WHERE polrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.polrelid));
SELECT ctid,
pronamespace FROM pg_catalog.pg_proc AS fk WHERE pronamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.pronamespace));
SELECT ctid,
proowner FROM pg_catalog.pg_proc AS fk WHERE proowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.proowner));
SELECT ctid,
prolang FROM pg_catalog.pg_proc AS fk WHERE prolang <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_language AS pk WHERE pk.oid = fk.prolang));
SELECT ctid,
provariadic FROM pg_catalog.pg_proc AS fk WHERE provariadic <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.provariadic));
SELECT ctid,
protransform FROM pg_catalog.pg_proc AS fk WHERE protransform <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.protransform));
SELECT ctid,
prorettype FROM pg_catalog.pg_proc AS fk WHERE prorettype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.prorettype));
SELECT ctid,
rngtypid FROM pg_catalog.pg_range AS fk WHERE rngtypid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.rngtypid));
SELECT ctid,
rngsubtype FROM pg_catalog.pg_range AS fk WHERE rngsubtype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.rngsubtype));
SELECT ctid,
rngcollation FROM pg_catalog.pg_range AS fk WHERE rngcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.rngcollation));
SELECT ctid,
rngsubopc FROM pg_catalog.pg_range AS fk WHERE rngsubopc <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_opclass AS pk WHERE pk.oid = fk.rngsubopc));
SELECT ctid,
rngcanonical FROM pg_catalog.pg_range AS fk WHERE rngcanonical <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.rngcanonical));
SELECT ctid,
rngsubdiff FROM pg_catalog.pg_range AS fk WHERE rngsubdiff <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.rngsubdiff));
SELECT ctid,
ev_class FROM pg_catalog.pg_rewrite AS fk WHERE ev_class <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.ev_class));
SELECT ctid,
refclassid FROM pg_catalog.pg_shdepend AS fk WHERE refclassid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.refclassid));
SELECT ctid,
classoid FROM pg_catalog.pg_shdescription AS fk WHERE classoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.classoid));
SELECT ctid,
starelid FROM pg_catalog.pg_statistic AS fk WHERE starelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.starelid));
SELECT ctid,
staop1 FROM pg_catalog.pg_statistic AS fk WHERE staop1 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop1));
SELECT ctid,
staop2 FROM pg_catalog.pg_statistic AS fk WHERE staop2 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop2));
SELECT ctid,
staop3 FROM pg_catalog.pg_statistic AS fk WHERE staop3 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop3));
SELECT ctid,
staop4 FROM pg_catalog.pg_statistic AS fk WHERE staop4 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop4));
SELECT ctid,
staop5 FROM pg_catalog.pg_statistic AS fk WHERE staop5 <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.staop5));
SELECT ctid,
spcowner FROM pg_catalog.pg_tablespace AS fk WHERE spcowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.spcowner));
SELECT ctid,
trftype FROM pg_catalog.pg_transform AS fk WHERE trftype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.trftype));
SELECT ctid,
trflang FROM pg_catalog.pg_transform AS fk WHERE trflang <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_language AS pk WHERE pk.oid = fk.trflang));
SELECT ctid,
trffromsql FROM pg_catalog.pg_transform AS fk WHERE trffromsql <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.trffromsql));
SELECT ctid,
trftosql FROM pg_catalog.pg_transform AS fk WHERE trftosql <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.trftosql));
SELECT ctid,
tgrelid FROM pg_catalog.pg_trigger AS fk WHERE tgrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgrelid));
SELECT ctid,
tgfoid FROM pg_catalog.pg_trigger AS fk WHERE tgfoid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tgfoid));
SELECT ctid,
tgconstrrelid FROM pg_catalog.pg_trigger AS fk WHERE tgconstrrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgconstrrelid));
SELECT ctid,
tgconstrindid FROM pg_catalog.pg_trigger AS fk WHERE tgconstrindid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.tgconstrindid));
SELECT ctid,
tgconstraint FROM pg_catalog.pg_trigger AS fk WHERE tgconstraint <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_constraint AS pk WHERE pk.oid = fk.tgconstraint));
SELECT ctid,
cfgnamespace FROM pg_catalog.pg_ts_config AS fk WHERE cfgnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.cfgnamespace));
SELECT ctid,
cfgowner FROM pg_catalog.pg_ts_config AS fk WHERE cfgowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.cfgowner));
SELECT ctid,
cfgparser FROM pg_catalog.pg_ts_config AS fk WHERE cfgparser <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_parser AS pk WHERE pk.oid = fk.cfgparser));
SELECT ctid,
mapcfg FROM pg_catalog.pg_ts_config_map AS fk WHERE mapcfg <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_config AS pk WHERE pk.oid = fk.mapcfg));
SELECT ctid,
mapdict FROM pg_catalog.pg_ts_config_map AS fk WHERE mapdict <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_dict AS pk WHERE pk.oid = fk.mapdict));
SELECT ctid,
dictnamespace FROM pg_catalog.pg_ts_dict AS fk WHERE dictnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.dictnamespace));
SELECT ctid,
dictowner FROM pg_catalog.pg_ts_dict AS fk WHERE dictowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.dictowner));
SELECT ctid,
dicttemplate FROM pg_catalog.pg_ts_dict AS fk WHERE dicttemplate <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_ts_template AS pk WHERE pk.oid = fk.dicttemplate));
SELECT ctid,
prsnamespace FROM pg_catalog.pg_ts_parser AS fk WHERE prsnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.prsnamespace));
SELECT ctid,
prsstart FROM pg_catalog.pg_ts_parser AS fk WHERE prsstart <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsstart));
SELECT ctid,
prstoken FROM pg_catalog.pg_ts_parser AS fk WHERE prstoken <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prstoken));
SELECT ctid,
prsend FROM pg_catalog.pg_ts_parser AS fk WHERE prsend <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsend));
SELECT ctid,
prsheadline FROM pg_catalog.pg_ts_parser AS fk WHERE prsheadline <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prsheadline));
SELECT ctid,
prslextype FROM pg_catalog.pg_ts_parser AS fk WHERE prslextype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.prslextype));
SELECT ctid,
tmplnamespace FROM pg_catalog.pg_ts_template AS fk WHERE tmplnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.tmplnamespace));
SELECT ctid,
tmplinit FROM pg_catalog.pg_ts_template AS fk WHERE tmplinit <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tmplinit));
SELECT ctid,
tmpllexize FROM pg_catalog.pg_ts_template AS fk WHERE tmpllexize <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.tmpllexize));
SELECT ctid,
typnamespace FROM pg_catalog.pg_type AS fk WHERE typnamespace <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_namespace AS pk WHERE pk.oid = fk.typnamespace));
SELECT ctid,
typowner FROM pg_catalog.pg_type AS fk WHERE typowner <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_authid AS pk WHERE pk.oid = fk.typowner));
SELECT ctid,
typrelid FROM pg_catalog.pg_type AS fk WHERE typrelid <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_class AS pk WHERE pk.oid = fk.typrelid));
SELECT ctid,
typelem FROM pg_catalog.pg_type AS fk WHERE typelem <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typelem));
SELECT ctid,
typarray FROM pg_catalog.pg_type AS fk WHERE typarray <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typarray));
SELECT ctid,
typinput FROM pg_catalog.pg_type AS fk WHERE typinput <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typinput));
SELECT ctid,
typoutput FROM pg_catalog.pg_type AS fk WHERE typoutput <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typoutput));
SELECT ctid,
typreceive FROM pg_catalog.pg_type AS fk WHERE typreceive <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typreceive));
SELECT ctid,
typsend FROM pg_catalog.pg_type AS fk WHERE typsend <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typsend));
SELECT ctid,
typmodin FROM pg_catalog.pg_type AS fk WHERE typmodin <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typmodin));
SELECT ctid,
typmodout FROM pg_catalog.pg_type AS fk WHERE typmodout <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typmodout));
SELECT ctid,
typanalyze FROM pg_catalog.pg_type AS fk WHERE typanalyze <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_proc AS pk WHERE pk.oid = fk.typanalyze));
SELECT ctid,
typbasetype FROM pg_catalog.pg_type AS fk WHERE typbasetype <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.typbasetype));
SELECT ctid,
typcollation FROM pg_catalog.pg_type AS fk WHERE typcollation <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_collation AS pk WHERE pk.oid = fk.typcollation));
SELECT ctid,
conpfeqop FROM (SELECT ctid,
unnest(conpfeqop) AS conpfeqop FROM pg_catalog.pg_constraint) AS fk WHERE conpfeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conpfeqop));
SELECT ctid,
conppeqop FROM (SELECT ctid,
unnest(conppeqop) AS conppeqop FROM pg_catalog.pg_constraint) AS fk WHERE conppeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conppeqop));
SELECT ctid,
conffeqop FROM (SELECT ctid,
unnest(conffeqop) AS conffeqop FROM pg_catalog.pg_constraint) AS fk WHERE conffeqop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conffeqop));
SELECT ctid,
conexclop FROM (SELECT ctid,
unnest(conexclop) AS conexclop FROM pg_catalog.pg_constraint) AS fk WHERE conexclop <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_operator AS pk WHERE pk.oid = fk.conexclop));
SELECT ctid,
proallargtypes FROM (SELECT ctid,
unnest(proallargtypes) AS proallargtypes FROM pg_catalog.pg_proc) AS fk WHERE proallargtypes <> 0 AND NOT (EXISTS (SELECT 1 FROM pg_catalog.pg_type AS pk WHERE pk.oid = fk.proallargtypes));"
`;

exports[`kitchen sink upstream upstream/path.sql 1`] = `
"CREATE TABLE path_tbl (
f1 path
);
INSERT INTO path_tbl VALUES ('[(1,2),(3,4)]');
INSERT INTO path_tbl VALUES ('((1,2),(3,4))');
INSERT INTO path_tbl VALUES ('[(0,0),(3,0),(4,5),(1,6)]');
INSERT INTO path_tbl VALUES ('((1,2),(3,4))');
INSERT INTO path_tbl VALUES ('1,2 ,3,4');
INSERT INTO path_tbl VALUES ('[1,2,3, 4]');
INSERT INTO path_tbl VALUES ('[11,12,13,14]');
INSERT INTO path_tbl VALUES ('(11,12,13,14)');
INSERT INTO path_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO path_tbl VALUES ('[(1,2),(3,4)');
SELECT f1 FROM path_tbl;
SELECT '' AS count,
f1 AS open_path FROM path_tbl WHERE isopen(f1);
SELECT '' AS count,
f1 AS closed_path FROM path_tbl WHERE isclosed(f1);
SELECT '' AS count,
pclose(f1) AS closed_path FROM path_tbl;
SELECT '' AS count,
popen(f1) AS open_path FROM path_tbl;"
`;

exports[`kitchen sink upstream upstream/path.sql 2`] = `
"CREATE TABLE path_tbl (
f1 path
);
INSERT INTO path_tbl VALUES ('[(1,2),(3,4)]');
INSERT INTO path_tbl VALUES ('((1,2),(3,4))');
INSERT INTO path_tbl VALUES ('[(0,0),(3,0),(4,5),(1,6)]');
INSERT INTO path_tbl VALUES ('((1,2),(3,4))');
INSERT INTO path_tbl VALUES ('1,2 ,3,4');
INSERT INTO path_tbl VALUES ('[1,2,3, 4]');
INSERT INTO path_tbl VALUES ('[11,12,13,14]');
INSERT INTO path_tbl VALUES ('(11,12,13,14)');
INSERT INTO path_tbl VALUES ('[(,2),(3,4)]');
INSERT INTO path_tbl VALUES ('[(1,2),(3,4)');
SELECT f1 FROM path_tbl;
SELECT '' AS count,
f1 AS open_path FROM path_tbl WHERE isopen(f1);
SELECT '' AS count,
f1 AS closed_path FROM path_tbl WHERE isclosed(f1);
SELECT '' AS count,
pclose(f1) AS closed_path FROM path_tbl;
SELECT '' AS count,
popen(f1) AS open_path FROM path_tbl;"
`;

exports[`kitchen sink upstream upstream/polygon.sql 1`] = `
"CREATE TABLE polygon_tbl (
f1 polygon
);
INSERT INTO polygon_tbl (f1) VALUES ('(2.0,0.0),(2.0,4.0),(0.0,0.0)');
INSERT INTO polygon_tbl (f1) VALUES ('(3.0,1.0),(3.0,3.0),(1.0,0.0)');
INSERT INTO polygon_tbl (f1) VALUES ('(0.0,0.0)');
INSERT INTO polygon_tbl (f1) VALUES ('(0.0,1.0),(0.0,1.0)');
INSERT INTO polygon_tbl (f1) VALUES ('0.0');
INSERT INTO polygon_tbl (f1) VALUES ('(0.0 0.0');
INSERT INTO polygon_tbl (f1) VALUES ('(0,1,2)');
INSERT INTO polygon_tbl (f1) VALUES ('(0,1,2,3');
INSERT INTO polygon_tbl (f1) VALUES ('asdf');
SELECT '' AS four,
* FROM polygon_tbl;
SELECT '' AS three,
p.* FROM polygon_tbl AS p WHERE p.f1 && '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS four,
p.* FROM polygon_tbl AS p WHERE p.f1 &< '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS two,
p.* FROM polygon_tbl AS p WHERE p.f1 &> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 << '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS zero,
p.* FROM polygon_tbl AS p WHERE p.f1 >> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 <@ '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 ~= '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 @> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon << '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon << '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"true\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon &> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon >> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon <@ '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon @> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"false\\";
SELECT '((0,4),(6,4),(3,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"true\\";
SELECT '((1,1),(1,4),(5,4),(5,3),(2,3),(2,2),(5,2),(5,1))'::polygon @> '((3,2),(3,3),(4,3),(4,2))'::polygon AS \\"false\\";
SELECT '((0,0),(0,3),(3,3),(3,0))'::polygon @> '((2,1),(2,2),(3,2),(3,1))'::polygon AS \\"true\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon ~= '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon && '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"true\\";
SELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon && '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"true\\";
SELECT '((1,4),(1,1),(4,1),(4,2),(2,2),(2,4),(1,4))'::polygon && '((3,3),(4,3),(4,4),(3,4),(3,3))'::polygon AS \\"false\\";
SELECT '((200,800),(800,800),(800,200),(200,200))' && '(1000,1000,0,0)'::polygon AS \\"true\\";
SELECT '(0,0)'::point <-> '((0,0),(1,2),(2,1))'::polygon AS on_corner,
'(1,1)'::point <-> '((0,0),(2,2),(1,3))'::polygon AS on_segment,
'(2,2)'::point <-> '((0,0),(1,4),(3,1))'::polygon AS inside,
'(3,3)'::point <-> '((0,2),(2,0),(2,2))'::polygon AS near_corner,
'(4,4)'::point <-> '((0,0),(0,3),(4,0))'::polygon AS near_segment;"
`;

exports[`kitchen sink upstream upstream/polygon.sql 2`] = `
"CREATE TABLE polygon_tbl (
f1 polygon
);
INSERT INTO polygon_tbl ( f1 ) VALUES ('(2.0,0.0),(2.0,4.0),(0.0,0.0)');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(3.0,1.0),(3.0,3.0),(1.0,0.0)');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(0.0,0.0)');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(0.0,1.0),(0.0,1.0)');
INSERT INTO polygon_tbl ( f1 ) VALUES ('0.0');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(0.0 0.0');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(0,1,2)');
INSERT INTO polygon_tbl ( f1 ) VALUES ('(0,1,2,3');
INSERT INTO polygon_tbl ( f1 ) VALUES ('asdf');
SELECT '' AS four,
* FROM polygon_tbl;
SELECT '' AS three,
p.* FROM polygon_tbl AS p WHERE p.f1 && '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS four,
p.* FROM polygon_tbl AS p WHERE p.f1 &< '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS two,
p.* FROM polygon_tbl AS p WHERE p.f1 &> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 << '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS zero,
p.* FROM polygon_tbl AS p WHERE p.f1 >> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 <@ '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 ~= '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '' AS one,
p.* FROM polygon_tbl AS p WHERE p.f1 @> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon;
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon << '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon << '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"true\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon &> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon >> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon <@ '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon @> '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"false\\";
SELECT '((0,4),(6,4),(3,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"true\\";
SELECT '((1,1),(1,4),(5,4),(5,3),(2,3),(2,2),(5,2),(5,1))'::polygon @> '((3,2),(3,3),(4,3),(4,2))'::polygon AS \\"false\\";
SELECT '((0,0),(0,3),(3,3),(3,0))'::polygon @> '((2,1),(2,2),(3,2),(3,1))'::polygon AS \\"true\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon ~= '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"false\\";
SELECT '(2.0,0.0),(2.0,4.0),(0.0,0.0)'::polygon && '(3.0,1.0),(3.0,3.0),(1.0,0.0)'::polygon AS \\"true\\";
SELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon && '((2,1),(2,3),(3,3),(3,1))'::polygon AS \\"true\\";
SELECT '((1,4),(1,1),(4,1),(4,2),(2,2),(2,4),(1,4))'::polygon && '((3,3),(4,3),(4,4),(3,4),(3,3))'::polygon AS \\"false\\";
SELECT '((200,800),(800,800),(800,200),(200,200))' && '(1000,1000,0,0)'::polygon AS \\"true\\";
SELECT '(0,0)'::point <-> '((0,0),(1,2),(2,1))'::polygon AS on_corner,
'(1,1)'::point <-> '((0,0),(2,2),(1,3))'::polygon AS on_segment,
'(2,2)'::point <-> '((0,0),(1,4),(3,1))'::polygon AS inside,
'(3,3)'::point <-> '((0,2),(2,0),(2,2))'::polygon AS near_corner,
'(4,4)'::point <-> '((0,0),(0,3),(4,0))'::polygon AS near_segment;"
`;

exports[`kitchen sink upstream upstream/random.sql 1`] = `
"SELECT count(*) FROM onek;
( ( SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1 ) INTERSECT ( SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1 ) ) INTERSECT ( SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1 );
SELECT count(*) AS random INTO random_tbl FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl (random) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl (random) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl (random) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
SELECT random,
count(random) FROM random_tbl GROUP BY random HAVING count(random) > 3;
SELECT avg(random) FROM random_tbl HAVING avg(random) NOT BETWEEN 80 AND 120;"
`;

exports[`kitchen sink upstream upstream/random.sql 2`] = `
"SELECT count(*) FROM onek;
((SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1) INTERSECT (SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1)) INTERSECT (SELECT unique1 AS random FROM onek ORDER BY random() LIMIT 1);
SELECT count(*) AS random INTO random_tbl FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl ( random ) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl ( random ) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
INSERT INTO random_tbl ( random ) SELECT count(*) FROM onek WHERE random() < (1.0 / 10);
SELECT random,
count(random) FROM random_tbl GROUP BY random HAVING count(random) > 3;
SELECT avg(random) FROM random_tbl HAVING avg(random) NOT BETWEEN 80 AND 120;"
`;

exports[`kitchen sink upstream upstream/reltime.sql 1`] = `
"CREATE TABLE reltime_tbl (
f1 reltime
);
INSERT INTO reltime_tbl (f1) VALUES ('@ 1 minute');
INSERT INTO reltime_tbl (f1) VALUES ('@ 5 hour');
INSERT INTO reltime_tbl (f1) VALUES ('@ 10 day');
INSERT INTO reltime_tbl (f1) VALUES ('@ 34 year');
INSERT INTO reltime_tbl (f1) VALUES ('@ 3 months');
INSERT INTO reltime_tbl (f1) VALUES ('@ 14 seconds ago');
INSERT INTO reltime_tbl (f1) VALUES ('badly formatted reltime');
INSERT INTO reltime_tbl (f1) VALUES ('@ 30 eons ago');
SELECT '' AS six,
* FROM reltime_tbl;
SELECT '' AS five,
* FROM reltime_tbl WHERE reltime_tbl.f1 <> '@ 10 days'::reltime;
SELECT '' AS three,
* FROM reltime_tbl WHERE reltime_tbl.f1 <= '@ 5 hours'::reltime;
SELECT '' AS three,
* FROM reltime_tbl WHERE reltime_tbl.f1 < '@ 1 day'::reltime;
SELECT '' AS one,
* FROM reltime_tbl WHERE reltime_tbl.f1 = '@ 34 years'::reltime;
SELECT '' AS two,
* FROM reltime_tbl WHERE reltime_tbl.f1 >= '@ 1 month'::reltime;
SELECT '' AS five,
* FROM reltime_tbl WHERE reltime_tbl.f1 > '@ 3 seconds ago'::reltime;
SELECT '' AS fifteen,
r1.*,
r2.* FROM reltime_tbl AS r1,
reltime_tbl AS r2 WHERE r1.f1 > r2.f1 ORDER BY r1.f1,
r2.f1;"
`;

exports[`kitchen sink upstream upstream/reltime.sql 2`] = `
"CREATE TABLE reltime_tbl (
f1 reltime
);
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 1 minute');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 5 hour');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 10 day');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 34 year');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 3 months');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 14 seconds ago');
INSERT INTO reltime_tbl ( f1 ) VALUES ('badly formatted reltime');
INSERT INTO reltime_tbl ( f1 ) VALUES ('@ 30 eons ago');
SELECT '' AS six,
* FROM reltime_tbl;
SELECT '' AS five,
* FROM reltime_tbl WHERE reltime_tbl.f1 <> '@ 10 days'::reltime;
SELECT '' AS three,
* FROM reltime_tbl WHERE reltime_tbl.f1 <= '@ 5 hours'::reltime;
SELECT '' AS three,
* FROM reltime_tbl WHERE reltime_tbl.f1 < '@ 1 day'::reltime;
SELECT '' AS one,
* FROM reltime_tbl WHERE reltime_tbl.f1 = '@ 34 years'::reltime;
SELECT '' AS two,
* FROM reltime_tbl WHERE reltime_tbl.f1 >= '@ 1 month'::reltime;
SELECT '' AS five,
* FROM reltime_tbl WHERE reltime_tbl.f1 > '@ 3 seconds ago'::reltime;
SELECT '' AS fifteen,
r1.*,
r2.* FROM reltime_tbl AS r1,
reltime_tbl AS r2 WHERE r1.f1 > r2.f1 ORDER BY r1.f1,
r2.f1;"
`;

exports[`kitchen sink upstream upstream/select_distinct_on.sql 1`] = `
"SELECT DISTINCT ON ( string4 ) string4,
two,
ten FROM tmp ORDER BY string4 USING <,
two USING >,
ten USING <;
SELECT DISTINCT ON ( string4,
ten ) string4,
two,
ten FROM tmp ORDER BY string4 USING <,
two USING <,
ten USING <;
SELECT DISTINCT ON ( string4,
ten ) string4,
ten,
two FROM tmp ORDER BY string4 USING <,
ten USING >,
two USING <;
SELECT DISTINCT ON ( 1 ) floor(random()) AS r,
f1 FROM int4_tbl ORDER BY 1,
2;"
`;

exports[`kitchen sink upstream upstream/select_distinct_on.sql 2`] = `
"SELECT DISTINCT ON (string4) string4,
two,
ten FROM tmp ORDER BY string4 USING <,
two USING >,
ten USING <;
SELECT DISTINCT ON (string4,
ten) string4,
two,
ten FROM tmp ORDER BY string4 USING <,
two USING <,
ten USING <;
SELECT DISTINCT ON (string4,
ten) string4,
ten,
two FROM tmp ORDER BY string4 USING <,
ten USING >,
two USING <;
SELECT DISTINCT ON (1) floor(random()) AS r,
f1 FROM int4_tbl ORDER BY 1,
2;"
`;

exports[`kitchen sink upstream upstream/select_having.sql 1`] = `
"CREATE TABLE test_having (
a int,
b int,
c char(8),
d char(1)
);
INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');
INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');
INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');
INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');
INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');
INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');
INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');
INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');
INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');
INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');
SELECT b,
c FROM test_having GROUP BY b,
c HAVING count(*) = 1 ORDER BY b,
c;
SELECT b,
c FROM test_having GROUP BY b,
c HAVING b = 3 ORDER BY b,
c;
SELECT lower(c),
count(c) FROM test_having GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a) ORDER BY lower(c);
SELECT c,
max(a) FROM test_having GROUP BY c HAVING count(*) > 2 OR min(a) = max(a) ORDER BY c;
SELECT min(a),
max(a) FROM test_having HAVING min(a) = max(a);
SELECT min(a),
max(a) FROM test_having HAVING min(a) < max(a);
SELECT a FROM test_having HAVING min(a) < max(a);
SELECT 1 AS one FROM test_having HAVING a > 1;
SELECT 1 AS one FROM test_having HAVING 1 > 2;
SELECT 1 AS one FROM test_having HAVING 1 < 2;
SELECT 1 AS one FROM test_having WHERE (1 / a) = 1 HAVING 1 < 2;
DROP TABLE test_having;"
`;

exports[`kitchen sink upstream upstream/select_having.sql 2`] = `
"CREATE TABLE test_having (
a int,
b int,
c char(8),
d char(1)
);
INSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');
INSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');
INSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');
INSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');
INSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');
INSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');
INSERT INTO test_having VALUES (6, 4, 'cccc', 'g');
INSERT INTO test_having VALUES (7, 4, 'cccc', 'h');
INSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');
INSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');
SELECT b,
c FROM test_having GROUP BY b,
c HAVING count(*) = 1 ORDER BY b,
c;
SELECT b,
c FROM test_having GROUP BY b,
c HAVING b = 3 ORDER BY b,
c;
SELECT lower(c),
count(c) FROM test_having GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a) ORDER BY lower(c);
SELECT c,
max(a) FROM test_having GROUP BY c HAVING count(*) > 2 OR min(a) = max(a) ORDER BY c;
SELECT min(a),
max(a) FROM test_having HAVING min(a) = max(a);
SELECT min(a),
max(a) FROM test_having HAVING min(a) < max(a);
SELECT a FROM test_having HAVING min(a) < max(a);
SELECT 1 AS one FROM test_having HAVING a > 1;
SELECT 1 AS one FROM test_having HAVING 1 > 2;
SELECT 1 AS one FROM test_having HAVING 1 < 2;
SELECT 1 AS one FROM test_having WHERE (1 / a) = 1 HAVING 1 < 2;
DROP TABLE test_having;"
`;

exports[`kitchen sink upstream upstream/select_implicit.sql 1`] = `
"CREATE TABLE test_missing_target (
a int,
b int,
c char(8),
d char(1)
);
INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');
INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');
INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');
INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');
INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');
INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');
INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');
INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');
INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');
INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');
SELECT c,
count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;
SELECT test_missing_target.b,
count(*) FROM test_missing_target GROUP BY b ORDER BY b;
SELECT c FROM test_missing_target ORDER BY a;
SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b DESC;
SELECT count(*) FROM test_missing_target ORDER BY 1 DESC;
SELECT c,
count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;
SELECT c,
count(*) FROM test_missing_target GROUP BY 3;
SELECT count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY b ORDER BY b;
SELECT a,
a FROM test_missing_target ORDER BY a;
SELECT a / 2,
a / 2 FROM test_missing_target ORDER BY a / 2;
SELECT a / 2,
a / 2 FROM test_missing_target GROUP BY a / 2 ORDER BY a / 2;
SELECT x.b,
count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT count(*) INTO test_missing_target2 FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT * FROM test_missing_target2;
SELECT a % 2,
count(b) FROM test_missing_target GROUP BY test_missing_target.a % 2 ORDER BY test_missing_target.a % 2;
SELECT count(c) FROM test_missing_target GROUP BY lower(test_missing_target.c) ORDER BY lower(test_missing_target.c);
SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
SELECT count(b) FROM test_missing_target GROUP BY b / 2 ORDER BY b / 2;
SELECT lower(test_missing_target.c),
count(c) FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
SELECT a FROM test_missing_target ORDER BY upper(d);
SELECT count(b) FROM test_missing_target GROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 DESC;
SELECT count(x.a) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY b / 2 ORDER BY b / 2;
SELECT x.b / 2,
count(x.b) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2 ORDER BY x.b / 2;
SELECT count(b) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2;
SELECT count(x.b) INTO test_missing_target3 FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2 ORDER BY x.b / 2;
SELECT * FROM test_missing_target3;
DROP TABLE test_missing_target;
DROP TABLE test_missing_target2;
DROP TABLE test_missing_target3;"
`;

exports[`kitchen sink upstream upstream/select_implicit.sql 2`] = `
"CREATE TABLE test_missing_target (
a int,
b int,
c char(8),
d char(1)
);
INSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');
INSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');
INSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');
INSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');
INSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');
INSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');
INSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');
INSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');
INSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');
INSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');
SELECT c,
count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;
SELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;
SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;
SELECT test_missing_target.b,
count(*) FROM test_missing_target GROUP BY b ORDER BY b;
SELECT c FROM test_missing_target ORDER BY a;
SELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b DESC;
SELECT count(*) FROM test_missing_target ORDER BY 1 DESC;
SELECT c,
count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;
SELECT c,
count(*) FROM test_missing_target GROUP BY 3;
SELECT count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY b ORDER BY b;
SELECT a,
a FROM test_missing_target ORDER BY a;
SELECT a / 2,
a / 2 FROM test_missing_target ORDER BY a / 2;
SELECT a / 2,
a / 2 FROM test_missing_target GROUP BY a / 2 ORDER BY a / 2;
SELECT x.b,
count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT count(*) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT count(*) INTO test_missing_target2 FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b ORDER BY x.b;
SELECT * FROM test_missing_target2;
SELECT a % 2,
count(b) FROM test_missing_target GROUP BY test_missing_target.a % 2 ORDER BY test_missing_target.a % 2;
SELECT count(c) FROM test_missing_target GROUP BY lower(test_missing_target.c) ORDER BY lower(test_missing_target.c);
SELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;
SELECT count(b) FROM test_missing_target GROUP BY b / 2 ORDER BY b / 2;
SELECT lower(test_missing_target.c),
count(c) FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);
SELECT a FROM test_missing_target ORDER BY upper(d);
SELECT count(b) FROM test_missing_target GROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 DESC;
SELECT count(x.a) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY b / 2 ORDER BY b / 2;
SELECT x.b / 2,
count(x.b) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2 ORDER BY x.b / 2;
SELECT count(b) FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2;
SELECT count(x.b) INTO test_missing_target3 FROM test_missing_target AS x,
test_missing_target AS y WHERE x.a = y.a GROUP BY x.b / 2 ORDER BY x.b / 2;
SELECT * FROM test_missing_target3;
DROP TABLE test_missing_target;
DROP TABLE test_missing_target2;
DROP TABLE test_missing_target3;"
`;

exports[`kitchen sink upstream upstream/text.sql 1`] = `
"SELECT 'this is a text string'::text = 'this is a text string'::text AS \\"true\\";
SELECT 'this is a text string'::text = 'this is a text strin'::text AS \\"false\\";
CREATE TABLE text_tbl (
f1 text
);
INSERT INTO text_tbl VALUES ('doh!');
INSERT INTO text_tbl VALUES ('hi de ho neighbor');
SELECT '' AS two,
* FROM text_tbl;
SELECT length(42);
SELECT 'four: '::text || (2 + 2);
SELECT 'four: ' || (2 + 2);
SELECT 3 || 4.0;
SELECT concat('one');
SELECT concat(1, 2, 3, 'hello', TRUE, FALSE, to_date('20100309', 'YYYYMMDD'));
SELECT concat_ws('#', 'one');
SELECT concat_ws('#', 1, 2, 3, 'hello', TRUE, FALSE, to_date('20100309', 'YYYYMMDD'));
SELECT concat_ws(',', 10, 20, NULL, 30);
SELECT concat_ws('', 10, 20, NULL, 30);
SELECT concat_ws(NULL, 10, 20, NULL, 30) IS NULL;
SELECT reverse('abcde');
SELECT i,
\\"left\\"('ahoj', i),
\\"right\\"('ahoj', i) FROM generate_series((-5), 5) AS t (i) ORDER BY i;
SELECT quote_literal('');
SELECT quote_literal('abc''');
SELECT quote_literal('\\\\');
SELECT concat(VARIADIC ARRAY[1, 2, 3]);
SELECT concat_ws(',', VARIADIC ARRAY[1, 2, 3]);
SELECT concat_ws(',', VARIADIC NULL::int[]);
SELECT concat(VARIADIC NULL::int[]) IS NULL;
SELECT concat(VARIADIC '{}'::int[]) = '';
SELECT concat_ws(',', VARIADIC 10);
SELECT format(NULL);
SELECT format('Hello');
SELECT format('Hello %s', 'World');
SELECT format('Hello %%');
SELECT format('Hello %%%%');
SELECT format('Hello %s %s', 'World');
SELECT format('Hello %s');
SELECT format('Hello %x', 20);
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, 'Hello');
SELECT format('%s%s%s', 'Hello', NULL, 'World');
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, NULL);
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', NULL, 'Hello');
SELECT format('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');
SELECT format('%1$s %3$s', 1, 2, 3);
SELECT format('%1$s %12$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
SELECT format('%1$s %4$s', 1, 2, 3);
SELECT format('%1$s %13$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
SELECT format('%0$s', 'Hello');
SELECT format('%*0$s', 'Hello');
SELECT format('%1$', 1);
SELECT format('%1$1', 1);
SELECT format('Hello %s %1$s %s', 'World', 'Hello again');
SELECT format('Hello %s %s, %2$s %2$s', 'World', 'Hello again');
SELECT format('%s, %s', VARIADIC ARRAY['Hello', 'World']);
SELECT format('%s, %s', VARIADIC ARRAY[1, 2]);
SELECT format('%s, %s', VARIADIC ARRAY[TRUE, FALSE]);
SELECT format('%s, %s', VARIADIC ARRAY[TRUE, FALSE]::text[]);
SELECT format('%2$s, %1$s', VARIADIC ARRAY['first', 'second']);
SELECT format('%2$s, %1$s', VARIADIC ARRAY[1, 2]);
SELECT format('Hello', VARIADIC NULL::int[]);
SELECT format(string_agg('%s', ','), VARIADIC array_agg(i)) FROM generate_series(1, 200) AS g (i);
SELECT format('>>%10s<<', 'Hello');
SELECT format('>>%10s<<', NULL);
SELECT format('>>%10s<<', '');
SELECT format('>>%-10s<<', '');
SELECT format('>>%-10s<<', 'Hello');
SELECT format('>>%-10s<<', NULL);
SELECT format('>>%1$10s<<', 'Hello');
SELECT format('>>%1$-10I<<', 'Hello');
SELECT format('>>%2$*1$L<<', 10, 'Hello');
SELECT format('>>%2$*1$L<<', 10, NULL);
SELECT format('>>%2$*1$L<<', (-10), NULL);
SELECT format('>>%*s<<', 10, 'Hello');
SELECT format('>>%*1$s<<', 10, 'Hello');
SELECT format('>>%-s<<', 'Hello');
SELECT format('>>%10L<<', NULL);
SELECT format('>>%2$*1$L<<', NULL, 'Hello');
SELECT format('>>%2$*1$L<<', 0, 'Hello');"
`;

exports[`kitchen sink upstream upstream/text.sql 2`] = `
"SELECT 'this is a text string'::text = 'this is a text string'::text AS \\"true\\";
SELECT 'this is a text string'::text = 'this is a text strin'::text AS \\"false\\";
CREATE TABLE text_tbl (
f1 text
);
INSERT INTO text_tbl VALUES ('doh!');
INSERT INTO text_tbl VALUES ('hi de ho neighbor');
SELECT '' AS two,
* FROM text_tbl;
SELECT length(42);
SELECT 'four: '::text || (2 + 2);
SELECT 'four: ' || (2 + 2);
SELECT 3 || 4.0;
SELECT concat('one');
SELECT concat(1, 2, 3, 'hello', (TRUE), (FALSE), to_date('20100309', 'YYYYMMDD'));
SELECT concat_ws('#', 'one');
SELECT concat_ws('#', 1, 2, 3, 'hello', (TRUE), (FALSE), to_date('20100309', 'YYYYMMDD'));
SELECT concat_ws(',', 10, 20, NULL, 30);
SELECT concat_ws('', 10, 20, NULL, 30);
SELECT concat_ws(NULL, 10, 20, NULL, 30) IS NULL;
SELECT reverse('abcde');
SELECT i,
left('ahoj', i),
right('ahoj', i) FROM generate_series((-5), 5) AS t(i) ORDER BY i;
SELECT quote_literal('');
SELECT quote_literal('abc''');
SELECT quote_literal('\\\\');
SELECT concat(VARIADIC ARRAY[1, 2, 3]);
SELECT concat_ws(',', VARIADIC ARRAY[1, 2, 3]);
SELECT concat_ws(',', VARIADIC NULL::int[]);
SELECT concat(VARIADIC NULL::int[]) IS NULL;
SELECT concat(VARIADIC '{}'::int[]) = '';
SELECT concat_ws(',', VARIADIC 10);
SELECT format(NULL);
SELECT format('Hello');
SELECT format('Hello %s', 'World');
SELECT format('Hello %%');
SELECT format('Hello %%%%');
SELECT format('Hello %s %s', 'World');
SELECT format('Hello %s');
SELECT format('Hello %x', 20);
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, 'Hello');
SELECT format('%s%s%s', 'Hello', NULL, 'World');
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, NULL);
SELECT format('INSERT INTO %I VALUES(%L,%L)', 'mytab', NULL, 'Hello');
SELECT format('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');
SELECT format('%1$s %3$s', 1, 2, 3);
SELECT format('%1$s %12$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
SELECT format('%1$s %4$s', 1, 2, 3);
SELECT format('%1$s %13$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
SELECT format('%0$s', 'Hello');
SELECT format('%*0$s', 'Hello');
SELECT format('%1$', 1);
SELECT format('%1$1', 1);
SELECT format('Hello %s %1$s %s', 'World', 'Hello again');
SELECT format('Hello %s %s, %2$s %2$s', 'World', 'Hello again');
SELECT format('%s, %s', VARIADIC ARRAY['Hello', 'World']);
SELECT format('%s, %s', VARIADIC ARRAY[1, 2]);
SELECT format('%s, %s', VARIADIC ARRAY[(TRUE), (FALSE)]);
SELECT format('%s, %s', VARIADIC ARRAY[(TRUE), (FALSE)]::text[]);
SELECT format('%2$s, %1$s', VARIADIC ARRAY['first', 'second']);
SELECT format('%2$s, %1$s', VARIADIC ARRAY[1, 2]);
SELECT format('Hello', VARIADIC NULL::int[]);
SELECT format(string_agg('%s', ','), VARIADIC array_agg(i)) FROM generate_series(1, 200) AS g(i);
SELECT format('>>%10s<<', 'Hello');
SELECT format('>>%10s<<', NULL);
SELECT format('>>%10s<<', '');
SELECT format('>>%-10s<<', '');
SELECT format('>>%-10s<<', 'Hello');
SELECT format('>>%-10s<<', NULL);
SELECT format('>>%1$10s<<', 'Hello');
SELECT format('>>%1$-10I<<', 'Hello');
SELECT format('>>%2$*1$L<<', 10, 'Hello');
SELECT format('>>%2$*1$L<<', 10, NULL);
SELECT format('>>%2$*1$L<<', (-10), NULL);
SELECT format('>>%*s<<', 10, 'Hello');
SELECT format('>>%*1$s<<', 10, 'Hello');
SELECT format('>>%-s<<', 'Hello');
SELECT format('>>%10L<<', NULL);
SELECT format('>>%2$*1$L<<', NULL, 'Hello');
SELECT format('>>%2$*1$L<<', 0, 'Hello');"
`;

exports[`kitchen sink upstream upstream/time.sql 1`] = `
"CREATE TABLE time_tbl (
f1 time(2)
);
INSERT INTO time_tbl VALUES ('00:00');
INSERT INTO time_tbl VALUES ('01:00');
INSERT INTO time_tbl VALUES ('02:03 PST');
INSERT INTO time_tbl VALUES ('11:59 EDT');
INSERT INTO time_tbl VALUES ('12:00');
INSERT INTO time_tbl VALUES ('12:01');
INSERT INTO time_tbl VALUES ('23:59');
INSERT INTO time_tbl VALUES ('11:59:59.99 PM');
INSERT INTO time_tbl VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO time_tbl VALUES ('2003-07-07 15:36:39 America/New_York');
INSERT INTO time_tbl VALUES ('15:36:39 America/New_York');
SELECT f1 AS \\"Time\\" FROM time_tbl;
SELECT f1 AS \\"Three\\" FROM time_tbl WHERE f1 < '05:06:07';
SELECT f1 AS \\"Five\\" FROM time_tbl WHERE f1 > '05:06:07';
SELECT f1 AS \\"None\\" FROM time_tbl WHERE f1 < '00:00';
SELECT f1 AS \\"Eight\\" FROM time_tbl WHERE f1 >= '00:00';
SELECT f1 + '00:01'::time AS \\"Illegal\\" FROM time_tbl;"
`;

exports[`kitchen sink upstream upstream/time.sql 2`] = `
"CREATE TABLE time_tbl (
f1 time(2)
);
INSERT INTO time_tbl VALUES ('00:00');
INSERT INTO time_tbl VALUES ('01:00');
INSERT INTO time_tbl VALUES ('02:03 PST');
INSERT INTO time_tbl VALUES ('11:59 EDT');
INSERT INTO time_tbl VALUES ('12:00');
INSERT INTO time_tbl VALUES ('12:01');
INSERT INTO time_tbl VALUES ('23:59');
INSERT INTO time_tbl VALUES ('11:59:59.99 PM');
INSERT INTO time_tbl VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO time_tbl VALUES ('2003-07-07 15:36:39 America/New_York');
INSERT INTO time_tbl VALUES ('15:36:39 America/New_York');
SELECT f1 AS \\"Time\\" FROM time_tbl;
SELECT f1 AS \\"Three\\" FROM time_tbl WHERE f1 < '05:06:07';
SELECT f1 AS \\"Five\\" FROM time_tbl WHERE f1 > '05:06:07';
SELECT f1 AS \\"None\\" FROM time_tbl WHERE f1 < '00:00';
SELECT f1 AS \\"Eight\\" FROM time_tbl WHERE f1 >= '00:00';
SELECT f1 + '00:01'::time AS \\"Illegal\\" FROM time_tbl;"
`;

exports[`kitchen sink upstream upstream/timetz.sql 1`] = `
"CREATE TABLE timetz_tbl (
f1 pg_catalog.timetz(2)
);
INSERT INTO timetz_tbl VALUES ('00:01 PDT');
INSERT INTO timetz_tbl VALUES ('01:00 PDT');
INSERT INTO timetz_tbl VALUES ('02:03 PDT');
INSERT INTO timetz_tbl VALUES ('07:07 PST');
INSERT INTO timetz_tbl VALUES ('08:08 EDT');
INSERT INTO timetz_tbl VALUES ('11:59 PDT');
INSERT INTO timetz_tbl VALUES ('12:00 PDT');
INSERT INTO timetz_tbl VALUES ('12:01 PDT');
INSERT INTO timetz_tbl VALUES ('23:59 PDT');
INSERT INTO timetz_tbl VALUES ('11:59:59.99 PM PDT');
INSERT INTO timetz_tbl VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO timetz_tbl VALUES ('2003-07-07 15:36:39 America/New_York');
INSERT INTO timetz_tbl VALUES ('15:36:39 America/New_York');
SELECT f1 AS \\"Time TZ\\" FROM timetz_tbl;
SELECT f1 AS \\"Three\\" FROM timetz_tbl WHERE f1 < '05:06:07-07';
SELECT f1 AS \\"Seven\\" FROM timetz_tbl WHERE f1 > '05:06:07-07';
SELECT f1 AS \\"None\\" FROM timetz_tbl WHERE f1 < '00:00-07';
SELECT f1 AS \\"Ten\\" FROM timetz_tbl WHERE f1 >= '00:00-07';
SELECT f1 + '00:01'::pg_catalog.timetz AS \\"Illegal\\" FROM timetz_tbl;"
`;

exports[`kitchen sink upstream upstream/timetz.sql 2`] = `
"CREATE TABLE timetz_tbl (
f1 pg_catalog.timetz(2)
);
INSERT INTO timetz_tbl VALUES ('00:01 PDT');
INSERT INTO timetz_tbl VALUES ('01:00 PDT');
INSERT INTO timetz_tbl VALUES ('02:03 PDT');
INSERT INTO timetz_tbl VALUES ('07:07 PST');
INSERT INTO timetz_tbl VALUES ('08:08 EDT');
INSERT INTO timetz_tbl VALUES ('11:59 PDT');
INSERT INTO timetz_tbl VALUES ('12:00 PDT');
INSERT INTO timetz_tbl VALUES ('12:01 PDT');
INSERT INTO timetz_tbl VALUES ('23:59 PDT');
INSERT INTO timetz_tbl VALUES ('11:59:59.99 PM PDT');
INSERT INTO timetz_tbl VALUES ('2003-03-07 15:36:39 America/New_York');
INSERT INTO timetz_tbl VALUES ('2003-07-07 15:36:39 America/New_York');
INSERT INTO timetz_tbl VALUES ('15:36:39 America/New_York');
SELECT f1 AS \\"Time TZ\\" FROM timetz_tbl;
SELECT f1 AS \\"Three\\" FROM timetz_tbl WHERE f1 < '05:06:07-07';
SELECT f1 AS \\"Seven\\" FROM timetz_tbl WHERE f1 > '05:06:07-07';
SELECT f1 AS \\"None\\" FROM timetz_tbl WHERE f1 < '00:00-07';
SELECT f1 AS \\"Ten\\" FROM timetz_tbl WHERE f1 >= '00:00-07';
SELECT f1 + '00:01'::pg_catalog.timetz AS \\"Illegal\\" FROM timetz_tbl;"
`;

exports[`kitchen sink upstream upstream/tinterval.sql 1`] = `
"CREATE TABLE tinterval_tbl (
f1 tinterval
);
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"-infinity\\" \\"infinity\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"May 10, 1947 23:59:12\\" \\"Jan 14, 1973 03:14:21\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"Sep 4, 1983 23:59:12\\" \\"Oct 4, 1983 23:59:12\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"epoch\\" \\"Mon May  1 00:30:30 1995\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"Feb 15 1990 12:15:03\\" \\"2001-09-23 11:12:13\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"bad time specifications\\" \\"\\"]');
INSERT INTO tinterval_tbl (f1) VALUES ('[\\"\\" \\"infinity\\"]');
SELECT '' AS five,
* FROM tinterval_tbl;
SELECT '' AS one,
t.* FROM tinterval_tbl AS t WHERE t.f1 #= '@ 1 months';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #<> '@ 1 months';
SELECT '' AS zero,
t.* FROM tinterval_tbl AS t WHERE t.f1 #< '@ 1 month';
SELECT '' AS one,
t.* FROM tinterval_tbl AS t WHERE t.f1 #<= '@ 1 month';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #> '@ 1 year';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #>= '@ 3 years';
SELECT '' AS three,
t1.* FROM tinterval_tbl AS t1 WHERE t1.f1 && '[\\"Aug 15 14:23:19 1983\\" \\"Sep 16 14:23:19 1983\\"]'::tinterval;
SELECT '' AS five,
t1.f1,
t2.f1 FROM tinterval_tbl AS t1,
tinterval_tbl AS t2 WHERE t1.f1 && t2.f1 AND t1.f1 = t2.f1 ORDER BY t1.f1,
t2.f1;
SELECT '' AS fourteen,
t1.f1 AS interval1,
t2.f1 AS interval2 FROM tinterval_tbl AS t1,
tinterval_tbl AS t2 WHERE t1.f1 && t2.f1 AND NOT (t1.f1 = t2.f1) ORDER BY interval1,
interval2;
SELECT '' AS five,
t1.f1 FROM tinterval_tbl AS t1 WHERE NOT (t1.f1 << '[\\"Aug 15 14:23:19 1980\\" \\"Sep 16 14:23:19 1990\\"]'::tinterval) ORDER BY t1.f1;
SELECT '' AS three,
t1.f1 FROM tinterval_tbl AS t1 WHERE t1.f1 && ('Aug 15 14:23:19 1983'::abstime <#> 'Sep 16 14:23:19 1983'::abstime) ORDER BY t1.f1;"
`;

exports[`kitchen sink upstream upstream/tinterval.sql 2`] = `
"CREATE TABLE tinterval_tbl (
f1 tinterval
);
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"-infinity\\" \\"infinity\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"May 10, 1947 23:59:12\\" \\"Jan 14, 1973 03:14:21\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"Sep 4, 1983 23:59:12\\" \\"Oct 4, 1983 23:59:12\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"epoch\\" \\"Mon May  1 00:30:30 1995\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"Feb 15 1990 12:15:03\\" \\"2001-09-23 11:12:13\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"bad time specifications\\" \\"\\"]');
INSERT INTO tinterval_tbl ( f1 ) VALUES ('[\\"\\" \\"infinity\\"]');
SELECT '' AS five,
* FROM tinterval_tbl;
SELECT '' AS one,
t.* FROM tinterval_tbl AS t WHERE t.f1 #= '@ 1 months';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #<> '@ 1 months';
SELECT '' AS zero,
t.* FROM tinterval_tbl AS t WHERE t.f1 #< '@ 1 month';
SELECT '' AS one,
t.* FROM tinterval_tbl AS t WHERE t.f1 #<= '@ 1 month';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #> '@ 1 year';
SELECT '' AS three,
t.* FROM tinterval_tbl AS t WHERE t.f1 #>= '@ 3 years';
SELECT '' AS three,
t1.* FROM tinterval_tbl AS t1 WHERE t1.f1 && '[\\"Aug 15 14:23:19 1983\\" \\"Sep 16 14:23:19 1983\\"]'::tinterval;
SELECT '' AS five,
t1.f1,
t2.f1 FROM tinterval_tbl AS t1,
tinterval_tbl AS t2 WHERE t1.f1 && t2.f1 AND t1.f1 = t2.f1 ORDER BY t1.f1,
t2.f1;
SELECT '' AS fourteen,
t1.f1 AS interval1,
t2.f1 AS interval2 FROM tinterval_tbl AS t1,
tinterval_tbl AS t2 WHERE t1.f1 && t2.f1 AND NOT (t1.f1 = t2.f1) ORDER BY interval1,
interval2;
SELECT '' AS five,
t1.f1 FROM tinterval_tbl AS t1 WHERE NOT (t1.f1 << '[\\"Aug 15 14:23:19 1980\\" \\"Sep 16 14:23:19 1990\\"]'::tinterval) ORDER BY t1.f1;
SELECT '' AS three,
t1.f1 FROM tinterval_tbl AS t1 WHERE t1.f1 && ('Aug 15 14:23:19 1983'::abstime <#> 'Sep 16 14:23:19 1983'::abstime) ORDER BY t1.f1;"
`;

exports[`kitchen sink upstream upstream/tstypes.sql 1`] = `
"SELECT '1'::tsvector;
SELECT '1 '::tsvector;
SELECT ' 1'::tsvector;
SELECT ' 1 '::tsvector;
SELECT '1 2'::tsvector;
SELECT '''1 2'''::tsvector;
SELECT '''1 \\\\''2'''::tsvector;
SELECT '''1 \\\\''2''3'::tsvector;
SELECT '''1 \\\\''2'' 3'::tsvector;
SELECT '''1 \\\\''2'' '' 3'' 4 '::tsvector;
SELECT '''\\\\\\\\as'' ab\\\\c ab\\\\\\\\c AB\\\\\\\\\\\\c ab\\\\\\\\\\\\\\\\c'::tsvector;
SELECT tsvectorin(tsvectorout('''\\\\\\\\as'' ab\\\\c ab\\\\\\\\c AB\\\\\\\\\\\\c ab\\\\\\\\\\\\\\\\c'::tsvector));
SELECT '''w'':4A,3B,2C,1D,5 a:8';
SELECT 'a:3A b:2a'::tsvector || 'ba:1234 a:1B';
SELECT '1'::tsquery;
SELECT '1 '::tsquery;
SELECT ' 1'::tsquery;
SELECT ' 1 '::tsquery;
SELECT '''1 2'''::tsquery;
SELECT '''1 \\\\''2'''::tsquery;
SELECT '!1'::tsquery;
SELECT '1|2'::tsquery;
SELECT '1|!2'::tsquery;
SELECT '!1|2'::tsquery;
SELECT '!1|!2'::tsquery;
SELECT '!(!1|!2)'::tsquery;
SELECT '!(!1|2)'::tsquery;
SELECT '!(1|!2)'::tsquery;
SELECT '!(1|2)'::tsquery;
SELECT '1&2'::tsquery;
SELECT '!1&2'::tsquery;
SELECT '1&!2'::tsquery;
SELECT '!1&!2'::tsquery;
SELECT '(1&2)'::tsquery;
SELECT '1&(2)'::tsquery;
SELECT '!(1)&2'::tsquery;
SELECT '!(1&2)'::tsquery;
SELECT '1|2&3'::tsquery;
SELECT '1|(2&3)'::tsquery;
SELECT '(1|2)&3'::tsquery;
SELECT '1|2&!3'::tsquery;
SELECT '1|!2&3'::tsquery;
SELECT '!1|2&3'::tsquery;
SELECT '!1|(2&3)'::tsquery;
SELECT '!(1|2)&3'::tsquery;
SELECT '(!1|2)&3'::tsquery;
SELECT '1|(2|(4|(5|6)))'::tsquery;
SELECT '1|2|4|5|6'::tsquery;
SELECT '1&(2&(4&(5&6)))'::tsquery;
SELECT '1&2&4&5&6'::tsquery;
SELECT '1&(2&(4&(5|6)))'::tsquery;
SELECT '1&(2&(4&(5|!6)))'::tsquery;
SELECT '1&(''2''&('' 4''&(\\\\|5 | ''6 \\\\'' !|&'')))'::tsquery;
SELECT '''\\\\\\\\as'''::tsquery;
SELECT 'a:* & nbb:*ac | doo:a* | goo'::tsquery;
SELECT 'a <-> (b|c)'::tsquery;
SELECT '(a|b) <-> c'::tsquery;
SELECT '(a|b) <-> (d|c)'::tsquery;
SELECT 'a <-> (b&c)'::tsquery;
SELECT '(a&b) <-> c'::tsquery;
SELECT '(a&b) <-> (d&c)'::tsquery;
SELECT 'a <-> !b'::tsquery;
SELECT '!a <-> b'::tsquery;
SELECT '!a <-> !b'::tsquery;
SELECT 'a <-> !(b&c)'::tsquery;
SELECT 'a <-> !(b|c)'::tsquery;
SELECT '!(a&b) <-> c'::tsquery;
SELECT '!(a|b) <-> c'::tsquery;
SELECT '(!a|b) <-> c'::tsquery;
SELECT '(!a&b) <-> c'::tsquery;
SELECT 'c <-> (!a|b)'::tsquery;
SELECT 'c <-> (!a&b)'::tsquery;
SELECT '(a|b) <-> !c'::tsquery;
SELECT '(a&b) <-> !c'::tsquery;
SELECT '!c <-> (a|b)'::tsquery;
SELECT '!c <-> (a&b)'::tsquery;
SELECT 'a' < 'b & c'::tsquery AS \\"true\\";
SELECT 'a' > 'b & c'::tsquery AS \\"false\\";
SELECT 'a | f' < 'b & c'::tsquery AS \\"false\\";
SELECT 'a | ff' < 'b & c'::tsquery AS \\"false\\";
SELECT 'a | f | g' < 'b & c'::tsquery AS \\"false\\";
SELECT numnode('new'::tsquery);
SELECT numnode('new & york'::tsquery);
SELECT numnode('new & york | qwery'::tsquery);
SELECT 'foo & bar'::tsquery && 'asd';
SELECT 'foo & bar'::tsquery || 'asd & fg';
SELECT 'foo & bar'::tsquery || (!!'asd & fg'::tsquery);
SELECT 'foo & bar'::tsquery && 'asd | fg';
SELECT 'a' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b | d'::tsquery;
SELECT 'a & g' <-> 'b <-> d'::tsquery;
SELECT tsquery_phrase('a <3> g', 'b & d', 10);
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:B' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:A' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:C' AS \\"false\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:CB' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"false\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*CB' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b cb:80c d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"true\\";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"true\\";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*B' AS \\"true\\";
SELECT 'supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supeanova supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supeznova supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT 'supeanova supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT 'supeznova supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 2' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 2' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 3' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 11 3') @@ '1 <-> 3' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 11 3') @@ '1:* <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> 2 <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> (2 <-> 3)' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <2> (2 <-> 3)' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '1 <-> 2 <-> 3' AS \\"true\\";
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 sa:3C sab:2c d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2A d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2 d:2A g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2,3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 b:2 s:3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 sa:2D sb:2A g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:A');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:B');
SELECT 'a:1 b:2'::tsvector @@ 'a <-> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <0> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <1> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <2> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <-> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <0> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <1> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <2> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <3> b'::tsquery AS \\"true\\";
SELECT strip('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd'::tsvector);
SELECT strip('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT strip('base hidden rebel spaceship strike'::tsvector);
SELECT ts_delete(to_tsvector('english', 'Rebel spaceships, striking from a hidden base'), 'spaceship');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'base');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bas');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bases');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'spaceship');
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, 'spaceship');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceships', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceshi', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship', 'leya', 'rebel']);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship', 'leya', 'rebel']);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship', 'leya', 'rebel', NULL]);
SELECT unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT unnest('base hidden rebel spaceship strike'::tsvector);
SELECT * FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT * FROM unnest('base hidden rebel spaceship strike'::tsvector);
SELECT lexeme,
(positions)[1] FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);
SELECT array_to_tsvector(ARRAY['base', 'hidden', 'rebel', 'spaceship', 'strike']);
SELECT array_to_tsvector(ARRAY['base', 'hidden', 'rebel', 'spaceship', NULL]);
SELECT setweight('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd zxc:81,567,222A'::tsvector, 'c');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a,zxc}');
SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', '{a,zxc}');
SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', NULL]);
SELECT ts_filter('base:7A empir:17 evil:15 first:11 galact:16 hidden:6A rebel:1A spaceship:2A strike:3A victori:12 won:9'::tsvector, '{a}');
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a}');
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a,b,NULL}');"
`;

exports[`kitchen sink upstream upstream/tstypes.sql 2`] = `
"SELECT '1'::tsvector;
SELECT '1 '::tsvector;
SELECT ' 1'::tsvector;
SELECT ' 1 '::tsvector;
SELECT '1 2'::tsvector;
SELECT '''1 2'''::tsvector;
SELECT '''1 \\\\''2'''::tsvector;
SELECT '''1 \\\\''2''3'::tsvector;
SELECT '''1 \\\\''2'' 3'::tsvector;
SELECT '''1 \\\\''2'' '' 3'' 4 '::tsvector;
SELECT '''\\\\\\\\as'' ab\\\\c ab\\\\\\\\c AB\\\\\\\\\\\\c ab\\\\\\\\\\\\\\\\c'::tsvector;
SELECT tsvectorin(tsvectorout('''\\\\\\\\as'' ab\\\\c ab\\\\\\\\c AB\\\\\\\\\\\\c ab\\\\\\\\\\\\\\\\c'::tsvector));
SELECT '''w'':4A,3B,2C,1D,5 a:8';
SELECT 'a:3A b:2a'::tsvector || 'ba:1234 a:1B';
SELECT '1'::tsquery;
SELECT '1 '::tsquery;
SELECT ' 1'::tsquery;
SELECT ' 1 '::tsquery;
SELECT '''1 2'''::tsquery;
SELECT '''1 \\\\''2'''::tsquery;
SELECT '!1'::tsquery;
SELECT '1|2'::tsquery;
SELECT '1|!2'::tsquery;
SELECT '!1|2'::tsquery;
SELECT '!1|!2'::tsquery;
SELECT '!(!1|!2)'::tsquery;
SELECT '!(!1|2)'::tsquery;
SELECT '!(1|!2)'::tsquery;
SELECT '!(1|2)'::tsquery;
SELECT '1&2'::tsquery;
SELECT '!1&2'::tsquery;
SELECT '1&!2'::tsquery;
SELECT '!1&!2'::tsquery;
SELECT '(1&2)'::tsquery;
SELECT '1&(2)'::tsquery;
SELECT '!(1)&2'::tsquery;
SELECT '!(1&2)'::tsquery;
SELECT '1|2&3'::tsquery;
SELECT '1|(2&3)'::tsquery;
SELECT '(1|2)&3'::tsquery;
SELECT '1|2&!3'::tsquery;
SELECT '1|!2&3'::tsquery;
SELECT '!1|2&3'::tsquery;
SELECT '!1|(2&3)'::tsquery;
SELECT '!(1|2)&3'::tsquery;
SELECT '(!1|2)&3'::tsquery;
SELECT '1|(2|(4|(5|6)))'::tsquery;
SELECT '1|2|4|5|6'::tsquery;
SELECT '1&(2&(4&(5&6)))'::tsquery;
SELECT '1&2&4&5&6'::tsquery;
SELECT '1&(2&(4&(5|6)))'::tsquery;
SELECT '1&(2&(4&(5|!6)))'::tsquery;
SELECT '1&(''2''&('' 4''&(\\\\|5 | ''6 \\\\'' !|&'')))'::tsquery;
SELECT '''\\\\\\\\as'''::tsquery;
SELECT 'a:* & nbb:*ac | doo:a* | goo'::tsquery;
SELECT 'a <-> (b|c)'::tsquery;
SELECT '(a|b) <-> c'::tsquery;
SELECT '(a|b) <-> (d|c)'::tsquery;
SELECT 'a <-> (b&c)'::tsquery;
SELECT '(a&b) <-> c'::tsquery;
SELECT '(a&b) <-> (d&c)'::tsquery;
SELECT 'a <-> !b'::tsquery;
SELECT '!a <-> b'::tsquery;
SELECT '!a <-> !b'::tsquery;
SELECT 'a <-> !(b&c)'::tsquery;
SELECT 'a <-> !(b|c)'::tsquery;
SELECT '!(a&b) <-> c'::tsquery;
SELECT '!(a|b) <-> c'::tsquery;
SELECT '(!a|b) <-> c'::tsquery;
SELECT '(!a&b) <-> c'::tsquery;
SELECT 'c <-> (!a|b)'::tsquery;
SELECT 'c <-> (!a&b)'::tsquery;
SELECT '(a|b) <-> !c'::tsquery;
SELECT '(a&b) <-> !c'::tsquery;
SELECT '!c <-> (a|b)'::tsquery;
SELECT '!c <-> (a&b)'::tsquery;
SELECT 'a' < 'b & c'::tsquery AS \\"true\\";
SELECT 'a' > 'b & c'::tsquery AS \\"false\\";
SELECT 'a | f' < 'b & c'::tsquery AS \\"false\\";
SELECT 'a | ff' < 'b & c'::tsquery AS \\"false\\";
SELECT 'a | f | g' < 'b & c'::tsquery AS \\"false\\";
SELECT numnode('new'::tsquery);
SELECT numnode('new & york'::tsquery);
SELECT numnode('new & york | qwery'::tsquery);
SELECT 'foo & bar'::tsquery && 'asd';
SELECT 'foo & bar'::tsquery || 'asd & fg';
SELECT 'foo & bar'::tsquery || (!!'asd & fg'::tsquery);
SELECT 'foo & bar'::tsquery && 'asd | fg';
SELECT 'a' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b & d'::tsquery;
SELECT 'a & g' <-> 'b | d'::tsquery;
SELECT 'a & g' <-> 'b <-> d'::tsquery;
SELECT tsquery_phrase('a <3> g', 'b & d', 10);
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:B' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:A' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:C' AS \\"false\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:CB' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"false\\";
SELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*CB' AS \\"true\\";
SELECT 'a b:89  ca:23A,64b cb:80c d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"true\\";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*C' AS \\"true\\";
SELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*B' AS \\"true\\";
SELECT 'supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supeanova supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supeznova supernova'::tsvector @@ 'super'::tsquery AS \\"false\\";
SELECT 'supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT 'supeanova supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT 'supeznova supernova'::tsvector @@ 'super:*'::tsquery AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 2' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 2' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 3' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 11 3') @@ '1 <-> 3' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 11 3') @@ '1:* <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> 2 <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> (2 <-> 3)' AS \\"false\\";
SELECT to_tsvector('simple', '1 2 3 4') @@ '1 <2> (2 <-> 3)' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \\"true\\";
SELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '1 <-> 2 <-> 3' AS \\"true\\";
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s:*');
SELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 sa:3C sab:2c d g'::tsvector, 'a | sa:*');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a | s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a & s');
SELECT ts_rank_cd(' a:1 s:2A d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2 d:2A g'::tsvector, 'a <-> s');
SELECT ts_rank_cd(' a:1 s:2,3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 b:2 s:3A d:2A g'::tsvector, 'a <2> s:A');
SELECT ts_rank_cd(' a:1 sa:2D sb:2A g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:*');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:A');
SELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:B');
SELECT 'a:1 b:2'::tsvector @@ 'a <-> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <0> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <1> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:2'::tsvector @@ 'a <2> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <-> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <0> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <1> b'::tsquery AS \\"false\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <2> b'::tsquery AS \\"true\\";
SELECT 'a:1 b:3'::tsvector @@ 'a <3> b'::tsquery AS \\"true\\";
SELECT strip('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd'::tsvector);
SELECT strip('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT strip('base hidden rebel spaceship strike'::tsvector);
SELECT ts_delete(to_tsvector('english', 'Rebel spaceships, striking from a hidden base'), 'spaceship');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'base');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bas');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bases');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'spaceship');
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, 'spaceship');
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceships', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceshi', 'rebel']);
SELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship', 'leya', 'rebel']);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship', 'leya', 'rebel']);
SELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship', 'leya', 'rebel', NULL]);
SELECT unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT unnest('base hidden rebel spaceship strike'::tsvector);
SELECT * FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT * FROM unnest('base hidden rebel spaceship strike'::tsvector);
SELECT lexeme,
(positions)[1] FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);
SELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);
SELECT array_to_tsvector(ARRAY['base', 'hidden', 'rebel', 'spaceship', 'strike']);
SELECT array_to_tsvector(ARRAY['base', 'hidden', 'rebel', 'spaceship', NULL]);
SELECT setweight('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd zxc:81,567,222A'::tsvector, 'c');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');
SELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a,zxc}');
SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', '{a,zxc}');
SELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', NULL]);
SELECT ts_filter('base:7A empir:17 evil:15 first:11 galact:16 hidden:6A rebel:1A spaceship:2A strike:3A victori:12 won:9'::tsvector, '{a}');
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a}');
SELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a,b,NULL}');"
`;

exports[`kitchen sink upstream upstream/txid.sql 1`] = `
"SELECT '12:13:'::txid_snapshot;
SELECT '12:18:14,16'::txid_snapshot;
SELECT '12:16:14,14'::txid_snapshot;
SELECT '31:12:'::txid_snapshot;
SELECT '0:1:'::txid_snapshot;
SELECT '12:13:0'::txid_snapshot;
SELECT '12:16:14,13'::txid_snapshot;
CREATE TEMPORARY TABLE snapshot_test (
nr int,
snap txid_snapshot
);
INSERT INTO snapshot_test VALUES (1, '12:13:');
INSERT INTO snapshot_test VALUES (2, '12:20:13,15,18');
INSERT INTO snapshot_test VALUES (3, '100001:100009:100005,100007,100008');
INSERT INTO snapshot_test VALUES (4, '100:150:101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131');
SELECT snap FROM snapshot_test ORDER BY nr;
SELECT txid_snapshot_xmin(snap),
txid_snapshot_xmax(snap),
txid_snapshot_xip(snap) FROM snapshot_test ORDER BY nr;
SELECT id,
txid_visible_in_snapshot(id, snap) FROM snapshot_test,
generate_series(11, 21) AS id WHERE nr = 2;
SELECT id,
txid_visible_in_snapshot(id, snap) FROM snapshot_test,
generate_series(90, 160) AS id WHERE nr = 4;
SELECT txid_current() >= txid_snapshot_xmin(txid_current_snapshot());
SELECT txid_visible_in_snapshot(txid_current(), txid_current_snapshot());
SELECT '1000100010001000:1000100010001100:1000100010001012,1000100010001013'::txid_snapshot;
SELECT txid_visible_in_snapshot('1000100010001012', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT txid_visible_in_snapshot('1000100010001015', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT '1:9223372036854775807:3'::txid_snapshot;
SELECT '1:9223372036854775808:3'::txid_snapshot;"
`;

exports[`kitchen sink upstream upstream/txid.sql 2`] = `
"SELECT '12:13:'::txid_snapshot;
SELECT '12:18:14,16'::txid_snapshot;
SELECT '12:16:14,14'::txid_snapshot;
SELECT '31:12:'::txid_snapshot;
SELECT '0:1:'::txid_snapshot;
SELECT '12:13:0'::txid_snapshot;
SELECT '12:16:14,13'::txid_snapshot;
CREATE TEMPORARY TABLE snapshot_test (
nr int,
snap txid_snapshot
);
INSERT INTO snapshot_test VALUES (1, '12:13:');
INSERT INTO snapshot_test VALUES (2, '12:20:13,15,18');
INSERT INTO snapshot_test VALUES (3, '100001:100009:100005,100007,100008');
INSERT INTO snapshot_test VALUES (4, '100:150:101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131');
SELECT snap FROM snapshot_test ORDER BY nr;
SELECT txid_snapshot_xmin(snap),
txid_snapshot_xmax(snap),
txid_snapshot_xip(snap) FROM snapshot_test ORDER BY nr;
SELECT id,
txid_visible_in_snapshot(id, snap) FROM snapshot_test,
generate_series(11, 21) AS id WHERE nr = 2;
SELECT id,
txid_visible_in_snapshot(id, snap) FROM snapshot_test,
generate_series(90, 160) AS id WHERE nr = 4;
SELECT txid_current() >= txid_snapshot_xmin(txid_current_snapshot());
SELECT txid_visible_in_snapshot(txid_current(), txid_current_snapshot());
SELECT '1000100010001000:1000100010001100:1000100010001012,1000100010001013'::txid_snapshot;
SELECT txid_visible_in_snapshot('1000100010001012', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT txid_visible_in_snapshot('1000100010001015', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');
SELECT '1:9223372036854775807:3'::txid_snapshot;
SELECT '1:9223372036854775808:3'::txid_snapshot;"
`;

exports[`kitchen sink upstream upstream/varchar.sql 1`] = `
"CREATE TABLE varchar_tbl (
f1 varchar(1)
);
INSERT INTO varchar_tbl (f1) VALUES ('a');
INSERT INTO varchar_tbl (f1) VALUES ('A');
INSERT INTO varchar_tbl (f1) VALUES ('1');
INSERT INTO varchar_tbl (f1) VALUES (2);
INSERT INTO varchar_tbl (f1) VALUES ('3');
INSERT INTO varchar_tbl (f1) VALUES ('');
INSERT INTO varchar_tbl (f1) VALUES ('cd');
INSERT INTO varchar_tbl (f1) VALUES ('c     ');
SELECT '' AS seven,
* FROM varchar_tbl;
SELECT '' AS six,
c.* FROM varchar_tbl AS c WHERE c.f1 <> 'a';
SELECT '' AS one,
c.* FROM varchar_tbl AS c WHERE c.f1 = 'a';
SELECT '' AS five,
c.* FROM varchar_tbl AS c WHERE c.f1 < 'a';
SELECT '' AS six,
c.* FROM varchar_tbl AS c WHERE c.f1 <= 'a';
SELECT '' AS one,
c.* FROM varchar_tbl AS c WHERE c.f1 > 'a';
SELECT '' AS two,
c.* FROM varchar_tbl AS c WHERE c.f1 >= 'a';
DROP TABLE varchar_tbl;
CREATE TABLE varchar_tbl (
f1 varchar(4)
);
INSERT INTO varchar_tbl (f1) VALUES ('a');
INSERT INTO varchar_tbl (f1) VALUES ('ab');
INSERT INTO varchar_tbl (f1) VALUES ('abcd');
INSERT INTO varchar_tbl (f1) VALUES ('abcde');
INSERT INTO varchar_tbl (f1) VALUES ('abcd    ');
SELECT '' AS four,
* FROM varchar_tbl;"
`;

exports[`kitchen sink upstream upstream/varchar.sql 2`] = `
"CREATE TABLE varchar_tbl (
f1 varchar(1)
);
INSERT INTO varchar_tbl ( f1 ) VALUES ('a');
INSERT INTO varchar_tbl ( f1 ) VALUES ('A');
INSERT INTO varchar_tbl ( f1 ) VALUES ('1');
INSERT INTO varchar_tbl ( f1 ) VALUES (2);
INSERT INTO varchar_tbl ( f1 ) VALUES ('3');
INSERT INTO varchar_tbl ( f1 ) VALUES ('');
INSERT INTO varchar_tbl ( f1 ) VALUES ('cd');
INSERT INTO varchar_tbl ( f1 ) VALUES ('c     ');
SELECT '' AS seven,
* FROM varchar_tbl;
SELECT '' AS six,
c.* FROM varchar_tbl AS c WHERE c.f1 <> 'a';
SELECT '' AS one,
c.* FROM varchar_tbl AS c WHERE c.f1 = 'a';
SELECT '' AS five,
c.* FROM varchar_tbl AS c WHERE c.f1 < 'a';
SELECT '' AS six,
c.* FROM varchar_tbl AS c WHERE c.f1 <= 'a';
SELECT '' AS one,
c.* FROM varchar_tbl AS c WHERE c.f1 > 'a';
SELECT '' AS two,
c.* FROM varchar_tbl AS c WHERE c.f1 >= 'a';
DROP TABLE varchar_tbl;
CREATE TABLE varchar_tbl (
f1 varchar(4)
);
INSERT INTO varchar_tbl ( f1 ) VALUES ('a');
INSERT INTO varchar_tbl ( f1 ) VALUES ('ab');
INSERT INTO varchar_tbl ( f1 ) VALUES ('abcd');
INSERT INTO varchar_tbl ( f1 ) VALUES ('abcde');
INSERT INTO varchar_tbl ( f1 ) VALUES ('abcd    ');
SELECT '' AS four,
* FROM varchar_tbl;"
`;

exports[`kitchen sink views create 1`] = `
"CREATE VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE MATERIALIZED VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname NOT IN ( 'pg_catalog', 'information_schema', 'pg_toast' ) AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname IN ( 'pg_catalog', 'information_schema', 'pg_toast' ) AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;"
`;

exports[`kitchen sink views create 2`] = `
"CREATE VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE MATERIALIZED VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast') AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname IN ('pg_catalog', 'information_schema', 'pg_toast') AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;"
`;

exports[`parens 1`] = `
"SELECT (node->'relation')->'RangeVar' IS NOT NULL FROM my_json_store;
SELECT (node->'relation')->'RangeVar' IS NOT NULL AND ((node->'relation')->'RangeVar')->>'inh' IS NULL FROM my_json_store;
SELECT (a IS NOT NULL AND b IS NULL) OR (c IS NOT NULL AND (a->'inh')::bool IS FALSE) FROM my_json_store;
SELECT ((node->'relation')->'RangeVar' IS NOT NULL AND ((node->'relation')->'RangeVar')->'inh' IS NULL) OR (((node->'relation')->'RangeVar')->'inh' IS NOT NULL AND (((node->'relation')->'RangeVar')->'inh')::bool IS FALSE) FROM my_json_store;
SELECT (a AND b AND c) OR d FROM t;
SELECT (a AND b AND c) OR d OR ((e AND f) OR g) FROM t;
SELECT (a AND b AND c::bool IS TRUE) OR d OR ((e AND f) OR g) FROM t;
SELECT (NOT ((a AND b)) AND c) OR NOT (d) FROM t;
SELECT NOT ((a AND b)) AND c FROM t;
SELECT NOT ((a AND b)) AND c FROM t;"
`;

exports[`parens 2`] = `
"SELECT (node->'relation')->'RangeVar' IS NOT NULL FROM my_json_store;
SELECT (node->'relation')->'RangeVar' IS NOT NULL AND ((node->'relation')->'RangeVar')->>'inh' IS NULL FROM my_json_store;
SELECT (a IS NOT NULL AND b IS NULL) OR (c IS NOT NULL AND (a->'inh')::bool IS FALSE) FROM my_json_store;
SELECT ((node->'relation')->'RangeVar' IS NOT NULL AND ((node->'relation')->'RangeVar')->'inh' IS NULL) OR (((node->'relation')->'RangeVar')->'inh' IS NOT NULL AND (((node->'relation')->'RangeVar')->'inh')::bool IS FALSE) FROM my_json_store;
SELECT (a AND b AND c) OR d FROM t;
SELECT (a AND b AND c) OR d OR ((e AND f) OR g) FROM t;
SELECT (a AND b AND c::bool IS TRUE) OR d OR ((e AND f) OR g) FROM t;
SELECT (NOT ((a AND b)) AND c) OR NOT (d) FROM t;
SELECT NOT ((a AND b)) AND c FROM t;
SELECT NOT ((a AND b)) AND c FROM t;"
`;
