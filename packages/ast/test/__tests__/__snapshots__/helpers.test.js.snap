// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`drops 1`] = `
"DROP POLICY policy_name ON schema_name.table_name;
DROP POLICY policy_name ON table_name;
REVOKE DELETE ON TABLE schema_name.table_name FROM authenticated;
REVOKE DELETE ON TABLE table_name FROM authenticated;
DROP TABLE table_name;
DROP TABLE schema_name.table_name;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".\\"aa-bdd\\" DROP COLUMN \\"sdf-sdf\\";
ALTER TABLE \\"table-name\\" DROP COLUMN column_name;
ALTER TABLE table_name DROP COLUMN column_name;
DROP SEQUENCE IF EXISTS hsseq;
DROP SEQUENCE IF EXISTS \\"some-thing\\".hsseq;
ALTER TABLE schemaname.table_name RENAME COLUMN column_name1 TO new_column_name1;
ALTER TABLE table_name RENAME COLUMN column_name1 TO new_column_name1;
DROP TYPE test_type;
DROP TYPE schema_name.test_type;
DROP TYPE \\"schema-name\\".test_type;
DROP TYPE \\"schema-name\\".\\"test-type\\";
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE IF EXISTS \\"aa-bb\\".test_type_exists;
DROP TYPE eitype CASCADE;
DROP DOMAIN testdomain2b;
DROP DOMAIN schema_name.testdomain2b;
DROP FUNCTION testfunc5b ( testdomain1 );
DROP FUNCTION \\"my-schema\\".testfunc5b ( testdomain1 );
DROP FUNCTION testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".\\"test-func6b\\" ( int );
DROP FUNCTION testfunc7777;
DROP FUNCTION \\"my-schema\\".testfunc7777;
DROP TRIGGER trigger_name ON table_name;
DROP TRIGGER IF EXISTS trigger_name ON table_name;
DROP TRIGGER trigger_name ON schema_name.table_name;
DROP TRIGGER IF EXISTS trigger_name ON schema_name.table_name;
DROP RULE rule_name ON table_name;
DROP RULE IF EXISTS rule_name ON table_name;
DROP RULE rule_name ON schema_name.table_name;
DROP RULE IF EXISTS rule_name ON schema_name.table_name;
DROP VIEW IF EXISTS test_view_exists;
DROP VIEW test_view_exists;
DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP AGGREGATE IF EXISTS no_such_schema.foo ( int );
DROP AGGREGATE IF EXISTS foo ( no_such_type );
DROP AGGREGATE IF EXISTS foo ( no_such_schema.no_such_type );
DROP CAST IF EXISTS ( int AS no_such_type2 );
DROP CAST IF EXISTS ( no_such_type1 AS int );
DROP CAST IF EXISTS ( int AS no_such_schema.bar );
DROP CAST IF EXISTS ( no_such_schema.foo AS int );
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP INDEX IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;"
`;

exports[`drops 2`] = `
"DROP POLICY policy_name ON schema_name.table_name;
DROP POLICY policy_name ON table_name;
REVOKE DELETE ON TABLE schema_name.table_name FROM authenticated;
REVOKE DELETE ON TABLE table_name FROM authenticated;
DROP TABLE table_name;
DROP TABLE schema_name.table_name;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".table_name DROP COLUMN column_name;
ALTER TABLE \\"schema-name\\".\\"aa-bdd\\" DROP COLUMN \\"sdf-sdf\\";
ALTER TABLE \\"table-name\\" DROP COLUMN column_name;
ALTER TABLE table_name DROP COLUMN column_name;
DROP SEQUENCE IF EXISTS hsseq;
DROP SEQUENCE IF EXISTS \\"some-thing\\".hsseq;
ALTER TABLE schemaname.table_name RENAME COLUMN column_name1 TO new_column_name1;
ALTER TABLE table_name RENAME COLUMN column_name1 TO new_column_name1;
DROP TYPE test_type;
DROP TYPE schema_name.test_type;
DROP TYPE \\"schema-name\\".test_type;
DROP TYPE \\"schema-name\\".\\"test-type\\";
DROP TYPE IF EXISTS test_type_exists;
DROP TYPE IF EXISTS \\"aa-bb\\".test_type_exists;
DROP TYPE eitype CASCADE;
DROP DOMAIN testdomain2b;
DROP DOMAIN schema_name.testdomain2b;
DROP FUNCTION testfunc5b ( testdomain1 );
DROP FUNCTION \\"my-schema\\".testfunc5b ( testdomain1 );
DROP FUNCTION testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".testfunc6b ( int );
DROP FUNCTION \\"my-schema\\".\\"test-func6b\\" ( int );
DROP FUNCTION testfunc7777;
DROP FUNCTION \\"my-schema\\".testfunc7777;
DROP TRIGGER trigger_name ON table_name;
DROP TRIGGER IF EXISTS trigger_name ON table_name;
DROP TRIGGER trigger_name ON schema_name.table_name;
DROP TRIGGER IF EXISTS trigger_name ON schema_name.table_name;
DROP RULE rule_name ON table_name;
DROP RULE IF EXISTS rule_name ON table_name;
DROP RULE rule_name ON schema_name.table_name;
DROP RULE IF EXISTS rule_name ON schema_name.table_name;
DROP VIEW IF EXISTS test_view_exists;
DROP VIEW test_view_exists;
DROP EXTENSION test_extension_exists;
DROP EXTENSION IF EXISTS test_extension_exists;
DROP FOREIGN DATA WRAPPER test_fdw_exists;
DROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;
DROP AGGREGATE IF EXISTS no_such_schema.foo ( int );
DROP AGGREGATE IF EXISTS foo ( no_such_type );
DROP AGGREGATE IF EXISTS foo ( no_such_schema.no_such_type );
DROP CAST IF EXISTS ( int AS no_such_type2 );
DROP CAST IF EXISTS ( no_such_type1 AS int );
DROP CAST IF EXISTS ( int AS no_such_schema.bar );
DROP CAST IF EXISTS ( no_such_schema.foo AS int );
DROP COLLATION IF EXISTS no_such_schema.foo;
DROP CONVERSION IF EXISTS no_such_schema.foo;
DROP DOMAIN IF EXISTS no_such_schema.foo;
DROP FOREIGN TABLE IF EXISTS no_such_schema.foo;
DROP INDEX IF EXISTS no_such_schema.foo;
DROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;"
`;

exports[`kitchen sink alias 1`] = `
"SELECT * FROM generate_series(1, 1) AS \\"a#b\\";
SELECT * FROM generate_series(1, 1) AS \\"a#b\\" (\\"c#d\\");
SELECT * FROM generate_series(1, 1) AS aba;
SELECT * FROM generate_series(1, 1) AS aba (ccd);"
`;

exports[`kitchen sink alias 2`] = `
"SELECT * FROM generate_series(1, 1) AS \\"a#b\\";
SELECT * FROM generate_series(1, 1) AS \\"a#b\\"(\\"c#d\\");
SELECT * FROM generate_series(1, 1) AS aba;
SELECT * FROM generate_series(1, 1) AS aba(ccd);"
`;

exports[`kitchen sink alter 1`] = `
"CREATE SCHEMA IF NOT EXISTS app_jobs;
CREATE TABLE app_jobs.job_queues (
queue_name varchar NOT NULL PRIMARY KEY,
job_count int DEFAULT (0) NOT NULL,
locked_at pg_catalog.timestamptz,
locked_by varchar
);
ALTER TABLE app_jobs.job_queues ENABLE ROW LEVEL SECURITY;
CREATE TABLE foo (
name text,
foo_timestamp timestampz DEFAULT (CURRENT_DATE)
);
ALTER TABLE foo RENAME COLUMN name TO city;
ALTER TABLE foo ALTER COLUMN foo_timestamp DROP DEFAULT, ALTER COLUMN foo_timestamp TYPE pg_catalog.timestamptz USING 'epoch'::pg_catalog.timestamptz + foo_timestamp * '1 second'::interval, ALTER COLUMN foo_timestamp SET DEFAULT now();
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE CASCADE ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE RESTRICT ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE SET NULL ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id)  ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE SET NULL ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (a, b) REFERENCES othr.orders (c, d)   MATCH FULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY (a, b) REFERENCES othr.orders (c, d)  ;
ALTER TABLE ONLY collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);
ALTER TABLE collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ADD COLUMN column_name column_type;
ALTER TABLE schema_name.table_name ADD COLUMN column_name geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN \\"column-name\\" geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN column_name int;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;"
`;

exports[`kitchen sink alter 2`] = `
"CREATE SCHEMA IF NOT EXISTS app_jobs;
CREATE TABLE app_jobs.job_queues (
queue_name varchar NOT NULL PRIMARY KEY,
job_count int DEFAULT ( 0 ) NOT NULL,
locked_at pg_catalog.timestamptz,
locked_by varchar
);
ALTER TABLE app_jobs.job_queues ENABLE ROW LEVEL SECURITY;
CREATE TABLE foo (
name text,
foo_timestamp timestampz DEFAULT ( CURRENT_DATE )
);
ALTER TABLE foo RENAME COLUMN name TO city;
ALTER TABLE foo ALTER COLUMN foo_timestamp DROP DEFAULT, ALTER COLUMN foo_timestamp TYPE pg_catalog.timestamptz USING (('epoch'::pg_catalog.timestamptz) + (((foo_timestamp) * ('1 second'::interval)))), ALTER COLUMN foo_timestamp SET DEFAULT now();
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE CASCADE;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE RESTRICT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id );
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET NULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( order_id ) REFERENCES othr.orders ( id ) ON DELETE SET NULL ON UPDATE SET DEFAULT;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( a, b ) REFERENCES othr.orders ( c, d ) MATCH FULL;
ALTER TABLE scha.foo ADD CONSTRAINT my_constraint_fey FOREIGN KEY ( a, b ) REFERENCES othr.orders ( c, d );
ALTER TABLE ONLY collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY ( id );
ALTER TABLE collections.mfield ADD CONSTRAINT col_field_pkey PRIMARY KEY ( id );
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;
ALTER TABLE schema_name.table_name ADD COLUMN  column_name column_type;
ALTER TABLE schema_name.table_name ADD COLUMN  column_name geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN  \\"column-name\\" geometry(polygon, 4326);
ALTER TABLE schema_name.table_name ADD COLUMN  column_name int;
ALTER TABLE schema_name.table_name DROP COLUMN column_name;"
`;

exports[`kitchen sink conflicts 1`] = `
"INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name;
INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO UPDATE SET field_name = EXCLUDED.field_name WHERE prop = 1;
INSERT INTO yo.\\"table\\" (project_id, name, field_name) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT (project_id, name) DO NOTHING;
INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ON CONSTRAINT customers_name_key DO NOTHING;
INSERT INTO customers (name, email) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT (name) DO UPDATE SET email = EXCLUDED.email || ';' || customers.email;"
`;

exports[`kitchen sink conflicts 2`] = `
"INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO UPDATE  SET field_name = excluded.field_name;
INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO UPDATE  SET field_name = excluded.field_name WHERE ((prop) = (1));
INSERT INTO yo.\\"table\\" ( project_id, name, field_name ) VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value) ON CONFLICT ( project_id, name ) DO NOTHING;
INSERT INTO customers ( name, email ) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ON CONSTRAINT customers_name_key DO NOTHING;
INSERT INTO customers ( name, email ) VALUES ('Microsoft', 'hotline@microsoft.com') ON CONFLICT ( name ) DO UPDATE  SET email = ((((excluded.email) || (';'))) || (customers.email));"
`;

exports[`kitchen sink default privs 1`] = `
"ALTER DEFAULT PRIVILEGES IN SCHEMA objects_public
GRANT EXECUTE ON FUNCTIONS  TO authenticated;
ALTER DEFAULT PRIVILEGES REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT SELECT ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT INSERT ON TABLES  TO webuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE SELECT ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE INSERT ON TABLES  FROM webuser;
ALTER DEFAULT PRIVILEGES FOR ROLE admin
REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;"
`;

exports[`kitchen sink default privs 2`] = `
"ALTER DEFAULT PRIVILEGES IN SCHEMA objects_public
GRANT EXECUTE ON FUNCTIONS  TO authenticated;
ALTER DEFAULT PRIVILEGES REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT SELECT ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
GRANT INSERT ON TABLES  TO webuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE SELECT ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA myschema
REVOKE INSERT ON TABLES  FROM webuser;
ALTER DEFAULT PRIVILEGES FOR ROLE admin
REVOKE EXECUTE ON FUNCTIONS  FROM PUBLIC;"
`;

exports[`kitchen sink delete 1`] = `
"DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
DELETE FROM delete_test AS dt WHERE dt.a > 75;
DELETE FROM delete_test AS dt WHERE delete_test.a > 25;
DELETE FROM delete_test WHERE a > 25;"
`;

exports[`kitchen sink delete 2`] = `
"DELETE FROM shoelace_data WHERE ((sl_name) = (old.sl_name));
DELETE FROM delete_test AS dt WHERE ((dt.a) > (75));
DELETE FROM delete_test AS dt WHERE ((delete_test.a) > (25));
DELETE FROM delete_test WHERE ((a) > (25));"
`;

exports[`kitchen sink do stmt 1`] = `
"DO $CODEZ$
BEGIN
IF NOT EXISTS (
SELECT
1
FROM
pg_roles
WHERE
rolname = 'administrator') THEN
CREATE ROLE administrator;
COMMENT ON ROLE administrator IS 'Administration group';
END IF;
END $CODEZ$;"
`;

exports[`kitchen sink do stmt 2`] = `
"DO $$
BEGIN
IF NOT EXISTS (
SELECT
1
FROM
pg_roles
WHERE
rolname = 'administrator') THEN
CREATE ROLE administrator;
COMMENT ON ROLE administrator IS 'Administration group';
END IF;
END $$;"
`;

exports[`kitchen sink domain 1`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK (value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$');"
`;

exports[`kitchen sink domain 2`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK ( ((value) ~ ('^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$')) );"
`;

exports[`kitchen sink domains 1`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK (value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$');"
`;

exports[`kitchen sink domains 2`] = `
"CREATE DOMAIN v8.json AS json;
CREATE DOMAIN email AS citext CHECK ( ((value) ~ ('^[a-zA-Z0-9.!#$%&''*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$')) );"
`;

exports[`kitchen sink enums 1`] = `
"CREATE TYPE myschema.special_type AS ENUM (
'oh',
'yea'
);"
`;

exports[`kitchen sink enums 2`] = `
"CREATE TYPE myschema.special_type AS ENUM (
'oh',
'yea'
);"
`;

exports[`kitchen sink fixtures complex.sql 1`] = `
"SELECT p1.playerid,
f1.playername,
p2.playerid,
f2.playername FROM player AS f1,
player AS f2,
plays AS p1 FULL OUTER JOIN plays AS p2 ON p1.playerid < p2.playerid AND p1.teamid = p2.teamid GROUP BY p1.playerid,
f1.playerid,
p2.playerid,
f2.playerid HAVING count(p1.playerid) = count(*) AND count(p2.playerid) = count(*) AND p1.playerid = f1.playerid AND p2.playerid = f2.playerid;"
`;

exports[`kitchen sink fixtures complex.sql 2`] = `
"SELECT p1.playerid,
f1.playername,
p2.playerid,
f2.playername FROM player AS f1,
player AS f2,
plays AS p1 FULL OUTER JOIN plays AS p2 ON (((p1.playerid) < (p2.playerid)) AND ((p1.teamid) = (p2.teamid))) GROUP BY p1.playerid,
f1.playerid,
p2.playerid,
f2.playerid HAVING (((count(p1.playerid)) = (count(*))) AND ((count(p2.playerid)) = (count(*))) AND ((p1.playerid) = (f1.playerid)) AND ((p2.playerid) = (f2.playerid)));"
`;

exports[`kitchen sink fixtures custom.sql 1`] = `
"SELECT * FROM tab ORDER BY col USING <;
SELECT * FROM tab ORDER BY col USING >;
SELECT * FROM tab ORDER BY col USING =;
SELECT * FROM tab ORDER BY col USING = NULLS FIRST,
col2 USING < NULLS LAST;
SELECT mleast(VARIADIC arr:=ARRAY[10, (-1), 5, 4.4]);
SELECT encode('''123\\\\000\\\\001', 'base64');
SELECT 'слон';
SELECT 'data';
SELECT 3 OPERATOR(pg_catalog.+) 4;
SELECT * FROM ROWS FROM (getfoo6(1) AS (fooid int, foosubid int, fooname text), getfoo7(1) AS (fooid int, foosubid int, fooname text)) AS (fooid int, foosubid int, fooname text);
SELECT a FROM b WHERE a < (SELECT 1);
SELECT a FROM b WHERE a < ALL (SELECT 1);
SELECT a FROM b WHERE a < ANY (SELECT 1);
SELECT a FROM b WHERE EXISTS (SELECT 1);
SELECT a FROM b WHERE a < ARRAY (SELECT DISTINCT (SELECT 1),
(SELECT DISTINCT 1 GROUP BY 7 HAVING 1 < (SELECT 1)));
SELECT 1 WHERE 'abc' SIMILAR TO 'abc' ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE 't';
SELECT 1::bit(1);
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
SHOW client_encoding;"
`;

exports[`kitchen sink fixtures custom.sql 2`] = `
"SELECT * FROM tab ORDER BY col USING <;
SELECT * FROM tab ORDER BY col USING >;
SELECT * FROM tab ORDER BY col USING =;
SELECT * FROM tab ORDER BY col USING = NULLS FIRST,
col2 USING < NULLS LAST;
SELECT mleast(VARIADIC arr := ARRAY[10, (-1), 5, 4.4]);
SELECT encode('''123\\\\000\\\\001', 'base64');
SELECT 'слон';
SELECT 'data';
SELECT ((3) OPERATOR(pg_catalog.+) (4));
SELECT * FROM ROWS FROM (getfoo6(1) AS (fooid int, foosubid int, fooname text), getfoo7(1) AS (fooid int, foosubid int, fooname text))  AS (fooid int, foosubid int, fooname text);
SELECT a FROM b WHERE ((a) < ((SELECT 1)));
SELECT a FROM b WHERE a < ALL (SELECT 1);
SELECT a FROM b WHERE a < ANY (SELECT 1);
SELECT a FROM b WHERE EXISTS (SELECT 1);
SELECT a FROM b WHERE ((a) < (ARRAY (SELECT DISTINCT (SELECT 1),
(SELECT DISTINCT 1 GROUP BY 7 HAVING ((1) < ((SELECT 1)))))));
SELECT 1 WHERE 'abc' SIMILAR TO 'abc' ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE NULL;
SELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE 't';
SELECT 1::bit(1);
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
SHOW client_encoding;"
`;

exports[`kitchen sink fixtures param-ref.sql 1`] = `
"SELECT * FROM table_name WHERE name = ?;
SELECT * FROM table_name WHERE name = $1;
SELECT $1::text AS name;"
`;

exports[`kitchen sink fixtures param-ref.sql 2`] = `
"SELECT * FROM table_name WHERE ((name) = (?));
SELECT * FROM table_name WHERE ((name) = ($1));
SELECT $1::text AS name;"
`;

exports[`kitchen sink fixtures query-001.sql 1`] = `
"SELECT array_agg(players),
player_teams FROM (SELECT DISTINCT t1.t1player AS players_dist,
t1.player_teams FROM (SELECT p.playerid AS t1id,
concat(p.playerid, ':', p.playername, ' ') AS t1player,
array_agg(pl.teamid ORDER BY pl.teamid ) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t1 INNER JOIN (SELECT p.playerid AS t2id,
array_agg(pl.teamid ORDER BY pl.teamid ) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON p.playerid = pl.playerid GROUP BY p.playerid,
p.playername) AS t2 ON t1.player_teams = t2.player_teams AND t1.t1id <> t2.t2id) AS innerquery GROUP BY player_teams;"
`;

exports[`kitchen sink fixtures query-001.sql 2`] = `
"SELECT array_agg(players),
player_teams FROM (SELECT DISTINCT t1.t1player AS players_dist,
t1.player_teams FROM (SELECT p.playerid AS t1id,
concat(p.playerid, ':', p.playername, ' ') AS t1player,
array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON ((p.playerid) = (pl.playerid)) GROUP BY p.playerid,
p.playername) AS t1 INNER JOIN (SELECT p.playerid AS t2id,
array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams FROM player AS p LEFT OUTER JOIN plays AS pl ON ((p.playerid) = (pl.playerid)) GROUP BY p.playerid,
p.playername) AS t2 ON (((t1.player_teams) = (t2.player_teams)) AND ((t1.t1id) <> (t2.t2id)))) AS innerquery GROUP BY player_teams;"
`;

exports[`kitchen sink fixtures query-002.sql 1`] = `"SELECT * FROM \\"Foo\\" AS f1 WHERE f1.\\"FooUID\\" = (SELECT f2.\\"FooUID\\" FROM \\"Foo\\" AS f2 LEFT OUTER JOIN \\"Bar\\" AS b ON f2.\\"BarUID\\" = b.\\"BarUID\\" WHERE f2.\\"BarUID\\" IS NOT NULL AND b.\\"BarUID\\" IS NULL LIMIT 1)"`;

exports[`kitchen sink fixtures query-002.sql 2`] = `"SELECT * FROM \\"Foo\\" AS f1 WHERE ((f1.\\"FooUID\\") = ((SELECT f2.\\"FooUID\\" FROM \\"Foo\\" AS f2 LEFT OUTER JOIN \\"Bar\\" AS b ON ((f2.\\"BarUID\\") = (b.\\"BarUID\\")) WHERE (f2.\\"BarUID\\" IS NOT NULL AND b.\\"BarUID\\" IS NULL) LIMIT 1)))"`;

exports[`kitchen sink fixtures query-003.sql 1`] = `"SELECT ((SELECT ROW(1, 1, 1, 1)::test)::test).*;"`;

exports[`kitchen sink fixtures query-003.sql 2`] = `"SELECT ((SELECT ROW(1, 1, 1, 1)::test)::test).*;"`;

exports[`kitchen sink fixtures simple.sql 1`] = `
"SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name LIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT LIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name ILIKE ( '%''test''%' );
SELECT * FROM table_name WHERE name = 'test' AND num > 7 AND last_name NOT ILIKE ( '%''test''%' );
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name > first_name;
SELECT * FROM table_name WHERE last_name <> first_name;
SELECT * FROM table_name WHERE last_name = ANY( stuff );
SELECT * FROM table_name WHERE last_name = ALL( stuff );
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id = ANY (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama');
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE NOT (category_id IN (SELECT category_id FROM category WHERE name = 'Action' OR name = 'Drama'));
SELECT title FROM film WHERE length >= ANY (SELECT max(length) FROM film JOIN film_category USING (film_id) GROUP BY category_id);
SELECT * FROM transactions.transaction WHERE transaction_date BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;
SELECT * FROM transactions.transaction WHERE transaction_date NOT BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND owner = 0;"
`;

exports[`kitchen sink fixtures simple.sql 2`] = `
"SELECT * FROM table_name WHERE (((name) = ('test')) AND ((num) > (7)) AND last_name LIKE ('%''test''%'));
SELECT * FROM table_name WHERE (((name) = ('test')) AND ((num) > (7)) AND last_name NOT LIKE ('%''test''%'));
SELECT * FROM table_name WHERE (((name) = ('test')) AND ((num) > (7)) AND last_name ILIKE ('%''test''%'));
SELECT * FROM table_name WHERE (((name) = ('test')) AND ((num) > (7)) AND last_name NOT ILIKE ('%''test''%'));
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE NULL;
SELECT * FROM table_name WHERE last_name NOT SIMILAR TO '%(b|d)%' ESCAPE 'a';
SELECT * FROM table_name WHERE ((last_name) > (first_name));
SELECT * FROM table_name WHERE ((last_name) <> (first_name));
SELECT * FROM table_name WHERE last_name = ANY (stuff);
SELECT * FROM table_name WHERE last_name = ALL (stuff);
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id = ANY (SELECT category_id FROM category WHERE (((name) = ('Action')) OR ((name) = ('Drama'))));
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE category_id IN (SELECT category_id FROM category WHERE (((name) = ('Action')) OR ((name) = ('Drama'))));
SELECT title,
category_id FROM film JOIN film_category USING (film_id) WHERE NOT (category_id IN (SELECT category_id FROM category WHERE (((name) = ('Action')) OR ((name) = ('Drama')))));
SELECT title FROM film WHERE length >= ANY (SELECT max(length) FROM film JOIN film_category USING (film_id) GROUP BY category_id);
SELECT * FROM transactions.transaction WHERE (transaction_date BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND ((owner) = (0)));
SELECT * FROM transactions.transaction WHERE (transaction_date NOT BETWEEN to_date('2020-01-01', 'YYYY-MM-DD') AND to_date('2020-12-31', 'YYYY-MM-DD') AND ((owner) = (0)));"
`;

exports[`kitchen sink functions basic 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS void AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;
$LQLCODEZ$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions basic 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS void AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;$EOFCODE$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id;$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_table 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS TABLE ( path text, name int ) AS $LQLCODEZ$
SELECT * FROM
mytable
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_table 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS TABLE ( path text, name int ) AS $EOFCODE$SELECT * FROM
mytable$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions returns_trigger 1`] = `
"CREATE OR REPLACE FUNCTION helpers.some_method ( ) RETURNS TRIGGER AS $LQLCODEZ$
BEGIN
IF tg_op = 'INSERT' THEN
NEW.some_prop = helpers.do_magic (NEW.data);
RETURN NEW;
END IF;
END;
$LQLCODEZ$ LANGUAGE plpgsql;"
`;

exports[`kitchen sink functions returns_trigger 2`] = `
"CREATE OR REPLACE FUNCTION helpers.some_method (  ) RETURNS trigger AS $EOFCODE$BEGIN
IF tg_op = 'INSERT' THEN
NEW.some_prop = helpers.do_magic (NEW.data);
RETURN NEW;
END IF;
END;$EOFCODE$ LANGUAGE plpgsql;"
`;

exports[`kitchen sink functions setof 1`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS SETOF obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id
$LQLCODEZ$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS SETOF obj.geo AS $LQLCODEZ$
UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id
$LQLCODEZ$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink functions setof 2`] = `
"CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id uuid, other_id uuid ) RETURNS SETOF obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id$EOFCODE$ LANGUAGE sql VOLATILE;
CREATE OR REPLACE FUNCTION someschema.myfunc ( some_id obj.geo_type, other_id obj.geo_type ) RETURNS SETOF obj.geo AS $EOFCODE$UPDATE
mytable
SET
ref_id = new_ref_id
WHERE
id = some_id$EOFCODE$ LANGUAGE sql VOLATILE;"
`;

exports[`kitchen sink grants 1`] = `
"GRANT USAGE ON SCHEMA users TO administrator;
GRANT EXECUTE ON FUNCTION auth.authenticate TO anonymous;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token TO administrator;
REVOKE USAGE ON SCHEMA users FROM administrator;
REVOKE EXECUTE ON FUNCTION auth.authenticate FROM anonymous;
REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token FROM administrator;
GRANT SELECT, INSERT ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2 ), UPDATE ( col2, \\"another-column\\" ), DELETE ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;"
`;

exports[`kitchen sink grants 2`] = `
"GRANT USAGE ON SCHEMA users TO administrator;
GRANT EXECUTE ON FUNCTION auth.authenticate TO anonymous;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token TO administrator;
REVOKE USAGE ON SCHEMA users FROM administrator;
REVOKE EXECUTE ON FUNCTION auth.authenticate FROM anonymous;
REVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE auth.token FROM administrator;
GRANT SELECT, INSERT ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT UPDATE ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2 ), UPDATE ( col2, \\"another-column\\" ), DELETE ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, col3 ) ON TABLE someschema.sometable2 TO somerole;
GRANT INSERT ( col2, \\"another-column\\" ) ON TABLE someschema.sometable2 TO somerole;"
`;

exports[`kitchen sink indexes 1`] = `
"CREATE INDEX CONCURRENTLY boom_merkle_tree_tag_created_reference_idx ON boom.merkle_tree (tag, created, reference);
CREATE UNIQUE INDEX databases_database_unique_name_idx ON databases.database (tenant_id, database_name_hash(name));
CREATE UNIQUE INDEX boom_worktree_idx ON boom.worktree (tag, reference, created, decode(md5(lower(path)), 'hex'));
CREATE UNIQUE INDEX uniq_service_when_not_null ON schema2.table3 (uid, svc) WHERE svc IS NOT NULL;"
`;

exports[`kitchen sink indexes 2`] = `
"CREATE INDEX CONCURRENTLY boom_merkle_tree_tag_created_reference_idx ON boom.merkle_tree ( tag, created, reference );
CREATE UNIQUE INDEX databases_database_unique_name_idx ON databases.database ( tenant_id, database_name_hash(name) );
CREATE UNIQUE INDEX boom_worktree_idx ON boom.worktree ( tag, reference, created, decode(md5(lower(path)), 'hex') );
CREATE UNIQUE INDEX uniq_service_when_not_null ON schema2.table3 ( uid, svc ) WHERE svc IS NOT NULL;"
`;

exports[`kitchen sink insert 1`] = `
"INSERT INTO shoelace_data VALUES (1, 2, 3, 'truth', 't'::boolean);
INSERT INTO shoelace_data (id, col1, col2, val1, bl2) VALUES (1, 2, 3, 'truth', 't'::boolean);
INSERT INTO shoelace_data DEFAULT VALUES;
INSERT INTO v8.modules (name, code) VALUES ('ajv', ' (FUNCTION () { var module = { exports: { } };
var exports = module.exports;
/* plv8 bundle begins */
(FUNCTION (f) {if(typeof exports == = \\"object\\" && typeof module != = \\"undefined\\") {module.exports=f()}else IF (typeof define == = \\"function\\" && define.amd) {define([], f) }else{var g;
IF (typeof
WINDOW != = \\"undefined\\") {g=window}else IF (typeof global != = \\"undefined\\") {g=global}else IF (typeof self != = \\"undefined\\") {g=self}else{g=this}g.ajv = f () }})(function(){var define,
module,
exports;
RETURN (FUNCTION e (t, n, r) {function s (o, u) {if(!n[o]){if(!t[o]){var a = typeof require == \\"function\\" && require;
IF (! u && a)
RETURN a (o,
! 0);
IF (i)
RETURN i (o,
! 0);
var f = new Error (\\"Cannot find module ''\\" + o + \\"''\\");
throw f.code = \\"MODULE_NOT_FOUND\\",
f }var l = n[o] = {exports : {}};
t[o][0].CALL (l.exports, FUNCTION (e) {var n = t[o][1][e];
RETURN s (n ? n:e) },
l,
l.exports,
e,
t,
n,
r) }return n[o].exports }var i = typeof require == \\"function\\" && require;
FOR (var o = 0;
o < r.length;
o + +) s (r[o]);
RETURN s })({1 :[FUNCTION (require, module, exports) { (FUNCTION (global) {
/*! https://mths.be/punycode v1.4.1 by @mathias */
;
(FUNCTION (root) {
/** Detect free variables */
var freeExports = typeof exports == ''object'' && exports && ! exports.nodeType && exports;
var freeModule = typeof module == ''object'' && module && ! module.nodeType && module;
var freeGlobal = typeof global == ''object'' && global;
IF (freeGlobal.global == = freeGlobal || freeGlobal.window == = freeGlobal || freeGlobal.self == = freeGlobal) { root = freeGlobal;
}
/**
* The \`punycode\` object.
* @name punycode
* @type Object
*/
var punycode,
/** Highest positive signed 32-bit float value */
maxInt = 2147483647,
/ / aka. 0x7FFFFFFF
OR 2 ^ 31 - 1
/** Bootstring parameters */
base = 36,
tMin = 1,
tMax = 26,
skew = 38,
damp = 700,
initialBias = 72,
initialN = 128,
/ / 0x80 DELIMITER = ''-'',
/ / ''\\\\x2D''
/** Regular expressions */
regexPunycode = / ^ xn --/, regexNonASCII = /[^ x20 - x7E] /,
/ / unprintable ASCII chars + non - ASCII chars regexSeparators = /[x2E u3002 uFF0E uFF61] / g,
/ / RFC 3490 separators
/** Error messages */
errors = { ''overflow'' :''Overflow: input needs wider integers to process'',
''not-basic'' :''Illegal input >= 0x80 (not a basic code point)'',
''invalid-input'' :''Invalid input'' },
/** Convenience shortcuts */
baseMinusTMin = base - tMin,
floor = Math.floor,
stringFromCharCode = String.fromCharCode,
/** Temporary variable */
KEY;
/*--------------------------------------------------------------------------*/
/**
* A generic error utility function.
* @private
* @param {String} type The error type.
* @returns {Error} Throws a \`RangeError\` with the applicable error message.
*/
FUNCTION error (TYPE) { throw new RangeError (errors[TYPE]);
}
/**
* A generic \`Array#map\` utility function.
* @private
* @param {Array} array The array to iterate over.
* @param {Function} callback The function that gets called for every array
* item.
* @returns {Array} A new array of values returned by the callback function.
*/
FUNCTION map (ARRAY, fn) { var length = array.length;
var result =[];
while (length --) { result[length] = fn (ARRAY[length]);
} RETURN result;
}
/**
* A simple \`Array#map\`-like wrapper to work with domain name strings or email
* addresses.
* @private
* @param {String} domain The domain name or email address.
* @param {Function} callback The function that gets called for every
* character.
* @returns {Array} A new string of characters returned by the callback
* function.
*/
FUNCTION mapDomain (string, fn) { var parts = string.split (''@'');
var result = '''';
IF (parts.length > 1) { / / IN email addresses,
ONLY the DOMAIN name should be punycoded. Leave / / the local part (i.e. everything up TO \`@\`) intact. result = parts[0] + ''@'';
string = parts[1];
} / / Avoid \`split(regex)\` FOR IE8 compatibility. See # 17. string = string.replace(regexSeparators, ''\\\\x2E'');
var labels = string.split (''.'');
var encoded = map (labels, fn).
JOIN (''.'');
RETURN result + encoded;
}
/**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see \`punycode.ucs2.encode\`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
FUNCTION ucs2decode (string) { var output =[], counter = 0, length = string.length, value, extra;
while (counter < length) { value = string.charCodeAt (counter + +);
IF (value >= 0xD800 && value <= 0xDBFF && counter < length) { / / high surrogate,
AND there IS a NEXT character extra = string.charCodeAt (counter + +);
IF ((extra & 0xFC00) == 0xDC00) { / / low surrogate output.push (((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
}
ELSE
{ / / unmatched surrogate;
ONLY append this code unit,
IN CASE the NEXT / / code unit IS the high surrogate OF a surrogate pair output.push (value); counter --; } }
ELSE
{ output.push (value); } } RETURN output; }
/**
* Creates a string based on an array of numeric code points.
* @see \`punycode.ucs2.decode\`
* @memberOf punycode.ucs2
* @name encode
* @param {Array} codePoints The array of numeric code points.
* @returns {String} The new Unicode string (UCS-2).
*/
FUNCTION ucs2encode (ARRAY) { RETURN map (ARRAY, FUNCTION (value) { var output = ''''; IF (value > 0xFFFF) { value - = 0x10000; output + = stringFromCharCode (value >> > 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output + = stringFromCharCode (value); RETURN output; }).join(''''); }
/**
* Converts a basic code point into a digit/integer.
* @see \`digitToBasic()\`
* @private
* @param {Number} codePoint The basic numeric code point value.
* @returns {Number} The numeric value of a basic code point (for use in
* representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
* the code point does not represent a value.
*/
FUNCTION basicToDigit (codePoint) { IF (codePoint - 48 < 10) { RETURN codePoint - 22; } IF (codePoint - 65 < 26) { RETURN codePoint - 65; } IF (codePoint - 97 < 26) { RETURN codePoint - 97; } RETURN base; }
/**
* Converts a digit/integer into a basic code point.
* @see \`basicToDigit()\`
* @private
* @param {Number} digit The numeric value of a basic code point.
* @returns {Number} The basic code point whose value (when used for
* representing integers) is \`digit\`, which needs to be in the range
* \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
* used; else, the lowercase form is used. The behavior is undefined
* if \`flag\` is non-zero and \`digit\` has no uppercase form.
*/
FUNCTION digitToBasic (digit, flag) { / / 0..25 map TO ASCII a..z OR A..Z / / 26..35 map TO ASCII 0..9 RETURN digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }
/**
* Bias adaptation function as per section 3.4 of RFC 3492.
* https://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
FUNCTION adapt (delta, numPoints, firstTime) { var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta + = floor(delta / numPoints); FOR (
/* no initialization */
; delta > baseMinusTMin * tMax >> 1; k + = base) { delta = floor(delta / baseMinusTMin); } RETURN floor(k + (baseMinusTMin + 1) * delta / (delta + skew)); }
/**
* Converts a Punycode string of ASCII-only symbols to a string of Unicode
* symbols.
* @memberOf punycode
* @param {String} input The Punycode string of ASCII-only symbols.
* @returns {String} The resulting string of Unicode symbols.
*/
FUNCTION decode(input) { / / Don ''t use UCS-2
var output = [],
inputLength = input.length,
out,
i = 0,
n = initialN,
bias = initialBias,
basic,
j,
index,
oldi,
w,
k,
digit,
t,
/** Cached calculation results */
baseMinusT;
// Handle the basic code points: let \`basic\` be the number of input code
// points before the last delimiter, or \`0\` if there is none, then copy
// the first basic code points to the output.
basic = input.lastIndexOf(delimiter);
if (basic < 0) {
basic = 0;
}
for (j = 0; j < basic; ++j) {
// if it'' s NOT a basic code point IF (input.charCodeAt (j) >= 0x80) { error (''not-basic''); } output.push (input.charCodeAt (j)); } / / Main decoding loop: START just AFTER the LAST DELIMITER IF ANY basic code / / points were copied; START at the beginning otherwise. FOR (INDEX = basic > 0 ? basic + 1 : 0; INDEX < inputLength;
/* no final expression */) { / / \`index\` IS the INDEX OF the NEXT character TO be consumed. / / Decode a generalized variable - length integer INTO \`delta\`, / / which gets added TO \`i\`.The overflow checking IS easier / / IF we increase \`i\` AS we
go, THEN
subtract OFF its starting / / value at the
END TO obtain \`delta\`. FOR (oldi = i, w = 1, k = base;
/* no condition */
;
k + = base) { IF (INDEX >= inputLength) { error (''invalid-input'');
} digit = basicToDigit (input.charCodeAt (INDEX + +));
IF (digit >= base || digit > floor((maxInt - i) / w)) { error (''overflow'');
} i + = digit * w;
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (digit < t) { break;
} baseMinusT = base - t;
IF (w > floor(maxInt / baseMinusT)) { error (''overflow'');
} w *= baseMinusT;
} out = output.length + 1;
bias = adapt (i - oldi, out, oldi == 0);
/ / \`i\` was supposed TO wrap around
FROM
\`out\` TO \`0\`,
/ / incrementing \`n\` EACH time,
so
we ''ll fix that now:
if (floor(i / out) > maxInt - n) {
error('' overflow '');
}
n += floor(i / out);
i %= out;
// Insert \`n\` at position \`i\` of the output
output.splice(i++, 0, n);
}
return ucs2encode(output);
}
/**
* Converts a string of Unicode symbols (e.g. a domain name label) to a
* Punycode string of ASCII-only symbols.
* @memberOf punycode
* @param {String} input The string of Unicode symbols.
* @returns {String} The resulting Punycode string of ASCII-only symbols.
*/
function encode(input) {
var n,
delta,
handledCPCount,
basicLength,
bias,
j,
m,
q,
k,
t,
currentValue,
output = [],
/** \`inputLength\` will hold the number of code points in \`input\`. */
inputLength,
/** Cached calculation results */
handledCPCountPlusOne,
baseMinusT,
qMinusT;
// Convert the input in UCS-2 to Unicode
input = ucs2decode(input);
// Cache the length
inputLength = input.length;
// Initialize the state
n = initialN;
delta = 0;
bias = initialBias;
// Handle the basic code points
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < 0x80) {
output.push(stringFromCharCode(currentValue));
}
}
handledCPCount = basicLength = output.length;
// \`handledCPCount\` is the number of code points that have been handled;
// \`basicLength\` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if (basicLength) {
output.push(delimiter);
}
// Main encoding loop:
while (handledCPCount < inputLength) {
// All non-basic code points < n have been handled already. Find the next
// larger one:
for (m = maxInt, j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue >= n && currentValue < m) {
m = currentValue;
}
}
// Increase \`delta\` enough to advance the decoder'' s < n,
i > state TO < m,
0 >,
/ / but guard against overflow handledCPCountPlusOne = handledCPCount + 1;
IF (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error (''overflow'');
} delta + = (m - n) * handledCPCountPlusOne;
n = m;
FOR (j = 0;
j < inputLength;
+ + j) { currentValue = input[j];
IF (currentValue < n && + + delta > maxInt) { error (''overflow'');
} IF (currentValue == n) { / / Represent delta AS a generalized variable - length integer FOR (q = delta,
k = base;
/* no condition */
;
k + = base) { t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (q < t) { break;
} qMinusT = q - t;
baseMinusT = base - t;
output.push (stringFromCharCode (digitToBasic (t + qMinusT % baseMinusT, 0)));
q = floor(qMinusT / baseMinusT);
} output.push (stringFromCharCode (digitToBasic (q, 0)));
bias = adapt (delta, handledCPCountPlusOne, handledCPCount == basicLength);
delta = 0;
+ + handledCPCount;
} } + + delta;
+ + n;
} RETURN output.join ('''');
}
/**
* Converts a Punycode string representing a domain name or an email address
* to Unicode. Only the Punycoded parts of the input will be converted, i.e.
* it doesn''t matter if you call it on a string that has already been
* converted to Unicode.
* @memberOf punycode
* @param {String} input The Punycoded domain name or email address to
* convert to Unicode.
* @returns {String} The Unicode representation of the given Punycode
* string.
*/
FUNCTION toUnicode (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexPunycode.test (string) ? decode(string.slice (4).toLowerCase ()) : string;
});
}
/**
* Converts a Unicode string representing a domain name or an email address to
* Punycode. Only the non-ASCII parts of the domain name will be converted,
* i.e. it doesn''t matter if you call it with a domain that''s already in
* ASCII.
* @memberOf punycode
* @param {String} input The domain name or email address to convert, as a
* Unicode string.
* @returns {String} The Punycode representation of the given domain name or
* email address.
*/
FUNCTION toASCII (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexNonASCII.test (string) ? ''xn--'' + encode(string) : string;
});
}
/*--------------------------------------------------------------------------*/
/** Define the public API */
punycode = {
/**
* A string representing the current Punycode.js version number.
* @memberOf punycode
* @type String
*/
''version'' :''1.4.1'',
/**
* An object of methods to convert from JavaScript''s internal character
* representation (UCS-2) to Unicode code points, and back.
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode
* @type Object
*/
''ucs2'' : { ''decode'' : ucs2decode,
''encode'' : ucs2encode },
''decode'' : decode,
''encode'' : encode,
''toASCII'' : toASCII,
''toUnicode'' : toUnicode };
/** Expose \`punycode\` */
/ / SOME AMD build optimizers,
LIKE r.js,
CHECK FOR specific condition patterns / / LIKE the following: IF (typeof define == ''function'' && typeof define.amd == ''object'' && define.amd) { define (''punycode'', FUNCTION () { RETURN punycode;
});
}
ELSE
IF (freeExports && freeModule) { IF (module.exports == freeExports) { / / IN Node.js,
io.js,
OR RingoJS v0.8.0 + freeModule.exports = punycode;
}
ELSE
{ / / IN Narwhal
OR RingoJS v0.7.0 - FOR (KEY IN punycode) { punycode.hasOwnProperty (KEY) && (freeExports[KEY] = punycode[KEY]);
} } }
ELSE
{ / / IN Rhino
OR a web browser root.punycode = punycode;
} }(this));
}).call(this,
typeof global != = \\"undefined\\" ? global : typeof self != = \\"undefined\\" ? self : typeof
WINDOW != = \\"undefined\\" ?
WINDOW : {}) },
{}],
2:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
/ / IF obj.hasOwnProperty has been overridden,
THEN
calling / / obj.hasOwnProperty (prop) will break. / / See: https: / / github.com / joyent / node / issues / 1707 FUNCTION hasOwnProperty (obj, prop) { RETURN Object.prototype.hasOwnProperty.call (obj, prop);
} module.exports = FUNCTION (qs, sep, eq, options) { sep = sep || ''&'';
eq = eq || ''='';
var obj = {};
IF (typeof qs != = ''string'' || qs.length == = 0) { RETURN obj;
} var regexp = / + / g;
qs = qs.split (sep);
var maxKeys = 1000;
IF (options && typeof options.maxKeys == = ''number'') { maxKeys = options.maxKeys;
} var len = qs.length;
/ / maxKeys <= 0 means that we should NOT
LIMIT keys count IF (maxKeys > 0 && len > maxKeys) { len = maxKeys;
} FOR (var i = 0;
i < len;
+ + i) { var x = qs[i].replace(regexp, ''%20''),
idx = x.indexOf (eq),
kstr,
vstr,
k,
v;
IF (idx >= 0) { kstr = x.substr(0, idx);
vstr = x.substr(idx + 1);
}
ELSE
{ kstr = x;
vstr = '''';
} k = decodeURIComponent (kstr);
v = decodeURIComponent (vstr);
IF (! hasOwnProperty (obj, k)) { obj[k] = v;
}
ELSE
IF (isArray (obj[k])) { obj[k].push (v);
}
ELSE
{ obj[k] =[obj[k], v];
} } RETURN obj;
};
var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]'';
};
},
{}],
3:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
var stringifyPrimitive = FUNCTION (v) { switch (typeof v) { CASE ''string'' : RETURN v; CASE ''boolean'' : RETURN v ? ''true'' :''false''; CASE ''number'' : RETURN isFinite(v) ? v : ''''; default: RETURN ''''; } }; module.exports = FUNCTION (obj, sep, eq, name) { sep = sep || ''&''; eq = eq || ''=''; IF (obj == = NULL) { obj = undefined; } IF (typeof obj == = ''object'') { RETURN map (objectKeys (obj), FUNCTION (k) { var ks = encodeURIComponent (stringifyPrimitive (k)) + eq; IF (isArray (obj[k])) { RETURN map (obj[k], FUNCTION (v) { RETURN ks + encodeURIComponent (stringifyPrimitive (v)); }).join(sep); }
ELSE
{ RETURN ks + encodeURIComponent (stringifyPrimitive (obj[k])); } }).join(sep); } IF (! name)
RETURN ''''; RETURN encodeURIComponent (stringifyPrimitive (name)) + eq + encodeURIComponent (stringifyPrimitive (obj)); }; var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]''; }; FUNCTION map (xs, f) { IF (xs.map)
RETURN xs.map (f); var res =[]; FOR (var i = 0; i < xs.length; i + +) { res.push (f (xs[i], i)); } RETURN res; } var objectKeys = Object.keys || FUNCTION (obj) { var res =[]; FOR (var KEY IN obj) { IF (Object.prototype.hasOwnProperty.call (obj, KEY)) res.push (KEY); } RETURN res; }; }, {}], 4:[FUNCTION (require, module, exports) { ''use strict''; exports.decode = exports.parse = require (''./decode''); exports.encode = exports.stringify = require (''./encode''); }, {\\". / decode \\":2,\\"./ encode \\":3}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\" Software \\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\" AS IS
\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
''use strict'';
var punycode = require(''punycode'');
var util = require(''./util'');
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
this.protocol = null;
this.slashes = null;
this.auth = null;
this.host = null;
this.port = null;
this.hostname = null;
this.hash = null;
this.search = null;
this.query = null;
this.pathname = null;
this.path = null;
this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
portPattern = /:[0-9]*$/,
// Special case for a simple path URL
simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,
// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = [''<'', ''>'', ''\\" '', '' \`'', '' '', ''\\\\r'', ''\\\\n'', ''\\\\t''],
// RFC 2396: characters not allowed for various reasons.
unwise = [''{'', ''}'', ''|'', ''\\\\\\\\'', ''^'', ''\` ''].concat(delims),
// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['' \\\\'' ''].concat(unwise),
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['' % '', '' / '', '' ? '', ''; '', '' # ''].concat(autoEscape),
hostEndingChars = ['' / '', '' ? '', '' # ''],
hostnameMaxLen = 255,
hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
// protocols that can allow \\"unsafe\\" and \\"unwise\\" chars.
unsafeProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that never have a hostname.
hostlessProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that always contain a // bit.
slashedProtocol = {
'' http '': true,
'' https '': true,
'' ftp '': true,
'' gopher '': true,
'' file '': true,
'' http: '': true,
'' https: '': true,
'' ftp: '': true,
'' gopher: '': true,
'' file: '': true
},
querystring = require('' querystring '');
function urlParse(url, parseQueryString, slashesDenoteHost) {
if (url && util.isObject(url) && url instanceof Url) return url;
var u = new Url;
u.parse(url, parseQueryString, slashesDenoteHost);
return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
if (!util.isString(url)) {
throw new TypeError(\\"Parameter '' url '' must be a string, not \\" + typeof url);
}
// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex = url.indexOf('' ? ''),
splitter =
(queryIndex !== -1 && queryIndex < url.indexOf('' # '')) ? '' ? '' : '' # '',
uSplit = url.split(splitter),
slashRegex = /\\\\\\\\/g;
uSplit[0] = uSplit[0].replace(slashRegex, '' / '');
url = uSplit.join(splitter);
var rest = url;
// trim before proceeding.
// This is to support parse stuff like \\"  http://foo.com  \\\\n\\"
rest = rest.trim();
if (!slashesDenoteHost && url.split('' # '').length === 1) {
// Try fast path regexp
var simplePath = simplePathPattern.exec(rest);
if (simplePath) {
this.path = rest;
this.href = rest;
this.pathname = simplePath[1];
if (simplePath[2]) {
this.search = simplePath[2];
if (parseQueryString) {
this.query = querystring.parse(this.search.substr(1));
} else {
this.query = this.search.substr(1);
}
} else if (parseQueryString) {
this.search = '''';
this.query = {};
}
return this;
}
}
var proto = protocolPattern.exec(rest);
if (proto) {
proto = proto[0];
var lowerProto = proto.toLowerCase();
this.protocol = lowerProto;
rest = rest.substr(proto.length);
}
// figure out if it'' s got a host / / user@server
IS * always * interpreted AS a hostname, AND url / / resolution will treat / / foo / bar AS host = foo, path = bar because that ''s
// how the browser resolves relative URLs.
if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {
var slashes = rest.substr(0, 2) === '' / / '';
if (slashes && !(proto && hostlessProtocol[proto])) {
rest = rest.substr(2);
this.slashes = true;
}
}
if (!hostlessProtocol[proto] &&
(slashes || (proto && !slashedProtocol[proto]))) {
// there'' s a hostname. / / the FIRST instance OF /, ?,;, OR # ends the host. / / / / IF there IS an @ IN the hostname, THEN
non - host chars * are * allowed / / TO the
LEFT OF the LAST @ sign, unless SOME host - ending character / / comes * BEFORE * the @ - sign. / / URLs are obnoxious. / / / / ex: / / http: / / a@b@c / => user:a@b host:c / / http: / / a@b ? @c => user:a host:c path: / ? @c / / v0.12 TODO (isaacs) : This IS NOT quite how Chrome does things. / / Review our test CASE against browsers more comprehensively. / / find the FIRST instance OF ANY hostEndingChars var hostEnd = - 1; FOR (var i = 0; i < hostEndingChars.length; i + +) { var hec = rest.indexOf (hostEndingChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / at this point, either we have an explicit point
WHERE
the / / auth portion cannot go past, OR the LAST @ char IS the decider. var auth, atSign; IF (hostEnd == = - 1) { / / atSign can be anywhere. atSign = rest.lastIndexOf (''@''); }
ELSE
{ / / atSign must be IN auth portion. / / http: / / a@b / c@d => host:b auth:a path: / c@d atSign = rest.lastIndexOf (''@'', hostEnd); } / / Now we have a portion which IS definitely the auth. / / Pull that off. IF (atSign != = - 1) { auth = rest.slice (0, atSign); rest = rest.slice (atSign + 1); this.auth = decodeURIComponent (auth); } / / the host IS the remaining TO the
LEFT OF the FIRST non - host char hostEnd = - 1; FOR (var i = 0; i < nonHostChars.length; i + +) { var hec = rest.indexOf (nonHostChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / IF we still have NOT hit it, THEN
the entire thing IS a host. IF (hostEnd == = - 1) hostEnd = rest.length; this.host = rest.slice (0, hostEnd); rest = rest.slice (hostEnd); / / pull out port. this.parseHost (); / / we ''ve indicated that there is a hostname,
// so even if it'' s empty, it has TO be present. this.hostname = this.hostname || ''''; / / IF hostname begins WITH[ AND ends WITH] / / assume that it ''s an IPv6 address.
var ipv6Hostname = this.hostname[0] === ''['' &&
this.hostname[this.hostname.length - 1] === ''] '';
// validate a little.
if (!ipv6Hostname) {
var hostparts = this.hostname.split(/\\\\./);
for (var i = 0, l = hostparts.length; i < l; i++) {
var part = hostparts[i];
if (!part) continue;
if (!part.match(hostnamePartPattern)) {
var newpart = '''';
for (var j = 0, k = part.length; j < k; j++) {
if (part.charCodeAt(j) > 127) {
// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart += '' x '';
} else {
newpart += part[j];
}
}
// we test again with ASCII char only
if (!newpart.match(hostnamePartPattern)) {
var validParts = hostparts.slice(0, i);
var notHost = hostparts.slice(i + 1);
var bit = part.match(hostnamePartStart);
if (bit) {
validParts.push(bit[1]);
notHost.unshift(bit[2]);
}
if (notHost.length) {
rest = '' / '' + notHost.join(''.'') + rest;
}
this.hostname = validParts.join(''.'');
break;
}
}
}
}
if (this.hostname.length > hostnameMaxLen) {
this.hostname = '''';
} else {
// hostnames are always lower case.
this.hostname = this.hostname.toLowerCase();
}
if (!ipv6Hostname) {
// IDNA Support: Returns a punycoded representation of \\"domain\\".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn'' t matter IF / / you CALL it WITH a DOMAIN that already IS ASCII - only. this.hostname = punycode.toASCII (
this.hostname); } var p = this.port ? '':'' + this.port : ''''; var h = this.hostname || ''''; this.host = h + p; this.href + = this.host; / / strip[ AND] FROM the hostname / / the host field still retains them, though IF (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); IF (rest[0] != = ''/'') { rest = ''/'' + rest; } } } / / now rest IS SET TO the post - host stuff. / / chop OFF ANY delim chars. IF (! unsafeProtocol[lowerProto]) { / / FIRST, make 100 % sure that ANY \\"autoEscape\\" chars get / / escaped, even IF encodeURIComponent doesn ''t think they
// need to be.
for (var i = 0, l = autoEscape.length; i < l; i++) {
var ae = autoEscape[i];
if (rest.indexOf(ae) === -1)
continue;
var esc = encodeURIComponent(ae);
if (esc === ae) {
esc = escape(ae);
}
rest = rest.split(ae).join(esc);
}
}
// chop off from the tail first.
var hash = rest.indexOf('' # '');
if (hash !== -1) {
// got a fragment string.
this.hash = rest.substr(hash);
rest = rest.slice(0, hash);
}
var qm = rest.indexOf('' ? '');
if (qm !== -1) {
this.search = rest.substr(qm);
this.query = rest.substr(qm + 1);
if (parseQueryString) {
this.query = querystring.parse(this.query);
}
rest = rest.slice(0, qm);
} else if (parseQueryString) {
// no query string, but parseQueryString still requested
this.search = '''';
this.query = {};
}
if (rest) this.pathname = rest;
if (slashedProtocol[lowerProto] &&
this.hostname && !this.pathname) {
this.pathname = '' / '';
}
//to support http.request
if (this.pathname || this.search) {
var p = this.pathname || '''';
var s = this.search || '''';
this.path = p + s;
}
// finally, reconstruct the href based on what has been validated.
this.href = this.format();
return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
// ensure it'' s an object, AND NOT a string url. / / IF it ''s an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if (util.isString(obj)) obj = urlParse(obj);
if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
return obj.format();
}
Url.prototype.format = function() {
var auth = this.auth || '''';
if (auth) {
auth = encodeURIComponent(auth);
auth = auth.replace(/%3A/i, '' : '');
auth += '' @ '';
}
var protocol = this.protocol || '''',
pathname = this.pathname || '''',
hash = this.hash || '''',
host = false,
query = '''';
if (this.host) {
host = auth + this.host;
} else if (this.hostname) {
host = auth + (this.hostname.indexOf('' : '') === -1 ?
this.hostname :
''['' + this.hostname + ''] '');
if (this.port) {
host += '' : '' + this.port;
}
}
if (this.query &&
util.isObject(this.query) &&
Object.keys(this.query).length) {
query = querystring.stringify(this.query);
}
var search = this.search || (query && ('' ? '' + query)) || '''';
if (protocol && protocol.substr(-1) !== '' :'') protocol += '' : '';
// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if (this.slashes ||
(!protocol || slashedProtocol[protocol]) && host !== false) {
host = '' / / '' + (host || '''');
if (pathname && pathname.charAt(0) !== '' / '') pathname = '' / '' + pathname;
} else if (!host) {
host = '''';
}
if (hash && hash.charAt(0) !== '' # '') hash = '' # '' + hash;
if (search && search.charAt(0) !== '' ? '') search = '' ? '' + search;
pathname = pathname.replace(/[?#]/g, function(match) {
return encodeURIComponent(match);
});
search = search.replace('' # '', '' % 23 '');
return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
if (!source) return relative;
return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
if (util.isString(relative)) {
var rel = new Url();
rel.parse(relative, false, true);
relative = rel;
}
var result = new Url();
var tkeys = Object.keys(this);
for (var tk = 0; tk < tkeys.length; tk++) {
var tkey = tkeys[tk];
result[tkey] = this[tkey];
}
// hash is always overridden, no matter what.
// even href=\\"\\" will remove it.
result.hash = relative.hash;
// if the relative url is empty, then there'' s NOTHING
LEFT TO DO here. IF (relative.href == = '''') { result.href = result.format(); RETURN result; } / / hrefs LIKE / / foo / bar always cut TO the protocol. IF (relative.slashes && ! relative.protocol) { / / take everything
EXCEPT
the protocol FROM relative var rkeys = Object.keys (relative); FOR (var rk = 0; rk < rkeys.length; rk + +) { var rkey = rkeys[rk]; IF (rkey != = ''protocol'') result[rkey] = relative[rkey]; } / / urlParse appends TRAILING / TO urls LIKE http: / / www.example.com IF (slashedProtocol[result.protocol] && result.hostname && ! result.pathname) { result.path = result.pathname = ''/''; } result.href = result.format(); RETURN result; } IF (relative.protocol && relative.protocol != = result.protocol) { / / IF it ''s a known url protocol, then changing
// the protocol does weird things
// first, if it'' s NOT file:, THEN
we MUST have a host, / /
AND IF there was a path / / TO
BEGIN
WITH,
THEN
we MUST have a path. / / IF it IS file:,
THEN
the host IS dropped,
/ / because that ''s known to be hostless.
// anything else is assumed to be absolute.
if (!slashedProtocol[relative.protocol]) {
var keys = Object.keys(relative);
for (var v = 0; v < keys.length; v++) {
var k = keys[v];
result[k] = relative[k];
}
result.href = result.format();
return result;
}
result.protocol = relative.protocol;
if (!relative.host && !hostlessProtocol[relative.protocol]) {
var relPath = (relative.pathname || '''').split('' / '');
while (relPath.length && !(relative.host = relPath.shift()));
if (!relative.host) relative.host = '''';
if (!relative.hostname) relative.hostname = '''';
if (relPath[0] !== '''') relPath.unshift('''');
if (relPath.length < 2) relPath.unshift('''');
result.pathname = relPath.join('' / '');
} else {
result.pathname = relative.pathname;
}
result.search = relative.search;
result.query = relative.query;
result.host = relative.host || '''';
result.auth = relative.auth;
result.hostname = relative.hostname || relative.host;
result.port = relative.port;
// to support http.request
if (result.pathname || result.search) {
var p = result.pathname || '''';
var s = result.search || '''';
result.path = p + s;
}
result.slashes = result.slashes || relative.slashes;
result.href = result.format();
return result;
}
var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '' / ''),
isRelAbs = (
relative.host ||
relative.pathname && relative.pathname.charAt(0) === '' / ''
),
mustEndAbs = (isRelAbs || isSourceAbs ||
(result.host && relative.pathname)),
removeAllDots = mustEndAbs,
srcPath = result.pathname && result.pathname.split('' / '') || [],
relPath = relative.pathname && relative.pathname.split('' / '') || [],
psychotic = result.protocol && !slashedProtocol[result.protocol];
// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if (psychotic) {
result.hostname = '''';
result.port = null;
if (result.host) {
if (srcPath[0] === '''') srcPath[0] = result.host;
else srcPath.unshift(result.host);
}
result.host = '''';
if (relative.protocol) {
relative.hostname = null;
relative.port = null;
if (relative.host) {
if (relPath[0] === '''') relPath[0] = relative.host;
else relPath.unshift(relative.host);
}
relative.host = null;
}
mustEndAbs = mustEndAbs && (relPath[0] === '''' || srcPath[0] === '''');
}
if (isRelAbs) {
// it'' s absolute. result.host = (
relative.host || relative.host == = '''') ? relative.host : result.host; result.hostname = (relative.hostname || relative.hostname == = '''') ? relative.hostname : result.hostname; result.search = relative.search; result.query = relative.query; srcPath = relPath; / / fall through TO the dot - handling below. }
ELSE
IF (relPath.length) { / / it ''s relative
// throw away the existing file, and take the new path instead.
if (!srcPath) srcPath = [];
srcPath.pop();
srcPath = srcPath.concat(relPath);
result.search = relative.search;
result.query = relative.query;
} else if (!util.isNullOrUndefined(relative.search)) {
// just pull out the search.
// like href='' ? foo ''.
// Put this after the other two cases because it simplifies the booleans
if (psychotic) {
result.hostname = result.host = srcPath.shift();
//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('' mailto:local1@domain1 '', '' local2@domain2 '')
var authInHost = result.host && result.host.indexOf('' @ '') > 0 ?
result.host.split('' @ '') : false;
if (authInHost) {
result.auth = authInHost.shift();
result.host = result.hostname = authInHost.shift();
}
}
result.search = relative.search;
result.query = relative.query;
//to support http.request
if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
result.path = (result.pathname ? result.pathname : '''') +
(result.search ? result.search : '''');
}
result.href = result.format();
return result;
}
if (!srcPath.length) {
// no path at all.  easy.
// we'' ve already handled the other stuff above. result.pathname = NULL; / / TO support http.request IF (result.search) { result.path = ''/'' + result.search; }
ELSE
{ result.path = NULL; } result.href = result.format(); RETURN result; } / / IF a url ENDs IN. OR.., THEN
it must get a TRAILING slash. / / however, IF it ends IN anything
ELSE
non - slashy, / / THEN
it must NOT get a TRAILING slash. var LAST = srcPath.slice (- 1)[0]; var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (LAST == = ''.'' || LAST == = ''..'') || LAST == = ''''); / / strip single dots, resolve double dots TO parent dir / / IF the path tries TO go above the root, \`up\` ends up > 0 var up = 0; FOR (var i = srcPath.length; i >= 0; i --) { LAST = srcPath[i]; IF (LAST == = ''.'') { srcPath.splice (i, 1); }
ELSE
IF (LAST == = ''..'') { srcPath.splice (i, 1); up + +; }
ELSE
IF (up) { srcPath.splice (i, 1); up --; } } / / IF the path IS allowed TO go above the root, restore LEADING..s IF (! mustEndAbs && ! removeAllDots) { FOR (;up --; up) { srcPath.unshift (''..''); } } IF (mustEndAbs && srcPath[0] != = '''' && (! srcPath[0] || srcPath[0].charAt (0) != = ''/'')) { srcPath.unshift (''''); } IF (hasTrailingSlash && (srcPath.join (''/'').substr(- 1) != = ''/'')) { srcPath.push (''''); } var isAbsolute = srcPath[0] == = '''' || (srcPath[0] && srcPath[0].charAt (0) == = ''/''); / / put the host back IF (psychotic) { result.hostname = result.host = isAbsolute ? '''' : srcPath.length ? srcPath.shift () : ''''; / / occationaly the auth can get stuck ONLY IN host / / this especially happens IN cases LIKE / / url.resolveObject (''mailto:local1@domain1'', ''local2@domain2'') var authInHost = result.host && result.host.indexOf (''@'') > 0 ? result.host.split (''@'') : FALSE; IF (authInHost) { result.auth = authInHost.shift (); result.host = result.hostname = authInHost.shift (); } } mustEndAbs = mustEndAbs || (result.host && srcPath.length); IF (mustEndAbs && ! isAbsolute) { srcPath.unshift (''''); } IF (! srcPath.length) { result.pathname = NULL; result.path = NULL; }
ELSE
{ result.pathname = srcPath.join (''/''); } / / TO support request.http IF (! util.isNull (result.pathname) || ! util.isNull (result.search)) { result.path = (result.pathname ? result.pathname : '''') + (result.search ? result.search : ''''); } result.auth = relative.auth || result.auth; result.slashes = result.slashes || relative.slashes; result.href = result.format(); RETURN result; }; Url.prototype.parseHost = FUNCTION () { var host = this.host; var port = portPattern.exec (host); IF (port) { port = port[0]; IF (port != = '':'') { this.port = port.substr(1); } host = host.substr(0, host.length - port.length); } IF (host) this.hostname = host; }; }, {\\". / util \\":6,\\" punycode \\":1,\\" querystring \\":4}],6:[function(require,module,exports){
''use strict'';
module.exports = {
isString: function(arg) {
return typeof(arg) === ''string'';
},
isObject: function(arg) {
return typeof(arg) === ''object'' && arg !== null;
},
isNull: function(arg) {
return arg === null;
},
isNullOrUndefined: function(arg) {
return arg == null;
}
};
},{}],7:[function(require,module,exports){
module.exports = require(''ajv'');
},{\\" ajv \\":9}],8:[function(require,module,exports){
''use strict'';
var KEYWORDS = [
''multipleOf'',
''maximum'',
''exclusiveMaximum'',
''minimum'',
''exclusiveMinimum'',
''maxLength'',
''minLength'',
''pattern'',
''additionalItems'',
''maxItems'',
''minItems'',
''uniqueItems'',
''maxProperties'',
''minProperties'',
''required'',
''additionalProperties'',
''enum'',
''format'',
''const''
];
module.exports = function (metaSchema, keywordsJsonPointers) {
for (var i=0; i<keywordsJsonPointers.length; i++) {
metaSchema = JSON.parse(JSON.stringify(metaSchema));
var segments = keywordsJsonPointers[i].split(''/'');
var keywords = metaSchema;
var j;
for (j=1; j<segments.length; j++)
keywords = keywords[segments[j]];
for (j=0; j<KEYWORDS.length; j++) {
var key = KEYWORDS[j];
var schema = keywords[key];
if (schema) {
keywords[key] = {
anyOf: [
schema,
{ $ref: ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
}
}
return metaSchema;
};
},{}],9:[function(require,module,exports){
''use strict'';
var compileSchema = require(''./compile'')
, resolve = require(''./compile/resolve'')
, Cache = require(''./cache'')
, SchemaObject = require(''./compile/schema_obj'')
, stableStringify = require(''json-stable-stringify'')
, formats = require(''./compile/formats'')
, rules = require(''./compile/rules'')
, $dataMetaSchema = require(''./$data'')
, patternGroups = require(''./patternGroups'')
, util = require(''./compile/util'')
, co = require(''co'');
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require(''./compile/async'');
var customKeyword = require(''./keyword'');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
var errorClasses = require(''./compile/error_classes'');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
var META_IGNORE_OPTIONS = [ ''removeAdditional'', ''useDefaults'', ''coerceTypes'' ];
var META_SUPPORT_DATA = [''/properties''];
/**
* Creates validator instance.
* Usage: \`Ajv(opts)\`
* @param {Object} opts optional options
* @return {Object} ajv instance
*/
function Ajv(opts) {
if (!(this instanceof Ajv)) return new Ajv(opts);
opts = this._opts = util.copy(opts) || {};
this._schemas = {};
this._refs = {};
this._fragments = {};
this._formats = formats(opts.format);
var schemaUriFormat = this._schemaUriFormat = this._formats[''uri-reference''];
this._schemaUriFormatFunc = function (str) { return schemaUriFormat.test(str); };
this._cache = opts.cache || new Cache;
this._loadingSchemas = {};
this._compilations = [];
this.RULES = rules();
this._getId = chooseGetId(opts);
opts.loopRequired = opts.loopRequired || Infinity;
if (opts.errorDataPath == ''property'') opts._errorDataPathProperty = true;
if (opts.serialize === undefined) opts.serialize = stableStringify;
this._metaOpts = getMetaSchemaOptions(this);
if (opts.formats) addInitialFormats(this);
addDraft6MetaSchema(this);
if (typeof opts.meta == ''object'') this.addMetaSchema(opts.meta);
addInitialSchemas(this);
if (opts.patternGroups) patternGroups(this);
}
/**
* Validate data using schema
* Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
* @this   Ajv
* @param  {String|Object} schemaKeyRef key, ref or schema object
* @param  {Any} data to be validated
* @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
*/
function validate(schemaKeyRef, data) {
var v;
if (typeof schemaKeyRef == ''string'') {
v = this.getSchema(schemaKeyRef);
if (!v) throw new Error(''no schema with key or ref \\" '' + schemaKeyRef + '' \\"'');
} else {
var schemaObj = this._addSchema(schemaKeyRef);
v = schemaObj.validate || this._compile(schemaObj);
}
var valid = v(data);
if (v.$async === true)
return this._opts.async == ''*'' ? co(valid) : valid;
this.errors = v.errors;
return valid;
}
/**
* Create validating function for passed schema.
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
* @return {Function} validating function
*/
function compile(schema, _meta) {
var schemaObj = this._addSchema(schema, undefined, _meta);
return schemaObj.validate || this._compile(schemaObj);
}
/**
* Adds schema to the instance.
* @this   Ajv
* @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
* @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
* @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
* @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
*/
function addSchema(schema, key, _skipValidation, _meta) {
if (Array.isArray(schema)){
for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
return;
}
var id = this._getId(schema);
if (id !== undefined && typeof id != ''string'')
throw new Error(''schema id must be string'');
key = resolve.normalizeId(key || id);
checkUnique(this, key);
this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
}
/**
* Add schema that will be used to validate other schemas
* options in META_IGNORE_OPTIONS are alway set to false
* @this   Ajv
* @param {Object} schema schema object
* @param {String} key optional schema key
* @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
*/
function addMetaSchema(schema, key, skipValidation) {
this.addSchema(schema, key, skipValidation, true);
}
/**
* Validate schema
* @this   Ajv
* @param {Object} schema schema to validate
* @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
* @return {Boolean} true if schema is valid
*/
function validateSchema(schema, throwOrLogError) {
var $schema = schema.$schema;
if ($schema !== undefined && typeof $schema != ''string'')
throw new Error(''$schema must be a string'');
$schema = $schema || this._opts.defaultMeta || defaultMeta(this);
if (!$schema) {
console.warn(''meta-schema not available'');
this.errors = null;
return true;
}
var currentUriFormat = this._formats.uri;
this._formats.uri = typeof currentUriFormat == ''function''
? this._schemaUriFormatFunc
: this._schemaUriFormat;
var valid;
try { valid = this.validate($schema, schema); }
finally { this._formats.uri = currentUriFormat; }
if (!valid && throwOrLogError) {
var message = ''schema is invalid: '' + this.errorsText();
if (this._opts.validateSchema == ''log'') console.error(message);
else throw new Error(message);
}
return valid;
}
function defaultMeta(self) {
var meta = self._opts.meta;
self._opts.defaultMeta = typeof meta == ''object''
? self._getId(meta) || meta
: self.getSchema(META_SCHEMA_ID)
? META_SCHEMA_ID
: undefined;
return self._opts.defaultMeta;
}
/**
* Get compiled schema from the instance by \`key\` or \`ref\`.
* @this   Ajv
* @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
* @return {Function} schema validating function (with property \`schema\`).
*/
function getSchema(keyRef) {
var schemaObj = _getSchemaObj(this, keyRef);
switch (typeof schemaObj) {
case ''object'': return schemaObj.validate || this._compile(schemaObj);
case ''string'': return this.getSchema(schemaObj);
case ''undefined'': return _getSchemaFragment(this, keyRef);
}
}
function _getSchemaFragment(self, ref) {
var res = resolve.schema.call(self, { schema: {} }, ref);
if (res) {
var schema = res.schema
, root = res.root
, baseId = res.baseId;
var v = compileSchema.call(self, schema, root, undefined, baseId);
self._fragments[ref] = new SchemaObject({
ref: ref,
fragment: true,
schema: schema,
root: root,
baseId: baseId,
validate: v
});
return v;
}
}
function _getSchemaObj(self, keyRef) {
keyRef = resolve.normalizeId(keyRef);
return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
* Remove cached schema(s).
* If no parameter is passed all schemas but meta-schemas are removed.
* If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
* Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
* @this   Ajv
* @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
*/
function removeSchema(schemaKeyRef) {
if (schemaKeyRef instanceof RegExp) {
_removeAllSchemas(this, this._schemas, schemaKeyRef);
_removeAllSchemas(this, this._refs, schemaKeyRef);
return;
}
switch (typeof schemaKeyRef) {
case ''undefined'':
_removeAllSchemas(this, this._schemas);
_removeAllSchemas(this, this._refs);
this._cache.clear();
return;
case ''string'':
var schemaObj = _getSchemaObj(this, schemaKeyRef);
if (schemaObj) this._cache.del(schemaObj.cacheKey);
delete this._schemas[schemaKeyRef];
delete this._refs[schemaKeyRef];
return;
case ''object'':
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
this._cache.del(cacheKey);
var id = this._getId(schemaKeyRef);
if (id) {
id = resolve.normalizeId(id);
delete this._schemas[id];
delete this._refs[id];
}
}
}
function _removeAllSchemas(self, schemas, regex) {
for (var keyRef in schemas) {
var schemaObj = schemas[keyRef];
if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
self._cache.del(schemaObj.cacheKey);
delete schemas[keyRef];
}
}
}
/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
if (typeof schema != ''object'' && typeof schema != ''boolean'')
throw new Error(''schema should be object or boolean'');
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schema) : schema;
var cached = this._cache.get(cacheKey);
if (cached) return cached;
shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
var id = resolve.normalizeId(this._getId(schema));
if (id && shouldAddSchema) checkUnique(this, id);
var willValidate = this._opts.validateSchema !== false && !skipValidation;
var recursiveMeta;
if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
this.validateSchema(schema, true);
var localRefs = resolve.ids.call(this, schema);
var schemaObj = new SchemaObject({
id: id,
schema: schema,
localRefs: localRefs,
cacheKey: cacheKey,
meta: meta
});
if (id[0] != ''#'' && shouldAddSchema) this._refs[id] = schemaObj;
this._cache.put(cacheKey, schemaObj);
if (willValidate && recursiveMeta) this.validateSchema(schema, true);
return schemaObj;
}
/* @this   Ajv */
function _compile(schemaObj, root) {
if (schemaObj.compiling) {
schemaObj.validate = callValidate;
callValidate.schema = schemaObj.schema;
callValidate.errors = null;
callValidate.root = root ? root : callValidate;
if (schemaObj.schema.$async === true)
callValidate.$async = true;
return callValidate;
}
schemaObj.compiling = true;
var currentOpts;
if (schemaObj.meta) {
currentOpts = this._opts;
this._opts = this._metaOpts;
}
var v;
try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
finally {
schemaObj.compiling = false;
if (schemaObj.meta) this._opts = currentOpts;
}
schemaObj.validate = v;
schemaObj.refs = v.refs;
schemaObj.refVal = v.refVal;
schemaObj.root = v.root;
return v;
function callValidate() {
var _validate = schemaObj.validate;
var result = _validate.apply(null, arguments);
callValidate.errors = _validate.errors;
return result;
}
}
function chooseGetId(opts) {
switch (opts.schemaId) {
case ''$id'': return _get$Id;
case ''id'': return _getId;
default: return _get$IdOrId;
}
}
function _getId(schema) {
if (schema.$id) console.warn(''schema $id ignored'', schema.$id);
return schema.id;
}
function _get$Id(schema) {
if (schema.id) console.warn(''schema id ignored'', schema.id);
return schema.$id;
}
function _get$IdOrId(schema) {
if (schema.$id && schema.id && schema.$id != schema.id)
throw new Error(''schema $id is different from id'');
return schema.$id || schema.id;
}
/**
* Convert array of error message objects to string
* @this   Ajv
* @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
* @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
* @return {String} human readable string with all errors descriptions
*/
function errorsText(errors, options) {
errors = errors || this.errors;
if (!errors) return ''No errors'';
options = options || {};
var separator = options.separator === undefined ? '', '' : options.separator;
var dataVar = options.dataVar === undefined ? ''data'' : options.dataVar;
var text = '''';
for (var i=0; i<errors.length; i++) {
var e = errors[i];
if (e) text += dataVar + e.dataPath + '' '' + e.message + separator;
}
return text.slice(0, -separator.length);
}
/**
* Add custom format
* @this   Ajv
* @param {String} name format name
* @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
*/
function addFormat(name, format) {
if (typeof format == ''string'') format = new RegExp(format);
this._formats[name] = format;
}
function addDraft6MetaSchema(self) {
var $dataSchema;
if (self._opts.$data) {
$dataSchema = require(''./refs/$data.json'');
self.addMetaSchema($dataSchema, $dataSchema.$id, true);
}
if (self._opts.meta === false) return;
var metaSchema = require(''./refs/json-schema-draft-06.json'');
if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
self._refs[''http://json-schema.org/schema''] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
var optsSchemas = self._opts.schemas;
if (!optsSchemas) return;
if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
for (var name in self._opts.formats) {
var format = self._opts.formats[name];
self.addFormat(name, format);
}
}
function checkUnique(self, id) {
if (self._schemas[id] || self._refs[id])
throw new Error(''schema with key or id \\" '' + id + '' \\" already exists'');
}
function getMetaSchemaOptions(self) {
var metaOpts = util.copy(self._opts);
for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
delete metaOpts[META_IGNORE_OPTIONS[i]];
return metaOpts;
}
},{\\"./ $ data \\":8,\\"./
CACHE \\":10,\\"./ compile \\":15,\\"./ compile / async \\":12,\\"./ compile / error_classes \\":13,\\"./ compile / formats \\":14,\\"./ compile / resolve \\":16,\\"./ compile / rules \\":17,\\"./ compile / schema_obj \\":18,\\"./ compile / util \\":20,\\"./ keyword \\":44,\\"./ patternGroups \\":45,\\"./ refs / $ data.json \\":46,\\"./ refs / json - SCHEMA - draft - 06.json \\":47,\\" co \\":48,\\" json - STABLE - stringify \\":51}],10:[function(require,module,exports){
''use strict'';
var Cache = module.exports = function Cache() {
this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
this._cache = {};
};
},{}],11:[function(require,module,exports){
''use strict'';
//all requires must be explicit because browserify won''t work with dynamic requires
module.exports = {
''$ref'': require(''../dotjs/ref''),
allOf: require(''../dotjs/allOf''),
anyOf: require(''../dotjs/anyOf''),
const: require(''../dotjs/const''),
contains: require(''../dotjs/contains''),
dependencies: require(''../dotjs/dependencies''),
''enum'': require(''../dotjs/enum''),
format: require(''../dotjs/format''),
items: require(''../dotjs/items''),
maximum: require(''../dotjs/_limit''),
minimum: require(''../dotjs/_limit''),
maxItems: require(''../dotjs/_limitItems''),
minItems: require(''../dotjs/_limitItems''),
maxLength: require(''../dotjs/_limitLength''),
minLength: require(''../dotjs/_limitLength''),
maxProperties: require(''../dotjs/_limitProperties''),
minProperties: require(''../dotjs/_limitProperties''),
multipleOf: require(''../dotjs/multipleOf''),
not: require(''../dotjs/not''),
oneOf: require(''../dotjs/oneOf''),
pattern: require(''../dotjs/pattern''),
properties: require(''../dotjs/properties''),
propertyNames: require(''../dotjs/propertyNames''),
required: require(''../dotjs/required''),
uniqueItems: require(''../dotjs/uniqueItems''),
validate: require(''../dotjs/validate'')
};
},{\\"../ dotjs / _limit \\":21,\\"../ dotjs / _limitItems \\":22,\\"../ dotjs / _limitLength \\":23,\\"../ dotjs / _limitProperties \\":24,\\"../ dotjs / allOf \\":25,\\"../ dotjs / anyOf \\":26,\\"../ dotjs / const \\":27,\\"../ dotjs / contains \\":28,\\"../ dotjs / dependencies \\":30,\\"../ dotjs / enum \\":31,\\"../ dotjs / format \\":32,\\"../ dotjs / items \\":33,\\"../ dotjs / multipleOf \\":34,\\"../ dotjs / NOT \\":35,\\"../ dotjs / oneOf \\":36,\\"../ dotjs / pattern \\":37,\\"../ dotjs / properties \\":38,\\"../ dotjs / propertyNames \\":39,\\"../ dotjs / ref \\":40,\\"../ dotjs / required \\":41,\\"../ dotjs / uniqueItems \\":42,\\"../ dotjs / validate \\":43}],12:[function(require,module,exports){
''use strict'';
var MissingRefError = require(''./error_classes'').MissingRef;
module.exports = compileAsync;
/**
* Creates validating function for passed schema with asynchronous loading of missing schemas.
* \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
* @this  Ajv
* @param {Object}   schema schema object
* @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
* @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
* @return {Promise} promise that resolves with a validating function.
*/
function compileAsync(schema, meta, callback) {
/* eslint no-shadow: 0 */
/* global Promise */
/* jshint validthis: true */
var self = this;
if (typeof this._opts.loadSchema != ''function'')
throw new Error(''options.loadSchema should be a function'');
if (typeof meta == ''function'') {
callback = meta;
meta = undefined;
}
var p = loadMetaSchemaOf(schema).then(function () {
var schemaObj = self._addSchema(schema, undefined, meta);
return schemaObj.validate || _compileAsync(schemaObj);
});
if (callback) {
p.then(
function(v) { callback(null, v); },
callback
);
}
return p;
function loadMetaSchemaOf(sch) {
var $schema = sch.$schema;
return $schema && !self.getSchema($schema)
? compileAsync.call(self, { $ref: $schema }, true)
: Promise.resolve();
}
function _compileAsync(schemaObj) {
try { return self._compile(schemaObj); }
catch(e) {
if (e instanceof MissingRefError) return loadMissingSchema(e);
throw e;
}
function loadMissingSchema(e) {
var ref = e.missingSchema;
if (added(ref)) throw new Error(''Schema '' + ref + '' is loaded but '' + e.missingRef + '' cannot be resolved'');
var schemaPromise = self._loadingSchemas[ref];
if (!schemaPromise) {
schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
schemaPromise.then(removePromise, removePromise);
}
return schemaPromise.then(function (sch) {
if (!added(ref)) {
return loadMetaSchemaOf(sch).then(function () {
if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
});
}
}).then(function() {
return _compileAsync(schemaObj);
});
function removePromise() {
delete self._loadingSchemas[ref];
}
function added(ref) {
return self._refs[ref] || self._schemas[ref];
}
}
}
}
},{\\"./ error_classes \\":13}],13:[function(require,module,exports){
''use strict'';
var resolve = require(''./resolve'');
module.exports = {
Validation: errorSubclass(ValidationError),
MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
this.message = ''validation failed'';
this.errors = errors;
this.ajv = this.validation = true;
}
MissingRefError.message = function (baseId, ref) {
return ''can\\\\''t resolve reference '' + ref + '' from id '' + baseId;
};
function MissingRefError(baseId, ref, message) {
this.message = message || MissingRefError.message(baseId, ref);
this.missingRef = resolve.url(baseId, ref);
this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
Subclass.prototype = Object.create(Error.prototype);
Subclass.prototype.constructor = Subclass;
return Subclass;
}
},{\\"./ resolve \\":16}],14:[function(require,module,exports){
''use strict'';
var util = require(''./util'');
var DATE = /^\\\\d\\\\d\\\\d\\\\d-(\\\\d\\\\d)-(\\\\d\\\\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)(\\\\.\\\\d+)?(z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\\\\-.]*:)(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''()*+,;=]|%[0-9a-f]{2})*)(?::\\\\d*)?(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\\\?(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\\\-.]*:)?(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''\\" () * +,; =] | %[0 - 9a - f] {2}) *) (?::d *) ? (? : / (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@] | %[0 - 9a - f] {2}) *) *) ? | (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\\\?(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@ / ?] | %[0 - 9a - f] {2}) *) ? (? : # (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\\\x00-\\\\x20\\"'' <> % \\\\\\\\ ^ \`{|}]|%[0-9a-f]{2})|\\\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?)*\\\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\\\/\\\\/)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!10(?:\\\\.\\\\d{1,3}){3})(?!127(?:\\\\.\\\\d{1,3}){3})(?!169\\\\.254(?:\\\\.\\\\d{1,3}){2})(?!192\\\\.168(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)*(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}]{2,})))(?::\\\\d{2,5})?(?:\\\\/[^\\\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\\\u017F]?|ftp):\\\\/\\\\/)(?:(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+(?::(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?@)?(?:(?!10(?:\\\\.[0-9]{1,3}){3})(?!127(?:\\\\.[0-9]{1,3}){3})(?!169\\\\.254(?:\\\\.[0-9]{1,3}){2})(?!192\\\\.168(?:\\\\.[0-9]{1,3}){2})(?!172\\\\.(?:1[6-9]|2[0-9]|3[01])(?:\\\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)(?:\\\\.(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)*(?:\\\\.(?:(?:[KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\\\/(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\\\/(?:[a-z0-9_\\\\-.!$&''()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\\\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
mode = mode == ''full'' ? ''full'' : ''fast'';
return util.copy(formats[mode]);
}
formats.fast = {
// date: http://tools.ietf.org/html/rfc3339#section-5.6
date: /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d$/,
// date-time: http://tools.ietf.org/html/rfc3339#section-5.6
time: /^[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i,
''date-time'': /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d[t\\\\s][0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)$/i,
// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\\\\/)\\\\/?[^\\\\s]*$/i,
''uri-reference'': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\\\/\\\\/)?[^\\\\s]*$/i,
''uri-template'': URITEMPLATE,
url: URL,
// email (sources from jsen validator):
// http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
// http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for ''willful violation'')
email: /^[a-z0-9.!#$%&''*+/=?^_\` {|}~ -] + @[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ? (? :.[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ?) * $ / i, hostname: HOSTNAME, / / optimized https: / / www.safaribooksonline.com / library / VIEW / regular - expressions - cookbook / 9780596802837 / ch07s16.html ipv4: / ^ (? : (? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?).) {3}(? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?) $ /, / / optimized http: / / stackoverflow.com / questions / 53497 / regular - expression - that - matches - valid - ipv6 - addresses ipv6: / ^ s * (? : (? : (? :[0 - 9a - f] {1, 4 } :) {7}(? :[0 - 9a - f] {1, 4 }| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {6}(?::[0 - 9a - f] {1, 4 }|(? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {5}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 2 })| : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {4}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 3 })|(? : (?::[0 - 9a - f] {1, 4 })? : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {3}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 4 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 2 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {2}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 5 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 3 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {1}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 6 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 4 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (?::(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 7 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 5 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :))) (? : %.+) ? s * $ / i, regex: regex, / / uuid: http: / / tools.ietf.org / html / rfc4122 uuid: uuid, / / json - pointer: https: / / tools.ietf.org / html / rfc6901 / / uri fragment: https: / / tools.ietf.org / html / rfc3986 # appendix - A ''json-pointer'' : JSON_POINTER, / / relative json - pointer: http: / / tools.ietf.org / html / draft - luff - relative - json - pointer - 00 ''relative-json-pointer'' : RELATIVE_JSON_POINTER }; formats.full = { date: date, time: time, ''date-time'' : date_time, uri: uri, ''uri-reference'' : URIREF, ''uri-template'' : URITEMPLATE, url: URL, email: / ^[a - z0 - 9 ! # $ % & ''*+/=?^_\`{|}~-]+(?:\\\\.[a-z0-9!#$%&''''*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
hostname: hostname,
ipv4: /^(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$/,
ipv6: /^\\\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:)))(?:%.+)?\\\\s*$/i,
regex: regex,
uuid: UUID,
'' json - pointer '': JSON_POINTER,
'' relative - json - pointer '': RELATIVE_JSON_POINTER
};
function date(str) {
// full-date from http://tools.ietf.org/html/rfc3339#section-5.6
var matches = str.match(DATE);
if (!matches) return false;
var month = +matches[1];
var day = +matches[2];
return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}
function time(str, full) {
var matches = str.match(TIME);
if (!matches) return false;
var hour = matches[1];
var minute = matches[2];
var second = matches[3];
var timeZone = matches[5];
return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\\\\s/i;
function date_time(str) {
// http://tools.ietf.org/html/rfc3339#section-5.6
var dateTime = str.split(DATE_TIME_SEPARATOR);
return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function hostname(str) {
// https://tools.ietf.org/html/rfc1034#section-3.5
// https://tools.ietf.org/html/rfc1123#section-2
return str.length <= 255 && HOSTNAME.test(str);
}
var NOT_URI_FRAGMENT = /\\\\/|:/;
function uri(str) {
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \\".\\"
return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\\\\\\\]\\\\\\\\Z/;
function regex(str) {
if (Z_ANCHOR.test(str)) return false;
try {
new RegExp(str);
return true;
} catch(e) {
return false;
}
}
},{\\"./util\\":20}],15:[function(require,module,exports){
'' use STRICT '';
var resolve = require(''./ resolve '')
, util = require(''./ util '')
, errorClasses = require(''./ error_classes '')
, stableStringify = require('' json - STABLE - stringify '');
var validateGenerator = require(''../ dotjs / validate '');
/**
* Functions below are used inside compiled validations function
*/
var co = require('' co '');
var ucs2length = util.ucs2length;
var equal = require('' fast - deep - equal '');
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
* Compiles schema to validation function
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Object} root object with information about the root schema for this schema
* @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
* @param  {String} baseId base ID for IDs in the schema
* @return {Function} validation function
*/
function compile(schema, root, localRefs, baseId) {
/* jshint validthis: true, evil: true */
/* eslint no-shadow: 0 */
var self = this
, opts = this._opts
, refVal = [ undefined ]
, refs = {}
, patterns = []
, patternsHash = {}
, defaults = []
, defaultsHash = {}
, customRules = [];
root = root || { schema: schema, refVal: refVal, refs: refs };
var c = checkCompiling.call(this, schema, root, baseId);
var compilation = this._compilations[c.index];
if (c.compiling) return (compilation.callValidate = callValidate);
var formats = this._formats;
var RULES = this.RULES;
try {
var v = localCompile(schema, root, localRefs, baseId);
compilation.validate = v;
var cv = compilation.callValidate;
if (cv) {
cv.schema = v.schema;
cv.errors = null;
cv.refs = v.refs;
cv.refVal = v.refVal;
cv.root = v.root;
cv.$async = v.$async;
if (opts.sourceCode) cv.source = v.source;
}
return v;
} finally {
endCompiling.call(this, schema, root, baseId);
}
function callValidate() {
var validate = compilation.validate;
var result = validate.apply(null, arguments);
callValidate.errors = validate.errors;
return result;
}
function localCompile(_schema, _root, localRefs, baseId) {
var isRoot = !_root || (_root && _root.schema == _schema);
if (_root.schema != root.schema)
return compile.call(self, _schema, _root, localRefs, baseId);
var $async = _schema.$async === true;
var sourceCode = validateGenerator({
isTop: true,
schema: _schema,
isRoot: isRoot,
baseId: baseId,
root: _root,
schemaPath: '''',
errSchemaPath: '' # '',
errorPath: '' \\"\\" '',
MissingRefError: errorClasses.MissingRef,
RULES: RULES,
validate: validateGenerator,
util: util,
resolve: resolve,
resolveRef: resolveRef,
usePattern: usePattern,
useDefault: useDefault,
useCustomRule: useCustomRule,
opts: opts,
formats: formats,
self: self
});
sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
+ vars(defaults, defaultCode) + vars(customRules, customRuleCode)
+ sourceCode;
if (opts.processCode) sourceCode = opts.processCode(sourceCode);
// console.log('' n n n * * * n '', JSON.stringify(sourceCode));
var validate;
try {
var makeValidate = new Function(
'' self '',
'' RULES '',
'' formats '',
'' root '',
'' refVal '',
'' defaults '',
'' customRules '',
'' co '',
'' equal '',
'' ucs2length '',
'' ValidationError '',
sourceCode
);
validate = makeValidate(
self,
RULES,
formats,
root,
refVal,
defaults,
customRules,
co,
equal,
ucs2length,
ValidationError
);
refVal[0] = validate;
} catch(e) {
console.error('' Error compiling SCHEMA, FUNCTION code: '', sourceCode);
throw e;
}
validate.schema = _schema;
validate.errors = null;
validate.refs = refs;
validate.refVal = refVal;
validate.root = isRoot ? validate : _root;
if ($async) validate.$async = true;
if (opts.sourceCode === true) {
validate.source = {
code: sourceCode,
patterns: patterns,
defaults: defaults
};
}
return validate;
}
function resolveRef(baseId, ref, isRoot) {
ref = resolve.url(baseId, ref);
var refIndex = refs[ref];
var _refVal, refCode;
if (refIndex !== undefined) {
_refVal = refVal[refIndex];
refCode = '' refVal['' + refIndex + ''] '';
return resolvedRef(_refVal, refCode);
}
if (!isRoot && root.refs) {
var rootRefId = root.refs[ref];
if (rootRefId !== undefined) {
_refVal = root.refVal[rootRefId];
refCode = addLocalRef(ref, _refVal);
return resolvedRef(_refVal, refCode);
}
}
refCode = addLocalRef(ref);
var v = resolve.call(self, localCompile, root, ref);
if (v === undefined) {
var localSchema = localRefs && localRefs[ref];
if (localSchema) {
v = resolve.inlineRef(localSchema, opts.inlineRefs)
? localSchema
: compile.call(self, localSchema, root, localRefs, baseId);
}
}
if (v === undefined) {
removeLocalRef(ref);
} else {
replaceLocalRef(ref, v);
return resolvedRef(v, refCode);
}
}
function addLocalRef(ref, v) {
var refId = refVal.length;
refVal[refId] = v;
refs[ref] = refId;
return '' refVal '' + refId;
}
function removeLocalRef(ref) {
delete refs[ref];
}
function replaceLocalRef(ref, v) {
var refId = refs[ref];
refVal[refId] = v;
}
function resolvedRef(refVal, code) {
return typeof refVal == '' object '' || typeof refVal == '' boolean ''
? { code: code, schema: refVal, inline: true }
: { code: code, $async: refVal && refVal.$async };
}
function usePattern(regexStr) {
var index = patternsHash[regexStr];
if (index === undefined) {
index = patternsHash[regexStr] = patterns.length;
patterns[index] = regexStr;
}
return '' pattern '' + index;
}
function useDefault(value) {
switch (typeof value) {
case '' boolean '':
case '' number '':
return '''' + value;
case '' string '':
return util.toQuotedString(value);
case '' object '':
if (value === null) return '' NULL '';
var valueStr = stableStringify(value);
var index = defaultsHash[valueStr];
if (index === undefined) {
index = defaultsHash[valueStr] = defaults.length;
defaults[index] = value;
}
return '' DEFAULT '' + index;
}
}
function useCustomRule(rule, schema, parentSchema, it) {
var validateSchema = rule.definition.validateSchema;
if (validateSchema && self._opts.validateSchema !== false) {
var valid = validateSchema(schema);
if (!valid) {
var message = '' keyword SCHEMA IS invalid: '' + self.errorsText(validateSchema.errors);
if (self._opts.validateSchema == '' log '') console.error(message);
else throw new Error(message);
}
}
var compile = rule.definition.compile
, inline = rule.definition.inline
, macro = rule.definition.macro;
var validate;
if (compile) {
validate = compile.call(self, schema, parentSchema, it);
} else if (macro) {
validate = macro.call(self, schema, parentSchema, it);
if (opts.validateSchema !== false) self.validateSchema(validate, true);
} else if (inline) {
validate = inline.call(self, it, rule.keyword, schema, parentSchema);
} else {
validate = rule.definition.validate;
if (!validate) return;
}
if (validate === undefined)
throw new Error('' custom keyword \\"'' + rule.keyword + ''\\" failed TO compile '');
var index = customRules.length;
customRules[index] = validate;
return {
code: '' customRule '' + index,
validate: validate
};
}
}
/**
* Checks if the schema is currently compiled
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Object} object with properties \\"index\\" (compilation index) and \\"compiling\\" (boolean)
*/
function checkCompiling(schema, root, baseId) {
/* jshint validthis: true */
var index = compIndex.call(this, schema, root, baseId);
if (index >= 0) return { index: index, compiling: true };
index = this._compilations.length;
this._compilations[index] = {
schema: schema,
root: root,
baseId: baseId
};
return { index: index, compiling: false };
}
/**
* Removes the schema from the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
*/
function endCompiling(schema, root, baseId) {
/* jshint validthis: true */
var i = compIndex.call(this, schema, root, baseId);
if (i >= 0) this._compilations.splice(i, 1);
}
/**
* Index of schema compilation in the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Integer} compilation index
*/
function compIndex(schema, root, baseId) {
/* jshint validthis: true */
for (var i=0; i<this._compilations.length; i++) {
var c = this._compilations[i];
if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
}
return -1;
}
function patternCode(i, patterns) {
return '' var pattern '' + i + '' = new RegExp ('' + util.toQuotedString(patterns[i]) + ''); '';
}
function defaultCode(i) {
return '' var DEFAULT '' + i + '' = defaults['' + i + '']; '';
}
function refValCode(i, refVal) {
return refVal[i] === undefined ? '''' : '' var refVal '' + i + '' = refVal['' + i + '']; '';
}
function customRuleCode(i) {
return '' var customRule '' + i + '' = customRules['' + i + '']; '';
}
function vars(arr, statement) {
if (!arr.length) return '''';
var code = '''';
for (var i=0; i<arr.length; i++)
code += statement(i, arr);
return code;
}
},{\\"../dotjs/validate\\":43,\\"./error_classes\\":13,\\"./resolve\\":16,\\"./util\\":20,\\"co\\":48,\\"fast-deep-equal\\":49,\\"json-stable-stringify\\":51}],16:[function(require,module,exports){
'' use STRICT '';
var url = require('' url '')
, equal = require('' fast - deep - equal '')
, util = require(''./ util '')
, SchemaObject = require(''./ schema_obj '')
, traverse = require('' json - SCHEMA - traverse '');
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
* [resolve and compile the references ($ref)]
* @this   Ajv
* @param  {Function} compile reference to schema compilation funciton (localCompile)
* @param  {Object} root object with information about the root schema for the current schema
* @param  {String} ref reference to resolve
* @return {Object|Function} schema object (if the schema can be inlined) or validation function
*/
function resolve(compile, root, ref) {
/* jshint validthis: true */
var refVal = this._refs[ref];
if (typeof refVal == '' string '') {
if (this._refs[refVal]) refVal = this._refs[refVal];
else return resolve.call(this, compile, root, refVal);
}
refVal = refVal || this._schemas[ref];
if (refVal instanceof SchemaObject) {
return inlineRef(refVal.schema, this._opts.inlineRefs)
? refVal.schema
: refVal.validate || this._compile(refVal);
}
var res = resolveSchema.call(this, root, ref);
var schema, v, baseId;
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
if (schema instanceof SchemaObject) {
v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
} else if (schema !== undefined) {
v = inlineRef(schema, this._opts.inlineRefs)
? schema
: compile.call(this, schema, root, undefined, baseId);
}
return v;
}
/**
* Resolve schema, its root and baseId
* @this Ajv
* @param  {Object} root root object with properties schema, refVal, refs
* @param  {String} ref  reference to resolve
* @return {Object} object with properties schema, root, baseId
*/
function resolveSchema(root, ref) {
/* jshint validthis: true */
var p = url.parse(ref, false, true)
, refPath = _getFullPath(p)
, baseId = getFullPath(this._getId(root.schema));
if (refPath !== baseId) {
var id = normalizeId(refPath);
var refVal = this._refs[id];
if (typeof refVal == '' string '') {
return resolveRecursive.call(this, root, refVal, p);
} else if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
root = refVal;
} else {
refVal = this._schemas[id];
if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
if (id == normalizeId(ref))
return { schema: refVal, root: root, baseId: baseId };
root = refVal;
} else {
return;
}
}
if (!root.schema) return;
baseId = getFullPath(this._getId(root.schema));
}
return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
/* jshint validthis: true */
var res = resolveSchema.call(this, root, ref);
if (res) {
var schema = res.schema;
var baseId = res.baseId;
root = res.root;
var id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
return getJsonPointer.call(this, parsedRef, baseId, schema, root);
}
}
var PREVENT_SCOPE_CHANGE = util.toHash(['' properties '', '' patternProperties '', '' enum '', '' dependencies '', '' definitions '']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
/* jshint validthis: true */
parsedRef.hash = parsedRef.hash || '''';
if (parsedRef.hash.slice(0,2) != '' # / '') return;
var parts = parsedRef.hash.split('' / '');
for (var i = 1; i < parts.length; i++) {
var part = parts[i];
if (part) {
part = util.unescapeFragment(part);
schema = schema[part];
if (schema === undefined) break;
var id;
if (!PREVENT_SCOPE_CHANGE[part]) {
id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
if (schema.$ref) {
var $ref = resolveUrl(baseId, schema.$ref);
var res = resolveSchema.call(this, root, $ref);
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
}
}
}
}
if (schema !== undefined && schema !== root.schema)
return { schema: schema, root: root, baseId: baseId };
}
var SIMPLE_INLINED = util.toHash([
'' TYPE '', '' format '', '' pattern '',
'' maxLength '', '' minLength '',
'' maxProperties '', '' minProperties '',
'' maxItems '', '' minItems '',
'' maximum '', '' minimum '',
'' uniqueItems '', '' multipleOf '',
'' required '', '' enum ''
]);
function inlineRef(schema, limit) {
if (limit === false) return false;
if (limit === undefined || limit === true) return checkNoRef(schema);
else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
var item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return false;
item = schema[key];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
}
return true;
}
function countKeys(schema) {
var count = 0, item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '') count += countKeys(item);
if (count == Infinity) return Infinity;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return Infinity;
if (SIMPLE_INLINED[key]) {
count++;
} else {
item = schema[key];
if (typeof item == '' object '') count += countKeys(item) + 1;
if (count == Infinity) return Infinity;
}
}
}
return count;
}
function getFullPath(id, normalize) {
if (normalize !== false) id = normalizeId(id);
var p = url.parse(id, false, true);
return _getFullPath(p);
}
function _getFullPath(p) {
var protocolSeparator = p.protocol || p.href.slice(0,2) == '' / / '' ? '' / / '' : '''';
return (p.protocol||'''') + protocolSeparator + (p.host||'''') + (p.path||'''')  + '' # '';
}
var TRAILING_SLASH_HASH = /#\\\\/?$/;
function normalizeId(id) {
return id ? id.replace(TRAILING_SLASH_HASH, '''') : '''';
}
function resolveUrl(baseId, id) {
id = normalizeId(id);
return url.resolve(baseId, id);
}
/* @this Ajv */
function resolveIds(schema) {
var schemaId = normalizeId(this._getId(schema));
var baseIds = {'''': schemaId};
var fullPaths = {'''': getFullPath(schemaId, false)};
var localRefs = {};
var self = this;
traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (jsonPtr === '''') return;
var id = self._getId(sch);
var baseId = baseIds[parentJsonPtr];
var fullPath = fullPaths[parentJsonPtr] + '' / '' + parentKeyword;
if (keyIndex !== undefined)
fullPath += '' / '' + (typeof keyIndex == '' number '' ? keyIndex : util.escapeFragment(keyIndex));
if (typeof id == '' string '') {
id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);
var refVal = self._refs[id];
if (typeof refVal == '' string '') refVal = self._refs[refVal];
if (refVal && refVal.schema) {
if (!equal(sch, refVal.schema))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
} else if (id != normalizeId(fullPath)) {
if (id[0] == '' # '') {
if (localRefs[id] && !equal(sch, localRefs[id]))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
localRefs[id] = sch;
} else {
self._refs[id] = fullPath;
}
}
}
baseIds[jsonPtr] = baseId;
fullPaths[jsonPtr] = fullPath;
});
return localRefs;
}
},{\\"./schema_obj\\":18,\\"./util\\":20,\\"fast-deep-equal\\":49,\\"json-schema-traverse\\":50,\\"url\\":5}],17:[function(require,module,exports){
'' use STRICT '';
var ruleModules = require(''./ _rules '')
, toHash = require(''./ util '').toHash;
module.exports = function rules() {
var RULES = [
{ type: '' number '',
rules: [ { '' maximum '': ['' exclusiveMaximum ''] },
{ '' minimum '': ['' exclusiveMinimum ''] }, '' multipleOf '', '' format ''] },
{ type: '' string '',
rules: [ '' maxLength '', '' minLength '', '' pattern '', '' format '' ] },
{ type: '' ARRAY '',
rules: [ '' maxItems '', '' minItems '', '' uniqueItems '', '' contains '', '' items '' ] },
{ type: '' object '',
rules: [ '' maxProperties '', '' minProperties '', '' required '', '' dependencies '', '' propertyNames '',
{ '' properties '': ['' additionalProperties '', '' patternProperties ''] } ] },
{ rules: [ '' $ ref '', '' const '', '' enum '', '' NOT '', '' anyOf '', '' oneOf '', '' allOf '' ] }
];
var ALL = [ '' TYPE '' ];
var KEYWORDS = [
'' additionalItems '', '' $ SCHEMA '', '' id '', '' title '',
'' description '', '' DEFAULT '', '' definitions ''
];
var TYPES = [ '' number '', '' integer '', '' string '', '' ARRAY '', '' object '', '' boolean '', '' NULL '' ];
RULES.all = toHash(ALL);
RULES.types = toHash(TYPES);
RULES.forEach(function (group) {
group.rules = group.rules.map(function (keyword) {
var implKeywords;
if (typeof keyword == '' object '') {
var key = Object.keys(keyword)[0];
implKeywords = keyword[key];
keyword = key;
implKeywords.forEach(function (k) {
ALL.push(k);
RULES.all[k] = true;
});
}
ALL.push(keyword);
var rule = RULES.all[keyword] = {
keyword: keyword,
code: ruleModules[keyword],
implements: implKeywords
};
return rule;
});
if (group.type) RULES.types[group.type] = group;
});
RULES.keywords = toHash(ALL.concat(KEYWORDS));
RULES.custom = {};
return RULES;
};
},{\\"./_rules\\":11,\\"./util\\":20}],18:[function(require,module,exports){
'' use STRICT '';
var util = require(''./ util '');
module.exports = SchemaObject;
function SchemaObject(obj) {
util.copy(obj, this);
}
},{\\"./util\\":20}],19:[function(require,module,exports){
'' use STRICT '';
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
var length = 0
, len = str.length
, pos = 0
, value;
while (pos < len) {
length++;
value = str.charCodeAt(pos++);
if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
// high surrogate, and there is a next character
value = str.charCodeAt(pos);
if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
}
}
return length;
};
},{}],20:[function(require,module,exports){
'' use STRICT '';
module.exports = {
copy: copy,
checkDataType: checkDataType,
checkDataTypes: checkDataTypes,
coerceToTypes: coerceToTypes,
toHash: toHash,
getProperty: getProperty,
escapeQuotes: escapeQuotes,
equal: require('' fast - deep - equal ''),
ucs2length: require(''./ ucs2length ''),
varOccurences: varOccurences,
varReplace: varReplace,
cleanUpCode: cleanUpCode,
finalCleanUpCode: finalCleanUpCode,
schemaHasRules: schemaHasRules,
schemaHasRulesExcept: schemaHasRulesExcept,
toQuotedString: toQuotedString,
getPathExpr: getPathExpr,
getPath: getPath,
getData: getData,
unescapeFragment: unescapeFragment,
unescapeJsonPointer: unescapeJsonPointer,
escapeFragment: escapeFragment,
escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
to = to || {};
for (var key in o) to[key] = o[key];
return to;
}
function checkDataType(dataType, data, negate) {
var EQUAL = negate ? '' != = '' : '' == = ''
, AND = negate ? '' || '' : '' && ''
, OK = negate ? '' ! '' : ''''
, NOT = negate ? '''' : '' ! '';
switch (dataType) {
case '' NULL '': return data + EQUAL + '' NULL '';
case '' ARRAY '': return OK + '' Array.isArray ('' + data + '') '';
case '' object '': return '' ('' + OK + data + AND +
'' typeof '' + data + EQUAL + '' \\"object\\" '' + AND +
NOT + '' Array.isArray ('' + data + '')) '';
case '' integer '': return '' (typeof '' + data + EQUAL + '' \\"number\\" '' + AND +
NOT + '' ('' + data + '' % 1) '' +
AND + data + EQUAL + data + '') '';
default: return '' typeof '' + data + EQUAL + '' \\"'' + dataType + ''\\" '';
}
}
function checkDataTypes(dataTypes, data) {
switch (dataTypes.length) {
case 1: return checkDataType(dataTypes[0], data, true);
default:
var code = '''';
var types = toHash(dataTypes);
if (types.array && types.object) {
code = types.null ? '' ('': '' (! '' + data + '' || '';
code += '' typeof '' + data + '' != = \\"object\\") '';
delete types.null;
delete types.array;
delete types.object;
}
if (types.number) delete types.integer;
for (var t in types)
code += (code ? '' && '' : '''' ) + checkDataType(t, data, true);
return code;
}
}
var COERCE_TO_TYPES = toHash([ '' string '', '' number '', '' integer '', '' boolean '', '' NULL '' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
if (Array.isArray(dataTypes)) {
var types = [];
for (var i=0; i<dataTypes.length; i++) {
var t = dataTypes[i];
if (COERCE_TO_TYPES[t]) types[types.length] = t;
else if (optionCoerceTypes === '' ARRAY '' && t === '' ARRAY '') types[types.length] = t;
}
if (types.length) return types;
} else if (COERCE_TO_TYPES[dataTypes]) {
return [dataTypes];
} else if (optionCoerceTypes === '' ARRAY '' && dataTypes === '' ARRAY '') {
return ['' ARRAY ''];
}
}
function toHash(arr) {
var hash = {};
for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'' | \\\\\\\\ / g; FUNCTION getProperty (KEY) { RETURN typeof KEY == ''number'' ? ''['' + KEY + '']'' : IDENTIFIER.test (KEY) ? ''.'' + KEY :\\"[''\\" + escapeQuotes (KEY) + \\"'']\\"; } FUNCTION escapeQuotes (str) { RETURN str.replace(SINGLE_QUOTE, ''\\\\\\\\$&'').replace(/ n / g, ''\\\\\\\\n'').replace(/ r / g, ''\\\\\\\\r'').replace(/ f / g, ''\\\\\\\\f'').replace(/ t / g, ''\\\\\\\\t''); } FUNCTION varOccurences (str, dataVar) { dataVar + = ''[^0-9]''; var matches = str.match (new RegExp (dataVar, ''g'')); RETURN matches ? matches.length : 0; } FUNCTION varReplace (str, dataVar, expr) { dataVar + = ''([^0-9])''; expr = expr.replace(/ $ / g, ''$$$$''); RETURN str.replace(new RegExp (dataVar, ''g''), expr + ''$1''); } var EMPTY_ELSE = /
ELSE
s * { s * } / g, EMPTY_IF_NO_ELSE = / IF s * ([^)] +) s * { s * }(?! s *
ELSE
) / g, EMPTY_IF_WITH_ELSE = / IF s * (([^)] +)) s * { s * } s *
ELSE
(? ! s * IF) / g; FUNCTION cleanUpCode (out) { RETURN out.replace(EMPTY_ELSE, '''').replace(EMPTY_IF_NO_ELSE, '''').replace(EMPTY_IF_WITH_ELSE, ''if (!($1))''); } var ERRORS_REGEXP = /[^ v.] errors / g, REMOVE_ERRORS = / var errors = 0; | var vErrors = NULL; | validate.errors = vErrors; / g, REMOVE_ERRORS_ASYNC = / var errors = 0; | var vErrors = NULL; / g, RETURN_VALID = ''return errors === 0;'', RETURN_TRUE = ''validate.errors = null; return true;'', RETURN_ASYNC = / IF (errors == = 0)
RETURN data; s *
ELSE
throw new ValidationError (vErrors); /, RETURN_DATA_ASYNC = ''return data;'', ROOTDATA_REGEXP = /[^ A - Za - z_$] rootData[^ A - Za - z0 - 9_$] / g, REMOVE_ROOTDATA = / IF (rootData == = undefined) rootData = data; /; FUNCTION finalCleanUpCode (out, async) { var matches = out.match (ERRORS_REGEXP); IF (matches && matches.length == 2) { out = async ? out.replace(REMOVE_ERRORS_ASYNC, '''').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '''').replace(RETURN_VALID, RETURN_TRUE); } matches = out.match (ROOTDATA_REGEXP); IF (! matches || matches.length != = 3)
RETURN out; RETURN out.replace(REMOVE_ROOTDATA, ''''); } FUNCTION schemaHasRules (SCHEMA, rules) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA; FOR (var KEY IN SCHEMA)
IF (rules[KEY])
RETURN TRUE; } FUNCTION schemaHasRulesExcept (SCHEMA, rules, exceptKeyword) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA && exceptKeyword != ''not''; FOR (var KEY IN SCHEMA)
IF (KEY != exceptKeyword && rules[KEY])
RETURN TRUE; } FUNCTION toQuotedString (str) { RETURN ''\\\\'''' + escapeQuotes (str) + ''\\\\''''; } FUNCTION getPathExpr (currentPath, expr, jsonPointers, isNumber) { var path = jsonPointers / / FALSE BY DEFAULT ? ''\\\\''/\\\\'' + '' + expr + (isNumber ? '''' :''.replace(/~/g, \\\\''~0\\\\'').replace(/\\\\\\\\//g, \\\\''~1\\\\'')'') : (isNumber ? ''\\\\''[\\\\'' + '' + expr + '' + \\\\'']\\\\'''' :''\\\\''[\\\\\\\\\\\\''\\\\'' + '' + expr + '' + \\\\''\\\\\\\\\\\\'']\\\\''''); RETURN joinPaths (currentPath, path); } FUNCTION getPath (currentPath, prop, jsonPointers) { var path = jsonPointers / / FALSE BY DEFAULT ? toQuotedString (''/'' + escapeJsonPointer (prop)) : toQuotedString (getProperty (prop)); RETURN joinPaths (currentPath, path); } var JSON_POINTER = / ^ / (? :[^ ~] | ~ 0 | ~ 1) * $ /; var RELATIVE_JSON_POINTER = / ^ ([0 - 9] +) (# | / (? :[^ ~] | ~ 0 | ~ 1) *) ? $ /; FUNCTION getData ($ data, lvl, paths) { var up, jsonPointer, data, matches; IF ($ data == = '''')
RETURN ''rootData''; IF ($ data[0] == ''/'') { IF (! JSON_POINTER.test ($ data)) throw new Error (''Invalid JSON-pointer: '' + $ data); jsonPointer = $ data; data = ''rootData''; }
ELSE
{ matches = $ data.match (RELATIVE_JSON_POINTER); IF (! matches) throw new Error (''Invalid JSON-pointer: '' + $ data); up = + matches[1]; jsonPointer = matches[2]; IF (jsonPointer == ''#'') { IF (up >= lvl) throw new Error (''Cannot access property/index '' + up + '' levels up, current level is '' + lvl); RETURN paths[lvl - up]; } IF (up > lvl) throw new Error (''Cannot access data '' + up + '' levels up, current level is '' + lvl); data = ''data'' + ((lvl - up) || ''''); IF (! jsonPointer)
RETURN data; } var expr = data; var segments = jsonPointer.split (''/''); FOR (var i = 0; i < segments.length; i + +) { var segment = segments[i]; IF (segment) { data + = getProperty (unescapeJsonPointer (segment)); expr + = '' && '' + data; } } RETURN expr; } FUNCTION joinPaths (a, b) { IF (a == ''\\"\\"'')
RETURN b; RETURN (a + '' + '' + b).replace(/ '' \\\\+ '' / g, ''''); } FUNCTION unescapeFragment (str) { RETURN unescapeJsonPointer (decodeURIComponent (str)); } FUNCTION escapeFragment (str) { RETURN encodeURIComponent (escapeJsonPointer (str)); } FUNCTION escapeJsonPointer (str) { RETURN str.replace(/ ~ / g, ''~0'').replace(/ / / g, ''~1''); } FUNCTION unescapeJsonPointer (str) { RETURN str.replace(/ ~ 1 / g, ''/'').replace(/ ~ 0 / g, ''~''); } }, {\\". / ucs2length \\":19,\\" fast - deep - equal \\":49}],21:[function(require,module,exports){
''use strict'';
module.exports = function generate__limit(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $isMax = $keyword == ''maximum'',
$exclusiveKeyword = $isMax ? ''exclusiveMaximum'' : ''exclusiveMinimum'',
$schemaExcl = it.schema[$exclusiveKeyword],
$isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
$op = $isMax ? ''<'' : ''>'',
$notOp = $isMax ? ''>'' : ''<'',
$errorKeyword = undefined;
if ($isDataExcl) {
var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
$exclusive = ''exclusive'' + $lvl,
$exclType = ''exclType'' + $lvl,
$exclIsNumber = ''exclIsNumber'' + $lvl,
$opExpr = ''op'' + $lvl,
$opStr = ''\\\\'' + '' + $opExpr + '' + \\\\'''';
out += '' var schemaExcl'' + ($lvl) + '' = '' + ($schemaValueExcl) + ''; '';
$schemaValueExcl = ''schemaExcl'' + $lvl;
out += '' var '' + ($exclusive) + ''; var '' + ($exclType) + '' = typeof '' + ($schemaValueExcl) + ''; if ('' + ($exclType) + '' != \\\\''boolean\\\\'' && '' + ($exclType) + '' != \\\\''undefined\\\\'' && '' + ($exclType) + '' != \\\\''number\\\\'') { '';
var $errorKeyword = $exclusiveKeyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_exclusiveLimit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''' + ($exclusiveKeyword) + '' should be boolean\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($exclType) + '' == \\\\''number\\\\'' ? (('' + ($exclusive) + '' = '' + ($schemaValue) + '' === undefined || '' + ($schemaValueExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '') ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValueExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) : (('' + ($exclusive) + '' = '' + ($schemaValueExcl) + '' === true) ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValue) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { var op'' + ($lvl) + '' = '' + ($exclusive) + '' ? \\\\'''' + ($op) + ''\\\\'' : \\\\'''' + ($op) + ''=\\\\'';'';
} else {
var $exclIsNumber = typeof $schemaExcl == ''number'',
$opStr = $op;
if ($exclIsNumber && $isData) {
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' ( '' + ($schemaValue) + '' === undefined || '' + ($schemaExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '' ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { '';
} else {
if ($exclIsNumber && $schema === undefined) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$schemaValue = $schemaExcl;
$notOp += ''='';
} else {
if ($exclIsNumber) $schemaValue = Math[$isMax ? ''min'' : ''max'']($schemaExcl, $schema);
if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$notOp += ''='';
} else {
$exclusive = false;
$opStr += ''='';
}
}
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' || '' + ($data) + '' !== '' + ($data) + '') { '';
}
}
$errorKeyword = $errorKeyword || $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { comparison: '' + ($opExpr) + '', limit: '' + ($schemaValue) + '', exclusive: '' + ($exclusive) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '' + ($opStr) + '' '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],22:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxItems'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + ''.length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxItems'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],23:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxLength'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
if (it.opts.unicode === false) {
out += '' '' + ($data) + ''.length '';
} else {
out += '' ucs2length('' + ($data) + '') '';
}
out += '' '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitLength'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be '';
if ($keyword == ''maxLength'') {
out += ''longer'';
} else {
out += ''shorter'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' characters\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],24:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxProperties'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' Object.keys('' + ($data) + '').length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxProperties'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],25:[function(require,module,exports){
''use strict'';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
var out = '' '';
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $currentBaseId = $it.baseId,
$allSchemasEmpty = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$allSchemasEmpty = false;
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($breakOnError) {
if ($allSchemasEmpty) {
out += '' if (true) { '';
} else {
out += '' '' + ($closingBraces.slice(0, -1)) + '' '';
}
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],26:[function(require,module,exports){
''use strict'';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $noEmptySchema = $schema.every(function($sch) {
return it.util.schemaHasRules($sch, it.RULES.all);
});
if ($noEmptySchema) {
var $currentBaseId = $it.baseId;
out += '' var '' + ($errs) + '' = errors; var '' + ($valid) + '' = false;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' '' + ($valid) + '' = '' + ($valid) + '' || '' + ($nextValid) + ''; if (!'' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''anyOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match some schema in anyOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],27:[function(require,module,exports){
''use strict'';
module.exports = function generate_const(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (!$isData) {
out += '' var schema'' + ($lvl) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '' = equal('' + ($data) + '', schema'' + ($lvl) + ''); if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''const'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to constant\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],28:[function(require,module,exports){
''use strict'';
module.exports = function generate_contains(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId,
$nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($nonEmptySchema) {
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($nextValid) + '' = false; for (var '' + ($idx) + '' = 0; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if ('' + ($nextValid) + '') break; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($nextValid) + '') {'';
} else {
out += '' if ('' + ($data) + ''.length == 0) {'';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''contains'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should contain a valid item\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
if ($nonEmptySchema) {
out += ''  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
}
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],29:[function(require,module,exports){
''use strict'';
module.exports = function generate_custom(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $rule = this,
$definition = ''definition'' + $lvl,
$rDef = $rule.definition,
$closingBraces = '''';
var $compile, $inline, $macro, $ruleValidate, $validateCode;
if ($isData && $rDef.$data) {
$validateCode = ''keywordValidate'' + $lvl;
var $validateSchema = $rDef.validateSchema;
out += '' var '' + ($definition) + '' = RULES.custom[\\\\'''' + ($keyword) + ''\\\\''].definition; var '' + ($validateCode) + '' = '' + ($definition) + ''.validate;'';
} else {
$ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
if (!$ruleValidate) return;
$schemaValue = ''validate.schema'' + $schemaPath;
$validateCode = $ruleValidate.code;
$compile = $rDef.compile;
$inline = $rDef.inline;
$macro = $rDef.macro;
}
var $ruleErrs = $validateCode + ''.errors'',
$i = ''i'' + $lvl,
$ruleErr = ''ruleErr'' + $lvl,
$asyncKeyword = $rDef.async;
if ($asyncKeyword && !it.async) throw new Error(''async keyword in sync schema'');
if (!($inline || $macro)) {
out += '''' + ($ruleErrs) + '' = null;'';
}
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($isData && $rDef.$data) {
$closingBraces += ''}'';
out += '' if ('' + ($schemaValue) + '' === undefined) { '' + ($valid) + '' = true; } else { '';
if ($validateSchema) {
$closingBraces += ''}'';
out += '' '' + ($valid) + '' = '' + ($definition) + ''.validateSchema('' + ($schemaValue) + ''); if ('' + ($valid) + '') { '';
}
}
if ($inline) {
if ($rDef.statements) {
out += '' '' + ($ruleValidate.validate) + '' '';
} else {
out += '' '' + ($valid) + '' = '' + ($ruleValidate.validate) + ''; '';
}
} else if ($macro) {
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $ruleValidate.validate;
$it.schemaPath = '''';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $validateCode);
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($code);
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
out += ''  '' + ($validateCode) + ''.call( '';
if (it.opts.passContext) {
out += ''this'';
} else {
out += ''self'';
}
if ($compile || $rDef.schema === false) {
out += '' , '' + ($data) + '' '';
} else {
out += '' , '' + ($schemaValue) + '' , '' + ($data) + '' , validate.schema'' + (it.schemaPath) + '' '';
}
out += '' , (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '' , rootData )  '';
var def_callRuleValidate = out;
out = $$outStack.pop();
if ($rDef.errors === false) {
out += '' '' + ($valid) + '' = '';
if ($asyncKeyword) {
out += '''' + (it.yieldAwait);
}
out += '''' + (def_callRuleValidate) + ''; '';
} else {
if ($asyncKeyword) {
$ruleErrs = ''customErrors'' + $lvl;
out += '' var '' + ($ruleErrs) + '' = null; try { '' + ($valid) + '' = '' + (it.yieldAwait) + (def_callRuleValidate) + ''; } catch (e) { '' + ($valid) + '' = false; if (e instanceof ValidationError) '' + ($ruleErrs) + '' = e.errors; else throw e; } '';
} else {
out += '' '' + ($ruleErrs) + '' = null; '' + ($valid) + '' = '' + (def_callRuleValidate) + ''; '';
}
}
}
if ($rDef.modifying) {
out += '' if ('' + ($parentData) + '') '' + ($data) + '' = '' + ($parentData) + ''['' + ($parentDataProperty) + ''];'';
}
out += '''' + ($closingBraces);
if ($rDef.valid) {
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
out += '' if ( '';
if ($rDef.valid === undefined) {
out += '' !'';
if ($macro) {
out += '''' + ($nextValid);
} else {
out += '''' + ($valid);
}
} else {
out += '' '' + (!$rDef.valid) + '' '';
}
out += '') { '';
$errorKeyword = $rule.keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
var def_customError = out;
out = $$outStack.pop();
if ($inline) {
if ($rDef.errors) {
if ($rDef.errors != ''full'') {
out += ''  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } '';
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if ('' + ($errs) + '' == errors) { '' + (def_customError) + '' } else {  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } '';
}
}
} else if ($macro) {
out += ''   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if (Array.isArray('' + ($ruleErrs) + '')) { if (vErrors === null) vErrors = '' + ($ruleErrs) + ''; else vErrors = vErrors.concat('' + ($ruleErrs) + ''); errors = vErrors.length;  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '';  '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\";  '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } else { '' + (def_customError) + '' } '';
}
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
}
return out;
}
},{}],30:[function(require,module,exports){
''use strict'';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $schemaDeps = {},
$propertyDeps = {},
$ownProperties = it.opts.ownProperties;
for ($property in $schema) {
var $sch = $schema[$property];
var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
$deps[$property] = $sch;
}
out += ''var '' + ($errs) + '' = errors;'';
var $currentErrorPath = it.errorPath;
out += ''var missing'' + ($lvl) + '';'';
for (var $property in $propertyDeps) {
$deps = $propertyDeps[$property];
if ($deps.length) {
out += '' if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
if ($breakOnError) {
out += '' && ( '';
var arr1 = $deps;
if (arr1) {
var $propertyKey, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$propertyKey = arr1[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '')) {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
out += '' ) { '';
var arr2 = $deps;
if (arr2) {
var $propertyKey, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$propertyKey = arr2[i2 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
out += '' }   '';
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
}
it.errorPath = $currentErrorPath;
var $currentBaseId = $it.baseId;
for (var $property in $schemaDeps) {
var $sch = $schemaDeps[$property];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
out += '') { '';
$it.schema = $sch;
$it.schemaPath = $schemaPath + it.util.getProperty($property);
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($property);
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
if ($breakOnError) {
out += ''   '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],31:[function(require,module,exports){
''use strict'';
module.exports = function generate_enum(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $i = ''i'' + $lvl,
$vSchema = ''schema'' + $lvl;
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '';'';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '''' + ($valid) + '' = false;for (var '' + ($i) + ''=0; '' + ($i) + ''<'' + ($vSchema) + ''.length; '' + ($i) + ''++) if (equal('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + ''])) { '' + ($valid) + '' = true; break; }'';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''enum'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { allowedValues: schema'' + ($lvl) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to one of the allowed values\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],32:[function(require,module,exports){
''use strict'';
module.exports = function generate_format(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
if (it.opts.format === false) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $unknownFormats = it.opts.unknownFormats,
$allowUnknown = Array.isArray($unknownFormats);
if ($isData) {
var $format = ''format'' + $lvl,
$isObject = ''isObject'' + $lvl,
$formatType = ''formatType'' + $lvl;
out += '' var '' + ($format) + '' = formats['' + ($schemaValue) + '']; var '' + ($isObject) + '' = typeof '' + ($format) + '' == \\\\''object\\\\'' && !('' + ($format) + '' instanceof RegExp) && '' + ($format) + ''.validate; var '' + ($formatType) + '' = '' + ($isObject) + '' && '' + ($format) + ''.type || \\\\''string\\\\''; if ('' + ($isObject) + '') { '';
if (it.async) {
out += '' var async'' + ($lvl) + '' = '' + ($format) + ''.async; '';
}
out += '' '' + ($format) + '' = '' + ($format) + ''.validate; } if (  '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' ('';
if ($unknownFormats != ''ignore'') {
out += '' ('' + ($schemaValue) + '' && !'' + ($format) + '' '';
if ($allowUnknown) {
out += '' && self._opts.unknownFormats.indexOf('' + ($schemaValue) + '') == -1 '';
}
out += '') || '';
}
out += '' ('' + ($format) + '' && '' + ($formatType) + '' == \\\\'''' + ($ruleType) + ''\\\\'' && !(typeof '' + ($format) + '' == \\\\''function\\\\'' ? '';
if (it.async) {
out += '' (async'' + ($lvl) + '' ? '' + (it.yieldAwait) + '' '' + ($format) + ''('' + ($data) + '') : '' + ($format) + ''('' + ($data) + '')) '';
} else {
out += '' '' + ($format) + ''('' + ($data) + '') '';
}
out += '' : '' + ($format) + ''.test('' + ($data) + ''))))) {'';
} else {
var $format = it.formats[$schema];
if (!$format) {
if ($unknownFormats == ''ignore'') {
console.warn(''unknown format \\" '' + $schema + '' \\" ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else {
throw new Error(''unknown format \\" '' + $schema + '' \\" is used in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
var $isObject = typeof $format == ''object'' && !($format instanceof RegExp) && $format.validate;
var $formatType = $isObject && $format.type || ''string'';
if ($isObject) {
var $async = $format.async === true;
$format = $format.validate;
}
if ($formatType != $ruleType) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
if ($async) {
if (!it.async) throw new Error(''async format in sync schema'');
var $formatRef = ''formats'' + it.util.getProperty($schema) + ''.validate'';
out += '' if (!('' + (it.yieldAwait) + '' '' + ($formatRef) + ''('' + ($data) + ''))) { '';
} else {
out += '' if (! '';
var $formatRef = ''formats'' + it.util.getProperty($schema);
if ($isObject) $formatRef += ''.validate'';
if (typeof $format == ''function'') {
out += '' '' + ($formatRef) + ''('' + ($data) + '') '';
} else {
out += '' '' + ($formatRef) + ''.test('' + ($data) + '') '';
}
out += '') { '';
}
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''format'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { format:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match format \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],33:[function(require,module,exports){
''use strict'';
module.exports = function generate_items(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId;
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if (Array.isArray($schema)) {
var $additionalItems = it.schema.additionalItems;
if ($additionalItems === false) {
out += '' '' + ($valid) + '' = '' + ($data) + ''.length <= '' + ($schema.length) + ''; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schema.length) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have more than '' + ($schema.length) + '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($i) + '') { '';
var $passData = $data + ''['' + $i + '']'';
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
$it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
$it.dataPathArr[$dataNxt] = $i;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if (typeof $additionalItems == ''object'' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
$it.schema = $additionalItems;
$it.schemaPath = it.schemaPath + ''.additionalItems'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($schema.length) + '') {  for (var '' + ($idx) + '' = '' + ($schema.length) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
} else if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += ''  for (var '' + ($idx) + '' = '' + (0) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],34:[function(require,module,exports){
''use strict'';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
out += ''var division'' + ($lvl) + '';if ('';
if ($isData) {
out += '' '' + ($schemaValue) + '' !== undefined && ( typeof '' + ($schemaValue) + '' != \\\\''number\\\\'' || '';
}
out += '' (division'' + ($lvl) + '' = '' + ($data) + '' / '' + ($schemaValue) + '', '';
if (it.opts.multipleOfPrecision) {
out += '' Math.abs(Math.round(division'' + ($lvl) + '') - division'' + ($lvl) + '') > 1e-'' + (it.opts.multipleOfPrecision) + '' '';
} else {
out += '' division'' + ($lvl) + '' !== parseInt(division'' + ($lvl) + '') '';
}
out += '' ) '';
if ($isData) {
out += ''  )  '';
}
out += '' ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''multipleOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { multipleOf: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be multiple of '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],35:[function(require,module,exports){
''use strict'';
module.exports = function generate_not(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.createErrors = false;
var $allErrorsOption;
if ($it.opts.allErrors) {
$allErrorsOption = $it.opts.allErrors;
$it.opts.allErrors = false;
}
out += '' '' + (it.validate($it)) + '' '';
$it.createErrors = true;
if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if ('' + ($nextValid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
} else {
out += ''  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if ($breakOnError) {
out += '' if (false) { '';
}
}
return out;
}
},{}],36:[function(require,module,exports){
''use strict'';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
out += ''var '' + ($errs) + '' = errors;var prevValid'' + ($lvl) + '' = false;var '' + ($valid) + '' = false;'';
var $currentBaseId = $it.baseId;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
} else {
out += '' var '' + ($nextValid) + '' = true; '';
}
if ($i) {
out += '' if ('' + ($nextValid) + '' && prevValid'' + ($lvl) + '') '' + ($valid) + '' = false; else { '';
$closingBraces += ''}'';
}
out += '' if ('' + ($nextValid) + '') '' + ($valid) + '' = prevValid'' + ($lvl) + '' = true;'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '''' + ($closingBraces) + ''if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''oneOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match exactly one schema in oneOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += ''} else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; }'';
if (it.opts.allErrors) {
out += '' } '';
}
return out;
}
},{}],37:[function(require,module,exports){
''use strict'';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $regexp = $isData ? ''(new RegExp('' + $schemaValue + ''))'' : it.usePattern($schema);
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' !'' + ($regexp) + ''.test('' + ($data) + '') ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''pattern'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { pattern:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match pattern \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],38:[function(require,module,exports){
''use strict'';
module.exports = function generate_properties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl;
var $schemaKeys = Object.keys($schema || {}),
$pProperties = it.schema.patternProperties || {},
$pPropertyKeys = Object.keys($pProperties),
$aProperties = it.schema.additionalProperties,
$someProperties = $schemaKeys.length || $pPropertyKeys.length,
$noAdditional = $aProperties === false,
$additionalIsSchema = typeof $aProperties == ''object'' && Object.keys($aProperties).length,
$removeAdditional = it.opts.removeAdditional,
$checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
var $required = it.schema.required;
if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
if (it.opts.patternGroups) {
var $pgProperties = it.schema.patternGroups || {},
$pgPropertyKeys = Object.keys($pgProperties);
}
out += ''var '' + ($errs) + '' = errors;var '' + ($nextValid) + '' = true;'';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined;'';
}
if ($checkAdditional) {
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
if ($someProperties) {
out += '' var isAdditional'' + ($lvl) + '' = !(false '';
if ($schemaKeys.length) {
if ($schemaKeys.length > 5) {
out += '' || validate.schema'' + ($schemaPath) + ''['' + ($key) + ''] '';
} else {
var arr1 = $schemaKeys;
if (arr1) {
var $propertyKey, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$propertyKey = arr1[i1 += 1];
out += '' || '' + ($key) + '' == '' + (it.util.toQuotedString($propertyKey)) + '' '';
}
}
}
}
if ($pPropertyKeys.length) {
var arr2 = $pPropertyKeys;
if (arr2) {
var $pProperty, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$pProperty = arr2[$i += 1];
out += '' || '' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '') '';
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr3 = $pgPropertyKeys;
if (arr3) {
var $pgProperty, $i = -1,
l3 = arr3.length - 1;
while ($i < l3) {
$pgProperty = arr3[$i += 1];
out += '' || '' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '') '';
}
}
}
out += '' ); if (isAdditional'' + ($lvl) + '') { '';
}
if ($removeAdditional == ''all'') {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
var $currentErrorPath = it.errorPath;
var $additionalProperty = ''\\\\'' + '' + $key + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
}
if ($noAdditional) {
if ($removeAdditional) {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
out += '' '' + ($nextValid) + '' = false; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { additionalProperty: \\\\'''' + ($additionalProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have additional properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' break; '';
}
}
} else if ($additionalIsSchema) {
if ($removeAdditional == ''failing'') {
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if (!'' + ($nextValid) + '') { errors = '' + ($errs) + ''; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete '' + ($data) + ''['' + ($key) + '']; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
} else {
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
}
}
it.errorPath = $currentErrorPath;
}
if ($someProperties) {
out += '' } '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
var $useDefaults = it.opts.useDefaults && !it.compositeRule;
if ($schemaKeys.length) {
var arr4 = $schemaKeys;
if (arr4) {
var $propertyKey, i4 = -1,
l4 = arr4.length - 1;
while (i4 < l4) {
$propertyKey = arr4[i4 += 1];
var $sch = $schema[$propertyKey];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
var $prop = it.util.getProperty($propertyKey),
$passData = $data + $prop,
$hasDefault = $useDefaults && $sch.default !== undefined;
$it.schema = $sch;
$it.schemaPath = $schemaPath + $prop;
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($propertyKey);
$it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
$it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
$code = it.util.varReplace($code, $nextData, $passData);
var $useData = $passData;
} else {
var $useData = $nextData;
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '';
}
if ($hasDefault) {
out += '' '' + ($code) + '' '';
} else {
if ($requiredHash && $requiredHash[$propertyKey]) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = false; '';
var $currentErrorPath = it.errorPath,
$currErrSchemaPath = $errSchemaPath,
$missingProperty = it.util.escapeQuotes($propertyKey);
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
$errSchemaPath = it.errSchemaPath + ''/required'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
it.errorPath = $currentErrorPath;
out += '' } else { '';
} else {
if ($breakOnError) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = true; } else { '';
} else {
out += '' if ('' + ($useData) + '' !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '' ) { '';
}
}
out += '' '' + ($code) + '' } '';
}
}
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($pPropertyKeys.length) {
var arr5 = $pPropertyKeys;
if (arr5) {
var $pProperty, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$pProperty = arr5[i5 += 1];
var $sch = $pProperties[$pProperty];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternProperties'' + it.util.getProperty($pProperty);
$it.errSchemaPath = it.errSchemaPath + ''/patternProperties/'' + it.util.escapeFragment($pProperty);
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '')) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr6 = $pgPropertyKeys;
if (arr6) {
var $pgProperty, i6 = -1,
l6 = arr6.length - 1;
while (i6 < l6) {
$pgProperty = arr6[i6 += 1];
var $pgSchema = $pgProperties[$pgProperty],
$sch = $pgSchema.schema;
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternGroups'' + it.util.getProperty($pgProperty) + ''.schema'';
$it.errSchemaPath = it.errSchemaPath + ''/patternGroups/'' + it.util.escapeFragment($pgProperty) + ''/schema'';
out += '' var pgPropCount'' + ($lvl) + '' = 0;  '';
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '')) { pgPropCount'' + ($lvl) + ''++; '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
var $pgMin = $pgSchema.minimum,
$pgMax = $pgSchema.maximum;
if ($pgMin !== undefined || $pgMax !== undefined) {
out += '' var '' + ($valid) + '' = true; '';
var $currErrSchemaPath = $errSchemaPath;
if ($pgMin !== undefined) {
var $limit = $pgMin,
$reason = ''minimum'',
$moreOrLess = ''less'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' >= '' + ($pgMin) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/minimum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($pgMax !== undefined) {
out += '' else '';
}
}
if ($pgMax !== undefined) {
var $limit = $pgMax,
$reason = ''maximum'',
$moreOrLess = ''more'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' <= '' + ($pgMax) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/maximum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],39:[function(require,module,exports){
''use strict'';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$i = ''i'' + $lvl,
$invalidName = ''\\\\'' + '' + $key + '' + \\\\'''',
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
out += '' var '' + ($errs) + '' = errors; '';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined; '';
}
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' var startErrs'' + ($lvl) + '' = errors; '';
var $passData = $key;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if (!'' + ($nextValid) + '') { for (var '' + ($i) + ''=startErrs'' + ($lvl) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { vErrors['' + ($i) + ''].propertyName = '' + ($key) + ''; }   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''propertyNames'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { propertyName: \\\\'''' + ($invalidName) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''property name \\\\\\\\\\\\'''' + ($invalidName) + ''\\\\\\\\\\\\'' is invalid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
if ($breakOnError) {
out += '' break; '';
}
out += '' } }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],40:[function(require,module,exports){
''use strict'';
module.exports = function generate_ref(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $async, $refCode;
if ($schema == ''#'' || $schema == ''#/'') {
if (it.isRoot) {
$async = it.async;
$refCode = ''validate'';
} else {
$async = it.root.schema.$async === true;
$refCode = ''root.refVal[0]'';
}
} else {
var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
if ($refVal === undefined) {
var $message = it.MissingRefError.message(it.baseId, $schema);
if (it.opts.missingRefs == ''fail'') {
console.error($message);
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''$ref'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { ref: \\\\'''' + (it.util.escapeQuotes($schema)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''can\\\\\\\\\\\\''t resolve reference '' + (it.util.escapeQuotes($schema)) + ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: '' + (it.util.toQuotedString($schema)) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
if ($breakOnError) {
out += '' if (false) { '';
}
} else if (it.opts.missingRefs == ''ignore'') {
console.warn($message);
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
throw new it.MissingRefError(it.baseId, $schema, $message);
}
} else if ($refVal.inline) {
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $refVal.schema;
$it.schemaPath = '''';
$it.errSchemaPath = $schema;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $refVal.code);
out += '' '' + ($code) + '' '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
}
} else {
$async = $refVal.$async === true;
$refCode = $refVal.code;
}
}
if ($refCode) {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
if (it.opts.passContext) {
out += '' '' + ($refCode) + ''.call(this, '';
} else {
out += '' '' + ($refCode) + ''( '';
}
out += '' '' + ($data) + '', (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '', rootData)  '';
var __callValidate = out;
out = $$outStack.pop();
if ($async) {
if (!it.async) throw new Error(''async schema referenced by sync schema'');
if ($breakOnError) {
out += '' var '' + ($valid) + ''; '';
}
out += '' try { '' + (it.yieldAwait) + '' '' + (__callValidate) + ''; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = true; '';
}
out += '' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = false; '';
}
out += '' } '';
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
}
} else {
out += '' if (!'' + (__callValidate) + '') { if (vErrors === null) vErrors = '' + ($refCode) + ''.errors; else vErrors = vErrors.concat('' + ($refCode) + ''.errors); errors = vErrors.length; } '';
if ($breakOnError) {
out += '' else { '';
}
}
}
return out;
}
},{}],41:[function(require,module,exports){
''use strict'';
module.exports = function generate_required(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $vSchema = ''schema'' + $lvl;
if (!$isData) {
if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
var $required = [];
var arr1 = $schema;
if (arr1) {
var $property, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$property = arr1[i1 += 1];
var $propertySch = it.schema.properties[$property];
if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
$required[$required.length] = $property;
}
}
}
} else {
var $required = $schema;
}
}
if ($isData || $required.length) {
var $currentErrorPath = it.errorPath,
$loopRequired = $isData || $required.length >= it.opts.loopRequired,
$ownProperties = it.opts.ownProperties;
if ($breakOnError) {
out += '' var missing'' + ($lvl) + ''; '';
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
out += '' var '' + ($valid) + '' = true; '';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { '' + ($valid) + '' = '' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += ''; if (!'' + ($valid) + '') break; } '';
if ($isData) {
out += ''  }  '';
}
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
} else {
out += '' if ( '';
var arr2 = $required;
if (arr2) {
var $propertyKey, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$propertyKey = arr2[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '') {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
}
} else {
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
if ($isData) {
out += '' if ('' + ($vSchema) + '' && !Array.isArray('' + ($vSchema) + '')) {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ('' + ($vSchema) + '' !== undefined) { '';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { if ('' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } '';
if ($isData) {
out += ''  }  '';
}
} else {
var arr3 = $required;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
}
it.errorPath = $currentErrorPath;
} else if ($breakOnError) {
out += '' if (true) {'';
}
return out;
}
},{}],42:[function(require,module,exports){
''use strict'';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (($schema || $isData) && it.opts.uniqueItems !== false) {
if ($isData) {
out += '' var '' + ($valid) + ''; if ('' + ($schemaValue) + '' === false || '' + ($schemaValue) + '' === undefined) '' + ($valid) + '' = true; else if (typeof '' + ($schemaValue) + '' != \\\\''boolean\\\\'') '' + ($valid) + '' = false; else { '';
}
out += '' var '' + ($valid) + '' = true; if ('' + ($data) + ''.length > 1) { var i = '' + ($data) + ''.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal('' + ($data) + ''[i], '' + ($data) + ''[j])) { '' + ($valid) + '' = false; break outer; } } } } '';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''uniqueItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { i: i, j: j } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have duplicate items (items ## \\\\'' + j + \\\\'' and \\\\'' + i + \\\\'' are identical)\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],43:[function(require,module,exports){
''use strict'';
module.exports = function generate_validate(it, $keyword, $ruleType) {
var out = '''';
var $async = it.schema.$async === true,
$refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, ''$ref''),
$id = it.self._getId(it.schema);
if (it.isTop) {
if ($async) {
it.async = true;
var $es7 = it.opts.async == ''es7'';
it.yieldAwait = $es7 ? ''await'' : ''yield'';
}
out += '' var validate = '';
if ($async) {
if ($es7) {
out += '' (async function '';
} else {
if (it.opts.async != ''*'') {
out += ''co.wrap'';
}
out += ''(function* '';
}
} else {
out += '' (function '';
}
out += '' (data, dataPath, parentData, parentDataProperty, rootData) { \\\\''use strict\\\\''; '';
if ($id && (it.opts.sourceCode || it.opts.processCode)) {
out += '' '' + (''/\\\\*# sourceURL='' + $id + '' */'') + '' '';
}
}
if (typeof it.schema == ''boolean'' || !($refKeywords || it.schema.$ref)) {
var $keyword = ''false schema'';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
if (it.schema === false) {
if (it.isTop) {
$breakOnError = true;
} else {
out += '' var '' + ($valid) + '' = false; '';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''false schema'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''boolean schema is false\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
if (it.isTop) {
if ($async) {
out += '' return data; '';
} else {
out += '' validate.errors = null; return true; '';
}
} else {
out += '' var '' + ($valid) + '' = true; '';
}
}
if (it.isTop) {
out += '' }); return validate; '';
}
return out;
}
if (it.isTop) {
var $top = it.isTop,
$lvl = it.level = 0,
$dataLvl = it.dataLevel = 0,
$data = ''data'';
it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
it.baseId = it.baseId || it.rootId;
delete it.isTop;
it.dataPathArr = [undefined];
out += '' var vErrors = null; '';
out += '' var errors = 0;     '';
out += '' if (rootData === undefined) rootData = data; '';
} else {
var $lvl = it.level,
$dataLvl = it.dataLevel,
$data = ''data'' + ($dataLvl || '''');
if ($id) it.baseId = it.resolve.url(it.baseId, $id);
if ($async && !it.async) throw new Error(''async schema in sync schema'');
out += '' var errs_'' + ($lvl) + '' = errors;'';
}
var $valid = ''valid'' + $lvl,
$breakOnError = !it.opts.allErrors,
$closingBraces1 = '''',
$closingBraces2 = '''';
var $errorKeyword;
var $typeSchema = it.schema.type,
$typeIsArray = Array.isArray($typeSchema);
if ($typeIsArray && $typeSchema.length == 1) {
$typeSchema = $typeSchema[0];
$typeIsArray = false;
}
if (it.schema.$ref && $refKeywords) {
if (it.opts.extendRefs == ''fail'') {
throw new Error(''$ref: validation keywords used in schema at path \\" '' + it.errSchemaPath + '' \\" (see option extendRefs)'');
} else if (it.opts.extendRefs !== true) {
$refKeywords = false;
console.warn(''$ref: keywords ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
if ($typeSchema) {
if (it.opts.coerceTypes) {
var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
}
var $rulesGroup = it.RULES.types[$typeSchema];
if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'',
$method = $typeIsArray ? ''checkDataTypes'' : ''checkDataType'';
out += '' if ('' + (it.util[$method]($typeSchema, $data, true)) + '') { '';
if ($coerceToTypes) {
var $dataType = ''dataType'' + $lvl,
$coerced = ''coerced'' + $lvl;
out += '' var '' + ($dataType) + '' = typeof '' + ($data) + ''; '';
if (it.opts.coerceTypes == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''object\\\\'' && Array.isArray('' + ($data) + '')) '' + ($dataType) + '' = \\\\''array\\\\''; '';
}
out += '' var '' + ($coerced) + '' = undefined; '';
var $bracesCoercion = '''';
var arr1 = $coerceToTypes;
if (arr1) {
var $type, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$type = arr1[$i += 1];
if ($i) {
out += '' if ('' + ($coerced) + '' === undefined) { '';
$bracesCoercion += ''}'';
}
if (it.opts.coerceTypes == ''array'' && $type != ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''array\\\\'' && '' + ($data) + ''.length == 1) { '' + ($coerced) + '' = '' + ($data) + '' = '' + ($data) + ''[0]; '' + ($dataType) + '' = typeof '' + ($data) + '';  } '';
}
if ($type == ''string'') {
out += '' if ('' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'') '' + ($coerced) + '' = \\\\''\\\\'' + '' + ($data) + ''; else if ('' + ($data) + '' === null) '' + ($coerced) + '' = \\\\''\\\\''; '';
} else if ($type == ''number'' || $type == ''integer'') {
out += '' if ('' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' === null || ('' + ($dataType) + '' == \\\\''string\\\\'' && '' + ($data) + '' && '' + ($data) + '' == +'' + ($data) + '' '';
if ($type == ''integer'') {
out += '' && !('' + ($data) + '' % 1)'';
}
out += '')) '' + ($coerced) + '' = +'' + ($data) + ''; '';
} else if ($type == ''boolean'') {
out += '' if ('' + ($data) + '' === \\\\''false\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === null) '' + ($coerced) + '' = false; else if ('' + ($data) + '' === \\\\''true\\\\'' || '' + ($data) + '' === 1) '' + ($coerced) + '' = true; '';
} else if ($type == ''null'') {
out += '' if ('' + ($data) + '' === \\\\''\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === false) '' + ($coerced) + '' = null; '';
} else if (it.opts.coerceTypes == ''array'' && $type == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''string\\\\'' || '' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' == null) '' + ($coerced) + '' = ['' + ($data) + '']; '';
}
}
}
out += '' '' + ($bracesCoercion) + '' if ('' + ($coerced) + '' === undefined) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  '';
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' '' + ($data) + '' = '' + ($coerced) + ''; '';
if (!$dataLvl) {
out += ''if ('' + ($parentData) + '' !== undefined)'';
}
out += '' '' + ($parentData) + ''['' + ($parentDataProperty) + ''] = '' + ($coerced) + ''; } '';
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
}
out += '' } '';
}
}
if (it.schema.$ref && !$refKeywords) {
out += '' '' + (it.RULES.all.$ref.code(it, ''$ref'')) + '' '';
if ($breakOnError) {
out += '' } if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
} else {
if (it.opts.v5 && it.schema.patternGroups) {
console.warn(''keyword \\" patternGroups \\" is deprecated and disabled. Use option patternGroups: true to enable.'');
}
var arr2 = it.RULES;
if (arr2) {
var $rulesGroup, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$rulesGroup = arr2[i2 += 1];
if ($shouldUseGroup($rulesGroup)) {
if ($rulesGroup.type) {
out += '' if ('' + (it.util.checkDataType($rulesGroup.type, $data)) + '') { '';
}
if (it.opts.useDefaults && !it.compositeRule) {
if ($rulesGroup.type == ''object'' && it.schema.properties) {
var $schema = it.schema.properties,
$schemaKeys = Object.keys($schema);
var arr3 = $schemaKeys;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $sch = $schema[$propertyKey];
if ($sch.default !== undefined) {
var $passData = $data + it.util.getProperty($propertyKey);
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
} else if ($rulesGroup.type == ''array'' && Array.isArray(it.schema.items)) {
var arr4 = it.schema.items;
if (arr4) {
var $sch, $i = -1,
l4 = arr4.length - 1;
while ($i < l4) {
$sch = arr4[$i += 1];
if ($sch.default !== undefined) {
var $passData = $data + ''['' + $i + '']'';
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
}
}
var arr5 = $rulesGroup.rules;
if (arr5) {
var $rule, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$rule = arr5[i5 += 1];
if ($shouldUseRule($rule)) {
var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
if ($code) {
out += '' '' + ($code) + '' '';
if ($breakOnError) {
$closingBraces1 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces1) + '' '';
$closingBraces1 = '''';
}
if ($rulesGroup.type) {
out += '' } '';
if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
out += '' else { '';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
}
if ($breakOnError) {
out += '' if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces2) + '' '';
}
if ($top) {
if ($async) {
out += '' if (errors === 0) return data;           '';
out += '' else throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; '';
out += '' return errors === 0;       '';
}
out += '' }); return validate;'';
} else {
out += '' var '' + ($valid) + '' = errors === errs_'' + ($lvl) + '';'';
}
out = it.util.cleanUpCode(out);
if ($top) {
out = it.util.finalCleanUpCode(out, $async);
}
function $shouldUseGroup($rulesGroup) {
var rules = $rulesGroup.rules;
for (var i = 0; i < rules.length; i++)
if ($shouldUseRule(rules[i])) return true;
}
function $shouldUseRule($rule) {
return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImlementsSomeKeyword($rule));
}
function $ruleImlementsSomeKeyword($rule) {
var impl = $rule.implements;
for (var i = 0; i < impl.length; i++)
if (it.schema[impl[i]] !== undefined) return true;
}
return out;
}
},{}],44:[function(require,module,exports){
''use strict'';
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require(''./dotjs/custom'');
module.exports = {
add: addKeyword,
get: getKeyword,
remove: removeKeyword
};
/**
* Define custom keyword
* @this  Ajv
* @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
* @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
*/
function addKeyword(keyword, definition) {
/* jshint validthis: true */
/* eslint no-shadow: 0 */
var RULES = this.RULES;
if (RULES.keywords[keyword])
throw new Error(''Keyword '' + keyword + '' is already defined'');
if (!IDENTIFIER.test(keyword))
throw new Error(''Keyword '' + keyword + '' is not a valid identifier'');
if (definition) {
if (definition.macro && definition.valid !== undefined)
throw new Error(''\\" valid \\" option cannot be used with macro keywords'');
var dataType = definition.type;
if (Array.isArray(dataType)) {
var i, len = dataType.length;
for (i=0; i<len; i++) checkDataType(dataType[i]);
for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
} else {
if (dataType) checkDataType(dataType);
_addRule(keyword, dataType, definition);
}
var $data = definition.$data === true && this._opts.$data;
if ($data && !definition.validate)
throw new Error(''$data support: \\" validate \\" function is not defined'');
var metaSchema = definition.metaSchema;
if (metaSchema) {
if ($data) {
metaSchema = {
anyOf: [
metaSchema,
{ ''$ref'': ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
definition.validateSchema = this.compile(metaSchema, true);
}
}
RULES.keywords[keyword] = RULES.all[keyword] = true;
function _addRule(keyword, dataType, definition) {
var ruleGroup;
for (var i=0; i<RULES.length; i++) {
var rg = RULES[i];
if (rg.type == dataType) {
ruleGroup = rg;
break;
}
}
if (!ruleGroup) {
ruleGroup = { type: dataType, rules: [] };
RULES.push(ruleGroup);
}
var rule = {
keyword: keyword,
definition: definition,
custom: true,
code: customRuleCode,
implements: definition.implements
};
ruleGroup.rules.push(rule);
RULES.custom[keyword] = rule;
}
function checkDataType(dataType) {
if (!RULES.types[dataType]) throw new Error(''Unknown type '' + dataType);
}
}
/**
* Get keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
* @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
*/
function getKeyword(keyword) {
/* jshint validthis: true */
var rule = this.RULES.custom[keyword];
return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
* Remove keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
*/
function removeKeyword(keyword) {
/* jshint validthis: true */
var RULES = this.RULES;
delete RULES.keywords[keyword];
delete RULES.all[keyword];
delete RULES.custom[keyword];
for (var i=0; i<RULES.length; i++) {
var rules = RULES[i].rules;
for (var j=0; j<rules.length; j++) {
if (rules[j].keyword == keyword) {
rules.splice(j, 1);
break;
}
}
}
}
},{\\"./ dotjs / custom \\":29}],45:[function(require,module,exports){
''use strict'';
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
module.exports = function (ajv) {
var defaultMeta = ajv._opts.defaultMeta;
var metaSchemaRef = typeof defaultMeta == ''string''
? { $ref: defaultMeta }
: ajv.getSchema(META_SCHEMA_ID)
? { $ref: META_SCHEMA_ID }
: {};
ajv.addKeyword(''patternGroups'', {
// implemented in properties.jst
metaSchema: {
type: ''object'',
additionalProperties: {
type: ''object'',
required: [ ''schema'' ],
properties: {
maximum: {
type: ''integer'',
minimum: 0
},
minimum: {
type: ''integer'',
minimum: 0
},
schema: metaSchemaRef
},
additionalProperties: false
}
}
});
ajv.RULES.all.properties.implements.push(''patternGroups'');
};
},{}],46:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" https: / / raw.githubusercontent.com / epoberezkin / ajv / master / lib / refs / $ data.json # \\",
\\" description \\": \\" Meta - SCHEMA FOR $ data reference (json - SCHEMA EXTENSION proposal) \\",
\\" TYPE \\": \\" object \\",
\\" required \\": [ \\" $ data \\" ],
\\" properties \\": {
\\" $ data \\": {
\\" TYPE \\": \\" string \\",
\\" anyOf \\": [
{ \\" format \\": \\" relative - json - pointer \\" },
{ \\" format \\": \\" json - pointer \\" }
]
}
},
\\" additionalProperties \\": false
}
},{}],47:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" title \\": \\" Core SCHEMA meta - SCHEMA \\",
\\" definitions \\": {
\\" schemaArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" items \\": { \\" $ ref \\": \\" # \\" }
},
\\" nonNegativeInteger \\": {
\\" TYPE \\": \\" integer \\",
\\" minimum \\": 0
},
\\" nonNegativeIntegerDefault0 \\": {
\\" allOf \\": [
{ \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
{ \\" DEFAULT \\": 0 }
]
},
\\" simpleTypes \\": {
\\" enum \\": [
\\" ARRAY \\",
\\" boolean \\",
\\" integer \\",
\\" NULL \\",
\\" number \\",
\\" object \\",
\\" string \\"
]
},
\\" stringArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" TYPE \\": \\" string \\" },
\\" uniqueItems \\": true,
\\" DEFAULT \\": []
}
},
\\" TYPE \\": [\\" object \\", \\" boolean \\"],
\\" properties \\": {
\\" $ id \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" $ SCHEMA \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri \\"
},
\\" $ ref \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" title \\": {
\\" TYPE \\": \\" string \\"
},
\\" description \\": {
\\" TYPE \\": \\" string \\"
},
\\" DEFAULT \\": {},
\\" multipleOf \\": {
\\" TYPE \\": \\" number \\",
\\" exclusiveMinimum \\": 0
},
\\" maximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMaximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" minimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMinimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" maxLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" pattern \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" regex \\"
},
\\" additionalItems \\": { \\" $ ref \\": \\" # \\" },
\\" items \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / schemaArray \\" }
],
\\" DEFAULT \\": {}
},
\\" maxItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" uniqueItems \\": {
\\" TYPE \\": \\" boolean \\",
\\" DEFAULT \\": false
},
\\" contains \\": { \\" $ ref \\": \\" # \\" },
\\" maxProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" required \\": { \\" $ ref \\": \\" # / definitions / stringArray \\" },
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" definitions \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" properties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" patternProperties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" dependencies \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / stringArray \\" }
]
}
},
\\" propertyNames \\": { \\" $ ref \\": \\" # \\" },
\\" const \\": {},
\\" enum \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" uniqueItems \\": true
},
\\" TYPE \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
{
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
\\" minItems \\": 1,
\\" uniqueItems \\": true
}
]
},
\\" format \\": { \\" TYPE \\": \\" string \\" },
\\" allOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" anyOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" oneOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" NOT \\": { \\" $ ref \\": \\" # \\" }
},
\\" DEFAULT \\": {}
}
},{}],48:[function(require,module,exports){
/**
* slice() reference.
*/
var slice = Array.prototype.slice;
/**
* Expose \`co\`.
*/
module.exports = co[''default''] = co.co = co;
/**
* Wrap the given generator \`fn\` into a
* function that returns a promise.
* This is a separate function so that
* every \`co()\` call doesn''t create a new,
* unnecessary closure.
*
* @param {GeneratorFunction} fn
* @return {Function}
* @api public
*/
co.wrap = function (fn) {
createPromise.__generatorFunction__ = fn;
return createPromise;
function createPromise() {
return co.call(this, fn.apply(this, arguments));
}
};
/**
* Execute the generator function or a generator
* and return a promise.
*
* @param {Function} fn
* @return {Promise}
* @api public
*/
function co(gen) {
var ctx = this;
var args = slice.call(arguments, 1)
// we wrap everything in a promise to avoid promise chaining,
// which leads to memory leak errors.
// see https://github.com/tj/co/issues/180
return new Promise(function(resolve, reject) {
if (typeof gen === ''function'') gen = gen.apply(ctx, args);
if (!gen || typeof gen.next !== ''function'') return resolve(gen);
onFulfilled();
/**
* @param {Mixed} res
* @return {Promise}
* @api private
*/
function onFulfilled(res) {
var ret;
try {
ret = gen.next(res);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* @param {Error} err
* @return {Promise}
* @api private
*/
function onRejected(err) {
var ret;
try {
ret = gen.throw(err);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* Get the next value in the generator,
* return a promise.
*
* @param {Object} ret
* @return {Promise}
* @api private
*/
function next(ret) {
if (ret.done) return resolve(ret.value);
var value = toPromise.call(ctx, ret.value);
if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
return onRejected(new TypeError(''You may only yield a function, promise, generator, array, or object, ''
+ ''but the following object was passed: \\" '' + String(ret.value) + '' \\"''));
}
});
}
/**
* Convert a \`yield\`ed value into a promise.
*
* @param {Mixed} obj
* @return {Promise}
* @api private
*/
function toPromise(obj) {
if (!obj) return obj;
if (isPromise(obj)) return obj;
if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
if (''function'' == typeof obj) return thunkToPromise.call(this, obj);
if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
if (isObject(obj)) return objectToPromise.call(this, obj);
return obj;
}
/**
* Convert a thunk to a promise.
*
* @param {Function}
* @return {Promise}
* @api private
*/
function thunkToPromise(fn) {
var ctx = this;
return new Promise(function (resolve, reject) {
fn.call(ctx, function (err, res) {
if (err) return reject(err);
if (arguments.length > 2) res = slice.call(arguments, 1);
resolve(res);
});
});
}
/**
* Convert an array of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Array} obj
* @return {Promise}
* @api private
*/
function arrayToPromise(obj) {
return Promise.all(obj.map(toPromise, this));
}
/**
* Convert an object of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Object} obj
* @return {Promise}
* @api private
*/
function objectToPromise(obj){
var results = new obj.constructor();
var keys = Object.keys(obj);
var promises = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var promise = toPromise.call(this, obj[key]);
if (promise && isPromise(promise)) defer(promise, key);
else results[key] = obj[key];
}
return Promise.all(promises).then(function () {
return results;
});
function defer(promise, key) {
// predefine the key in the result
results[key] = undefined;
promises.push(promise.then(function (res) {
results[key] = res;
}));
}
}
/**
* Check if \`obj\` is a promise.
*
* @param {Object} obj
* @return {Boolean}
* @api private
*/
function isPromise(obj) {
return ''function'' == typeof obj.then;
}
/**
* Check if \`obj\` is a generator.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGenerator(obj) {
return ''function'' == typeof obj.next && ''function'' == typeof obj.throw;
}
/**
* Check if \`obj\` is a generator function.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGeneratorFunction(obj) {
var constructor = obj.constructor;
if (!constructor) return false;
if (''GeneratorFunction'' === constructor.name || ''GeneratorFunction'' === constructor.displayName) return true;
return isGenerator(constructor.prototype);
}
/**
* Check for plain object.
*
* @param {Mixed} val
* @return {Boolean}
* @api private
*/
function isObject(val) {
return Object == val.constructor;
}
},{}],49:[function(require,module,exports){
''use strict'';
module.exports = function equal(a, b) {
if (a === b) return true;
var arrA = Array.isArray(a)
, arrB = Array.isArray(b)
, i;
if (arrA && arrB) {
if (a.length != b.length) return false;
for (i = 0; i < a.length; i++)
if (!equal(a[i], b[i])) return false;
return true;
}
if (arrA != arrB) return false;
if (a && b && typeof a === ''object'' && typeof b === ''object'') {
var keys = Object.keys(a);
if (keys.length !== Object.keys(b).length) return false;
var dateA = a instanceof Date
, dateB = b instanceof Date;
if (dateA && dateB) return a.getTime() == b.getTime();
if (dateA != dateB) return false;
var regexpA = a instanceof RegExp
, regexpB = b instanceof RegExp;
if (regexpA && regexpB) return a.toString() == b.toString();
if (regexpA != regexpB) return false;
for (i = 0; i < keys.length; i++)
if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
for (i = 0; i < keys.length; i++)
if(!equal(a[keys[i]], b[keys[i]])) return false;
return true;
}
return false;
};
},{}],50:[function(require,module,exports){
''use strict'';
var traverse = module.exports = function (schema, opts, cb) {
if (typeof opts == ''function'') {
cb = opts;
opts = {};
}
_traverse(opts, cb, schema, '''', schema);
};
traverse.keywords = {
additionalItems: true,
items: true,
contains: true,
additionalProperties: true,
propertyNames: true,
not: true
};
traverse.arrayKeywords = {
items: true,
allOf: true,
anyOf: true,
oneOf: true
};
traverse.propsKeywords = {
definitions: true,
properties: true,
patternProperties: true,
dependencies: true
};
traverse.skipKeywords = {
enum: true,
const: true,
required: true,
maximum: true,
minimum: true,
exclusiveMaximum: true,
exclusiveMinimum: true,
multipleOf: true,
maxLength: true,
minLength: true,
pattern: true,
format: true,
maxItems: true,
minItems: true,
uniqueItems: true,
maxProperties: true,
minProperties: true
};
function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (schema && typeof schema == ''object'' && !Array.isArray(schema)) {
cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
for (var key in schema) {
var sch = schema[key];
if (Array.isArray(sch)) {
if (key in traverse.arrayKeywords) {
for (var i=0; i<sch.length; i++)
_traverse(opts, cb, sch[i], jsonPtr + ''/'' + key + ''/'' + i, rootSchema, jsonPtr, key, schema, i);
}
} else if (key in traverse.propsKeywords) {
if (sch && typeof sch == ''object'') {
for (var prop in sch)
_traverse(opts, cb, sch[prop], jsonPtr + ''/'' + key + ''/'' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
}
} else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
_traverse(opts, cb, sch, jsonPtr + ''/'' + key, rootSchema, jsonPtr, key, schema);
}
}
}
}
function escapeJsonPtr(str) {
return str.replace(/~/g, ''~0'').replace(/\\\\//g, ''~1'');
}
},{}],51:[function(require,module,exports){
var json = typeof JSON !== ''undefined'' ? JSON : require(''jsonify'');
module.exports = function (obj, opts) {
if (!opts) opts = {};
if (typeof opts === ''function'') opts = { cmp: opts };
var space = opts.space || '''';
if (typeof space === ''number'') space = Array(space+1).join('' '');
var cycles = (typeof opts.cycles === ''boolean'') ? opts.cycles : false;
var replacer = opts.replacer || function(key, value) { return value; };
var cmp = opts.cmp && (function (f) {
return function (node) {
return function (a, b) {
var aobj = { key: a, value: node[a] };
var bobj = { key: b, value: node[b] };
return f(aobj, bobj);
};
};
})(opts.cmp);
var seen = [];
return (function stringify (parent, key, node, level) {
var indent = space ? (''\\\\n'' + new Array(level + 1).join(space)) : '''';
var colonSeparator = space ? '': '' : '':'';
if (node && node.toJSON && typeof node.toJSON === ''function'') {
node = node.toJSON();
}
node = replacer.call(parent, key, node);
if (node === undefined) {
return;
}
if (typeof node !== ''object'' || node === null) {
return json.stringify(node);
}
if (isArray(node)) {
var out = [];
for (var i = 0; i < node.length; i++) {
var item = stringify(node, i, node[i], level+1) || json.stringify(null);
out.push(indent + space + item);
}
return ''['' + out.join('','') + indent + '']'';
}
else {
if (seen.indexOf(node) !== -1) {
if (cycles) return json.stringify(''__cycle__'');
throw new TypeError(''Converting circular structure to JSON'');
}
else seen.push(node);
var keys = objectKeys(node).sort(cmp && cmp(node));
var out = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var value = stringify(node, key, node[key], level+1);
if(!value) continue;
var keyValue = json.stringify(key)
+ colonSeparator
+ value;
;
out.push(indent + space + keyValue);
}
seen.splice(seen.indexOf(node), 1);
return ''{'' + out.join('','') + indent + ''}'';
}
})({ '''': obj }, '''', obj, 0);
};
var isArray = Array.isArray || function (x) {
return {}.toString.call(x) === ''[object Array]'';
};
var objectKeys = Object.keys || function (obj) {
var has = Object.prototype.hasOwnProperty || function () { return true };
var keys = [];
for (var key in obj) {
if (has.call(obj, key)) keys.push(key);
}
return keys;
};
},{\\" jsonify \\":52}],52:[function(require,module,exports){
exports.parse = require(''./lib/parse'');
exports.stringify = require(''./lib/stringify'');
},{\\"./ lib / parse \\":53,\\"./ lib / stringify \\":54}],53:[function(require,module,exports){
var at, // The index of the current character
ch, // The current character
escapee = {
''\\" '':  '' \\"'',
''\\\\\\\\'': ''\\\\\\\\'',
''/'':  ''/'',
b:    ''\\\\b'',
f:    ''\\\\f'',
n:    ''\\\\n'',
r:    ''\\\\r'',
t:    ''\\\\t''
},
text,
error = function (m) {
// Call error when something is wrong.
throw {
name:    ''SyntaxError'',
message: m,
at:      at,
text:    text
};
},
next = function (c) {
// If a c parameter is provided, verify that it matches the current character.
if (c && c !== ch) {
error(\\" Expected ''\\" + c + \\"'' INSTEAD OF ''\\" + ch + \\"'' \\");
}
// Get the next character. When there are no more characters,
// return the empty string.
ch = text.charAt(at);
at += 1;
return ch;
},
number = function () {
// Parse a number value.
var number,
string = '''';
if (ch === ''-'') {
string = ''-'';
next(''-'');
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
if (ch === ''.'') {
string += ''.'';
while (next() && ch >= ''0'' && ch <= ''9'') {
string += ch;
}
}
if (ch === ''e'' || ch === ''E'') {
string += ch;
next();
if (ch === ''-'' || ch === ''+'') {
string += ch;
next();
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
}
number = +string;
if (!isFinite(number)) {
error(\\" Bad number \\");
} else {
return number;
}
},
string = function () {
// Parse a string value.
var hex,
i,
string = '''',
uffff;
// When parsing for string values, we must look for \\" AND characters. IF (ch == = ''\\"'') { while (NEXT ()) { IF (ch == = ''\\"'') { NEXT (); RETURN string; }
ELSE
IF (ch == = ''\\\\\\\\'') { NEXT (); IF (ch == = ''u'') { uffff = 0; FOR (i = 0; i < 4; i + = 1) { hex = parseInt (NEXT (), 16); IF (! isFinite(hex)) { break; } uffff = uffff * 16 + hex; } string + = String.fromCharCode (uffff); }
ELSE
IF (typeof escapee[ch] == = ''string'') { string + = escapee[ch]; }
ELSE
{ break; } }
ELSE
{ string + = ch; } } } error (\\"Bad string\\"); }, white = FUNCTION () { / / SKIP whitespace. while (ch && ch <= '' '') { NEXT (); } }, word = FUNCTION () { / / TRUE, FALSE, OR null. switch (ch) { CASE ''t'' : NEXT (''t''); NEXT (''r''); NEXT (''u''); NEXT (''e''); RETURN TRUE; CASE ''f'' : NEXT (''f''); NEXT (''a''); NEXT (''l''); NEXT (''s''); NEXT (''e''); RETURN FALSE; CASE ''n'' : NEXT (''n''); NEXT (''u''); NEXT (''l''); NEXT (''l''); RETURN NULL; } error (\\"Unexpected ''\\" + ch + \\"''\\"); }, value, / / Place holder FOR the value function. ARRAY = FUNCTION () { / / Parse an ARRAY value. var ARRAY =[]; IF (ch == = ''['') { NEXT (''[''); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; / / empty ARRAY } while (ch) { array.push (value ()); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; } NEXT ('',''); white (); } } error (\\"Bad array\\"); }, object = FUNCTION () { / / Parse an object value. var KEY, object = {}; IF (ch == = ''{'') { NEXT (''{''); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; / / empty object } while (ch) { KEY = string (); white (); NEXT ('':''); IF (Object.hasOwnProperty.call (object, KEY)) { error (''Duplicate key \\"'' + KEY + ''\\"''); } object[KEY] = value (); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; } NEXT ('',''); white (); } } error (\\"Bad object\\"); }; value = FUNCTION () { / / Parse a json value. It could be an object, an ARRAY, a string, a number, / / OR a word. white (); switch (ch) { CASE ''{'' : RETURN object (); CASE ''['' : RETURN ARRAY (); CASE ''\\"'' : RETURN string (); CASE ''-'' : RETURN number (); default: RETURN ch >= ''0'' && ch <= ''9'' ? number () : word (); } }; / / RETURN the json_parse function. It will have access TO ALL OF the above / / functions AND variables. module.exports = FUNCTION (source, reviver) { var result; text = source; at = 0; ch = '' ''; result = value (); white (); IF (ch) { error (\\"Syntax error\\"); } / / IF there IS a reviver FUNCTION, we recursively walk the new structure, / / passing EACH name / value pair TO the reviver FUNCTION FOR possible / / transformation, starting WITH a TEMPORARY root object that holds the result / / IN an empty key. IF there IS NOT a reviver FUNCTION, we simply RETURN the / / result. RETURN typeof reviver == = ''function'' ? (
FUNCTION walk (
holder, KEY
) { var k, v, value = holder[KEY]; IF (
value && typeof value == = ''object''
) { FOR (
k IN value
) { IF (
Object.prototype.hasOwnProperty.call (
value, k
)
) { v = walk (
value, k
); IF (
v != = undefined
) { value[k] = v; }
ELSE
{ DELETE value[k]; } } } } RETURN reviver.call (
holder, KEY, value
); }({'''' : result }, '''')) : result; }; }, {}], 54:[FUNCTION (require, module, exports) { var cx = /[u0000 u00ad u0600 - u0604 u070f u17b4 u17b5 u200c - u200f u2028 - u202f u2060 - u206f ufeff ufff0 - uffff] / g, escapable = /[\\\\\\\\ \\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,
gap,
indent,
meta = {    // table of character substitutions
''\\\\b'': ''\\\\\\\\b'',
''\\\\t'': ''\\\\\\\\t'',
''\\\\n'': ''\\\\\\\\n'',
''\\\\f'': ''\\\\\\\\f'',
''\\\\r'': ''\\\\\\\\r'',
''\\" '' : '' \\\\\\\\ \\"'',
''\\\\\\\\'': ''\\\\\\\\\\\\\\\\''
},
rep;
function quote(string) {
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
escapable.lastIndex = 0;
return escapable.test(string) ? ''\\" '' + string.replace(escapable, function (a) {
var c = meta[a];
return typeof c === '' string '' ? c :
'' \\\\\\\\u '' + ('' 0000 '' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '' \\"'' : ''\\" '' + string + '' \\"''; } FUNCTION str (KEY, holder) { / / Produce a string FROM holder[KEY].var i, / / The LOOP
counter. k, / / The member key. v, / / The member value. length, mind = gap, partial, value = holder[KEY]; / / IF the value has a toJSON method, CALL it TO obtain a replacement value. IF (value && typeof value == = ''object'' && typeof value.toJSON == = ''function'') { value = value.toJSON (KEY); } / / IF we were called WITH a replacer FUNCTION, THEN
CALL the replacer TO / / obtain a replacement value. IF (
typeof rep == = ''function'') { value = rep.call (holder, KEY, value); } / / What happens NEXT depends ON the value ''s type.
switch (typeof value) {
case '' string '':
return quote(value);
case '' number '':
// JSON numbers must be finite. Encode non-finite numbers as null.
return isFinite(value) ? String(value) : '' NULL '';
case '' boolean '':
case '' NULL '':
// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce '' NULL ''. The case is included here in
// the remote chance that this gets fixed someday.
return String(value);
case '' object '':
if (!value) return '' NULL '';
gap += indent;
partial = [];
// Array.isArray
if (Object.prototype.toString.apply(value) === ''[object ARRAY] '') {
length = value.length;
for (i = 0; i < length; i += 1) {
partial[i] = str(i, value) || '' NULL '';
}
// Join all of the elements together, separated with commas, and
// wrap them in brackets.
v = partial.length === 0 ? ''[] '' : gap ?
''[n '' + gap + partial.join('', n '' + gap) + '' n '' + mind + ''] '' :
''['' + partial.join('', '') + ''] '';
gap = mind;
return v;
}
// If the replacer is an array, use it to select the members to be
// stringified.
if (rep && typeof rep === '' object '') {
length = rep.length;
for (i = 0; i < length; i += 1) {
k = rep[i];
if (typeof k === '' string '') {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
else {
// Otherwise, iterate through all of the keys in the object.
for (k in value) {
if (Object.prototype.hasOwnProperty.call(value, k)) {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
// Join all of the member texts together, separated with commas,
// and wrap them in braces.
v = partial.length === 0 ? '' {}'' : gap ? ''{\\\\n'' + gap + partial.join ('',\\\\n'' + gap) + ''\\\\n'' + mind + ''}'' :''{'' + partial.join ('','') + ''}''; gap = mind; RETURN v; } } module.exports = FUNCTION (value, replacer, space) { var i; gap = ''''; indent = ''''; / / IF the space parameter IS a number, make an indent string containing that / / many spaces. IF (typeof space == = ''number'') { FOR (i = 0; i < space; i + = 1) { indent + = '' ''; } } / / IF the space parameter IS a string, it will be used AS the
indent string.
ELSE
IF (typeof space == = ''string'') { indent = space; } / / IF there IS a replacer, it must be a FUNCTION OR an array. / / Otherwise, throw an error. rep = replacer; IF (replacer && typeof replacer != = ''function'' && (typeof replacer != = ''object'' || typeof replacer.length != = ''number'')) { throw new Error (''JSON.stringify''); } / / Make a fake root object containing our value under
the KEY OF ''''. / / RETURN the result OF stringifying the value. RETURN str ('''', {'''' : value }); }; }, {}]}, {},[7]) (7) });
/* plv8 bundle ends */
RETURN module; })(); ');"
`;

exports[`kitchen sink insert 2`] = `
"INSERT INTO shoelace_data VALUES (1, 2, 3, 'truth', (TRUE));
INSERT INTO shoelace_data ( id, col1, col2, val1, bl2 ) VALUES (1, 2, 3, 'truth', (TRUE));
INSERT INTO shoelace_data DEFAULT VALUES;
INSERT INTO v8.modules ( name, code ) VALUES ('ajv', ' (FUNCTION () { var module = { exports: { } };
var exports = module.exports;
/* plv8 bundle begins */
(FUNCTION (f) {if(typeof exports == = \\"object\\" && typeof module != = \\"undefined\\") {module.exports=f()}else IF (typeof define == = \\"function\\" && define.amd) {define([], f) }else{var g;
IF (typeof
WINDOW != = \\"undefined\\") {g=window}else IF (typeof global != = \\"undefined\\") {g=global}else IF (typeof self != = \\"undefined\\") {g=self}else{g=this}g.ajv = f () }})(function(){var define,
module,
exports;
RETURN (FUNCTION e (t, n, r) {function s (o, u) {if(!n[o]){if(!t[o]){var a = typeof require == \\"function\\" && require;
IF (! u && a)
RETURN a (o,
! 0);
IF (i)
RETURN i (o,
! 0);
var f = new Error (\\"Cannot find module ''\\" + o + \\"''\\");
throw f.code = \\"MODULE_NOT_FOUND\\",
f }var l = n[o] = {exports : {}};
t[o][0].CALL (l.exports, FUNCTION (e) {var n = t[o][1][e];
RETURN s (n ? n:e) },
l,
l.exports,
e,
t,
n,
r) }return n[o].exports }var i = typeof require == \\"function\\" && require;
FOR (var o = 0;
o < r.length;
o + +) s (r[o]);
RETURN s })({1 :[FUNCTION (require, module, exports) { (FUNCTION (global) {
/*! https://mths.be/punycode v1.4.1 by @mathias */
;
(FUNCTION (root) {
/** Detect free variables */
var freeExports = typeof exports == ''object'' && exports && ! exports.nodeType && exports;
var freeModule = typeof module == ''object'' && module && ! module.nodeType && module;
var freeGlobal = typeof global == ''object'' && global;
IF (freeGlobal.global == = freeGlobal || freeGlobal.window == = freeGlobal || freeGlobal.self == = freeGlobal) { root = freeGlobal;
}
/**
* The \`punycode\` object.
* @name punycode
* @type Object
*/
var punycode,
/** Highest positive signed 32-bit float value */
maxInt = 2147483647,
/ / aka. 0x7FFFFFFF
OR 2 ^ 31 - 1
/** Bootstring parameters */
base = 36,
tMin = 1,
tMax = 26,
skew = 38,
damp = 700,
initialBias = 72,
initialN = 128,
/ / 0x80 DELIMITER = ''-'',
/ / ''\\\\x2D''
/** Regular expressions */
regexPunycode = / ^ xn --/, regexNonASCII = /[^ x20 - x7E] /,
/ / unprintable ASCII chars + non - ASCII chars regexSeparators = /[x2E u3002 uFF0E uFF61] / g,
/ / RFC 3490 separators
/** Error messages */
errors = { ''overflow'' :''Overflow: input needs wider integers to process'',
''not-basic'' :''Illegal input >= 0x80 (not a basic code point)'',
''invalid-input'' :''Invalid input'' },
/** Convenience shortcuts */
baseMinusTMin = base - tMin,
floor = Math.floor,
stringFromCharCode = String.fromCharCode,
/** Temporary variable */
KEY;
/*--------------------------------------------------------------------------*/
/**
* A generic error utility function.
* @private
* @param {String} type The error type.
* @returns {Error} Throws a \`RangeError\` with the applicable error message.
*/
FUNCTION error (TYPE) { throw new RangeError (errors[TYPE]);
}
/**
* A generic \`Array#map\` utility function.
* @private
* @param {Array} array The array to iterate over.
* @param {Function} callback The function that gets called for every array
* item.
* @returns {Array} A new array of values returned by the callback function.
*/
FUNCTION map (ARRAY, fn) { var length = array.length;
var result =[];
while (length --) { result[length] = fn (ARRAY[length]);
} RETURN result;
}
/**
* A simple \`Array#map\`-like wrapper to work with domain name strings or email
* addresses.
* @private
* @param {String} domain The domain name or email address.
* @param {Function} callback The function that gets called for every
* character.
* @returns {Array} A new string of characters returned by the callback
* function.
*/
FUNCTION mapDomain (string, fn) { var parts = string.split (''@'');
var result = '''';
IF (parts.length > 1) { / / IN email addresses,
ONLY the DOMAIN name should be punycoded. Leave / / the local part (i.e. everything up TO \`@\`) intact. result = parts[0] + ''@'';
string = parts[1];
} / / Avoid \`split(regex)\` FOR IE8 compatibility. See # 17. string = string.replace(regexSeparators, ''\\\\x2E'');
var labels = string.split (''.'');
var encoded = map (labels, fn).
JOIN (''.'');
RETURN result + encoded;
}
/**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see \`punycode.ucs2.encode\`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
FUNCTION ucs2decode (string) { var output =[], counter = 0, length = string.length, value, extra;
while (counter < length) { value = string.charCodeAt (counter + +);
IF (value >= 0xD800 && value <= 0xDBFF && counter < length) { / / high surrogate,
AND there IS a NEXT character extra = string.charCodeAt (counter + +);
IF ((extra & 0xFC00) == 0xDC00) { / / low surrogate output.push (((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
}
ELSE
{ / / unmatched surrogate;
ONLY append this code unit,
IN CASE the NEXT / / code unit IS the high surrogate OF a surrogate pair output.push (value); counter --; } }
ELSE
{ output.push (value); } } RETURN output; }
/**
* Creates a string based on an array of numeric code points.
* @see \`punycode.ucs2.decode\`
* @memberOf punycode.ucs2
* @name encode
* @param {Array} codePoints The array of numeric code points.
* @returns {String} The new Unicode string (UCS-2).
*/
FUNCTION ucs2encode (ARRAY) { RETURN map (ARRAY, FUNCTION (value) { var output = ''''; IF (value > 0xFFFF) { value - = 0x10000; output + = stringFromCharCode (value >> > 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output + = stringFromCharCode (value); RETURN output; }).join(''''); }
/**
* Converts a basic code point into a digit/integer.
* @see \`digitToBasic()\`
* @private
* @param {Number} codePoint The basic numeric code point value.
* @returns {Number} The numeric value of a basic code point (for use in
* representing integers) in the range \`0\` to \`base - 1\`, or \`base\` if
* the code point does not represent a value.
*/
FUNCTION basicToDigit (codePoint) { IF (codePoint - 48 < 10) { RETURN codePoint - 22; } IF (codePoint - 65 < 26) { RETURN codePoint - 65; } IF (codePoint - 97 < 26) { RETURN codePoint - 97; } RETURN base; }
/**
* Converts a digit/integer into a basic code point.
* @see \`basicToDigit()\`
* @private
* @param {Number} digit The numeric value of a basic code point.
* @returns {Number} The basic code point whose value (when used for
* representing integers) is \`digit\`, which needs to be in the range
* \`0\` to \`base - 1\`. If \`flag\` is non-zero, the uppercase form is
* used; else, the lowercase form is used. The behavior is undefined
* if \`flag\` is non-zero and \`digit\` has no uppercase form.
*/
FUNCTION digitToBasic (digit, flag) { / / 0..25 map TO ASCII a..z OR A..Z / / 26..35 map TO ASCII 0..9 RETURN digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }
/**
* Bias adaptation function as per section 3.4 of RFC 3492.
* https://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
FUNCTION adapt (delta, numPoints, firstTime) { var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta + = floor(delta / numPoints); FOR (
/* no initialization */
; delta > baseMinusTMin * tMax >> 1; k + = base) { delta = floor(delta / baseMinusTMin); } RETURN floor(k + (baseMinusTMin + 1) * delta / (delta + skew)); }
/**
* Converts a Punycode string of ASCII-only symbols to a string of Unicode
* symbols.
* @memberOf punycode
* @param {String} input The Punycode string of ASCII-only symbols.
* @returns {String} The resulting string of Unicode symbols.
*/
FUNCTION decode(input) { / / Don ''t use UCS-2
var output = [],
inputLength = input.length,
out,
i = 0,
n = initialN,
bias = initialBias,
basic,
j,
index,
oldi,
w,
k,
digit,
t,
/** Cached calculation results */
baseMinusT;
// Handle the basic code points: let \`basic\` be the number of input code
// points before the last delimiter, or \`0\` if there is none, then copy
// the first basic code points to the output.
basic = input.lastIndexOf(delimiter);
if (basic < 0) {
basic = 0;
}
for (j = 0; j < basic; ++j) {
// if it'' s NOT a basic code point IF (input.charCodeAt (j) >= 0x80) { error (''not-basic''); } output.push (input.charCodeAt (j)); } / / Main decoding loop: START just AFTER the LAST DELIMITER IF ANY basic code / / points were copied; START at the beginning otherwise. FOR (INDEX = basic > 0 ? basic + 1 : 0; INDEX < inputLength;
/* no final expression */) { / / \`index\` IS the INDEX OF the NEXT character TO be consumed. / / Decode a generalized variable - length integer INTO \`delta\`, / / which gets added TO \`i\`.The overflow checking IS easier / / IF we increase \`i\` AS we
go, THEN
subtract OFF its starting / / value at the
END TO obtain \`delta\`. FOR (oldi = i, w = 1, k = base;
/* no condition */
;
k + = base) { IF (INDEX >= inputLength) { error (''invalid-input'');
} digit = basicToDigit (input.charCodeAt (INDEX + +));
IF (digit >= base || digit > floor((maxInt - i) / w)) { error (''overflow'');
} i + = digit * w;
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (digit < t) { break;
} baseMinusT = base - t;
IF (w > floor(maxInt / baseMinusT)) { error (''overflow'');
} w *= baseMinusT;
} out = output.length + 1;
bias = adapt (i - oldi, out, oldi == 0);
/ / \`i\` was supposed TO wrap around
FROM
\`out\` TO \`0\`,
/ / incrementing \`n\` EACH time,
so
we ''ll fix that now:
if (floor(i / out) > maxInt - n) {
error('' overflow '');
}
n += floor(i / out);
i %= out;
// Insert \`n\` at position \`i\` of the output
output.splice(i++, 0, n);
}
return ucs2encode(output);
}
/**
* Converts a string of Unicode symbols (e.g. a domain name label) to a
* Punycode string of ASCII-only symbols.
* @memberOf punycode
* @param {String} input The string of Unicode symbols.
* @returns {String} The resulting Punycode string of ASCII-only symbols.
*/
function encode(input) {
var n,
delta,
handledCPCount,
basicLength,
bias,
j,
m,
q,
k,
t,
currentValue,
output = [],
/** \`inputLength\` will hold the number of code points in \`input\`. */
inputLength,
/** Cached calculation results */
handledCPCountPlusOne,
baseMinusT,
qMinusT;
// Convert the input in UCS-2 to Unicode
input = ucs2decode(input);
// Cache the length
inputLength = input.length;
// Initialize the state
n = initialN;
delta = 0;
bias = initialBias;
// Handle the basic code points
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < 0x80) {
output.push(stringFromCharCode(currentValue));
}
}
handledCPCount = basicLength = output.length;
// \`handledCPCount\` is the number of code points that have been handled;
// \`basicLength\` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if (basicLength) {
output.push(delimiter);
}
// Main encoding loop:
while (handledCPCount < inputLength) {
// All non-basic code points < n have been handled already. Find the next
// larger one:
for (m = maxInt, j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue >= n && currentValue < m) {
m = currentValue;
}
}
// Increase \`delta\` enough to advance the decoder'' s < n,
i > state TO < m,
0 >,
/ / but guard against overflow handledCPCountPlusOne = handledCPCount + 1;
IF (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error (''overflow'');
} delta + = (m - n) * handledCPCountPlusOne;
n = m;
FOR (j = 0;
j < inputLength;
+ + j) { currentValue = input[j];
IF (currentValue < n && + + delta > maxInt) { error (''overflow'');
} IF (currentValue == n) { / / Represent delta AS a generalized variable - length integer FOR (q = delta,
k = base;
/* no condition */
;
k + = base) { t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
IF (q < t) { break;
} qMinusT = q - t;
baseMinusT = base - t;
output.push (stringFromCharCode (digitToBasic (t + qMinusT % baseMinusT, 0)));
q = floor(qMinusT / baseMinusT);
} output.push (stringFromCharCode (digitToBasic (q, 0)));
bias = adapt (delta, handledCPCountPlusOne, handledCPCount == basicLength);
delta = 0;
+ + handledCPCount;
} } + + delta;
+ + n;
} RETURN output.join ('''');
}
/**
* Converts a Punycode string representing a domain name or an email address
* to Unicode. Only the Punycoded parts of the input will be converted, i.e.
* it doesn''t matter if you call it on a string that has already been
* converted to Unicode.
* @memberOf punycode
* @param {String} input The Punycoded domain name or email address to
* convert to Unicode.
* @returns {String} The Unicode representation of the given Punycode
* string.
*/
FUNCTION toUnicode (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexPunycode.test (string) ? decode(string.slice (4).toLowerCase ()) : string;
});
}
/**
* Converts a Unicode string representing a domain name or an email address to
* Punycode. Only the non-ASCII parts of the domain name will be converted,
* i.e. it doesn''t matter if you call it with a domain that''s already in
* ASCII.
* @memberOf punycode
* @param {String} input The domain name or email address to convert, as a
* Unicode string.
* @returns {String} The Punycode representation of the given domain name or
* email address.
*/
FUNCTION toASCII (input) { RETURN mapDomain (input, FUNCTION (string) { RETURN regexNonASCII.test (string) ? ''xn--'' + encode(string) : string;
});
}
/*--------------------------------------------------------------------------*/
/** Define the public API */
punycode = {
/**
* A string representing the current Punycode.js version number.
* @memberOf punycode
* @type String
*/
''version'' :''1.4.1'',
/**
* An object of methods to convert from JavaScript''s internal character
* representation (UCS-2) to Unicode code points, and back.
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode
* @type Object
*/
''ucs2'' : { ''decode'' : ucs2decode,
''encode'' : ucs2encode },
''decode'' : decode,
''encode'' : encode,
''toASCII'' : toASCII,
''toUnicode'' : toUnicode };
/** Expose \`punycode\` */
/ / SOME AMD build optimizers,
LIKE r.js,
CHECK FOR specific condition patterns / / LIKE the following: IF (typeof define == ''function'' && typeof define.amd == ''object'' && define.amd) { define (''punycode'', FUNCTION () { RETURN punycode;
});
}
ELSE
IF (freeExports && freeModule) { IF (module.exports == freeExports) { / / IN Node.js,
io.js,
OR RingoJS v0.8.0 + freeModule.exports = punycode;
}
ELSE
{ / / IN Narwhal
OR RingoJS v0.7.0 - FOR (KEY IN punycode) { punycode.hasOwnProperty (KEY) && (freeExports[KEY] = punycode[KEY]);
} } }
ELSE
{ / / IN Rhino
OR a web browser root.punycode = punycode;
} }(this));
}).call(this,
typeof global != = \\"undefined\\" ? global : typeof self != = \\"undefined\\" ? self : typeof
WINDOW != = \\"undefined\\" ?
WINDOW : {}) },
{}],
2:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
/ / IF obj.hasOwnProperty has been overridden,
THEN
calling / / obj.hasOwnProperty (prop) will break. / / See: https: / / github.com / joyent / node / issues / 1707 FUNCTION hasOwnProperty (obj, prop) { RETURN Object.prototype.hasOwnProperty.call (obj, prop);
} module.exports = FUNCTION (qs, sep, eq, options) { sep = sep || ''&'';
eq = eq || ''='';
var obj = {};
IF (typeof qs != = ''string'' || qs.length == = 0) { RETURN obj;
} var regexp = / + / g;
qs = qs.split (sep);
var maxKeys = 1000;
IF (options && typeof options.maxKeys == = ''number'') { maxKeys = options.maxKeys;
} var len = qs.length;
/ / maxKeys <= 0 means that we should NOT
LIMIT keys count IF (maxKeys > 0 && len > maxKeys) { len = maxKeys;
} FOR (var i = 0;
i < len;
+ + i) { var x = qs[i].replace(regexp, ''%20''),
idx = x.indexOf (eq),
kstr,
vstr,
k,
v;
IF (idx >= 0) { kstr = x.substr(0, idx);
vstr = x.substr(idx + 1);
}
ELSE
{ kstr = x;
vstr = '''';
} k = decodeURIComponent (kstr);
v = decodeURIComponent (vstr);
IF (! hasOwnProperty (obj, k)) { obj[k] = v;
}
ELSE
IF (isArray (obj[k])) { obj[k].push (v);
}
ELSE
{ obj[k] =[obj[k], v];
} } RETURN obj;
};
var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]'';
};
},
{}],
3:[FUNCTION (require, module, exports) { / / Copyright Joyent, Inc.
AND other Node contributors. / / / / Permission IS hereby granted, free OF charge, TO ANY person obtaining a / / COPY OF this software
AND associated documentation files (the / / \\"Software\\"), TO deal IN the Software WITHOUT restriction, INCLUDING / / WITHOUT limitation the rights TO use, COPY, modify, merge, publish, / / distribute, sublicense,
AND /
OR sell copies OF the Software,
AND TO permit / / persons TO whom the Software IS furnished TO DO so, subject TO the / / FOLLOWING conditions: / / / / The above copyright notice
AND this permission notice shall be included / / IN ALL copies
OR substantial portions OF the Software. / / / / THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS / /
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF / / MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN / / NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, / / DAMAGES
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR / / OTHERWISE, ARISING
FROM
, OUT OF
OR IN CONNECTION WITH THE SOFTWARE
OR THE / / USE
OR OTHER DEALINGS IN THE SOFTWARE. ''use strict'';
var stringifyPrimitive = FUNCTION (v) { switch (typeof v) { CASE ''string'' : RETURN v; CASE ''boolean'' : RETURN v ? ''true'' :''false''; CASE ''number'' : RETURN isFinite(v) ? v : ''''; default: RETURN ''''; } }; module.exports = FUNCTION (obj, sep, eq, name) { sep = sep || ''&''; eq = eq || ''=''; IF (obj == = NULL) { obj = undefined; } IF (typeof obj == = ''object'') { RETURN map (objectKeys (obj), FUNCTION (k) { var ks = encodeURIComponent (stringifyPrimitive (k)) + eq; IF (isArray (obj[k])) { RETURN map (obj[k], FUNCTION (v) { RETURN ks + encodeURIComponent (stringifyPrimitive (v)); }).join(sep); }
ELSE
{ RETURN ks + encodeURIComponent (stringifyPrimitive (obj[k])); } }).join(sep); } IF (! name)
RETURN ''''; RETURN encodeURIComponent (stringifyPrimitive (name)) + eq + encodeURIComponent (stringifyPrimitive (obj)); }; var isArray = Array.isArray || FUNCTION (xs) { RETURN Object.prototype.toString.call (xs) == = ''[object Array]''; }; FUNCTION map (xs, f) { IF (xs.map)
RETURN xs.map (f); var res =[]; FOR (var i = 0; i < xs.length; i + +) { res.push (f (xs[i], i)); } RETURN res; } var objectKeys = Object.keys || FUNCTION (obj) { var res =[]; FOR (var KEY IN obj) { IF (Object.prototype.hasOwnProperty.call (obj, KEY)) res.push (KEY); } RETURN res; }; }, {}], 4:[FUNCTION (require, module, exports) { ''use strict''; exports.decode = exports.parse = require (''./decode''); exports.encode = exports.stringify = require (''./encode''); }, {\\". / decode \\":2,\\"./ encode \\":3}],5:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\" Software \\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\" AS IS
\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
''use strict'';
var punycode = require(''punycode'');
var util = require(''./util'');
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
this.protocol = null;
this.slashes = null;
this.auth = null;
this.host = null;
this.port = null;
this.hostname = null;
this.hash = null;
this.search = null;
this.query = null;
this.pathname = null;
this.path = null;
this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
portPattern = /:[0-9]*$/,
// Special case for a simple path URL
simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,
// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = [''<'', ''>'', ''\\" '', '' \`'', '' '', ''\\\\r'', ''\\\\n'', ''\\\\t''],
// RFC 2396: characters not allowed for various reasons.
unwise = [''{'', ''}'', ''|'', ''\\\\\\\\'', ''^'', ''\` ''].concat(delims),
// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['' \\\\'' ''].concat(unwise),
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['' % '', '' / '', '' ? '', ''; '', '' # ''].concat(autoEscape),
hostEndingChars = ['' / '', '' ? '', '' # ''],
hostnameMaxLen = 255,
hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
// protocols that can allow \\"unsafe\\" and \\"unwise\\" chars.
unsafeProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that never have a hostname.
hostlessProtocol = {
'' javascript '': true,
'' javascript: '': true
},
// protocols that always contain a // bit.
slashedProtocol = {
'' http '': true,
'' https '': true,
'' ftp '': true,
'' gopher '': true,
'' file '': true,
'' http: '': true,
'' https: '': true,
'' ftp: '': true,
'' gopher: '': true,
'' file: '': true
},
querystring = require('' querystring '');
function urlParse(url, parseQueryString, slashesDenoteHost) {
if (url && util.isObject(url) && url instanceof Url) return url;
var u = new Url;
u.parse(url, parseQueryString, slashesDenoteHost);
return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
if (!util.isString(url)) {
throw new TypeError(\\"Parameter '' url '' must be a string, not \\" + typeof url);
}
// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex = url.indexOf('' ? ''),
splitter =
(queryIndex !== -1 && queryIndex < url.indexOf('' # '')) ? '' ? '' : '' # '',
uSplit = url.split(splitter),
slashRegex = /\\\\\\\\/g;
uSplit[0] = uSplit[0].replace(slashRegex, '' / '');
url = uSplit.join(splitter);
var rest = url;
// trim before proceeding.
// This is to support parse stuff like \\"  http://foo.com  \\\\n\\"
rest = rest.trim();
if (!slashesDenoteHost && url.split('' # '').length === 1) {
// Try fast path regexp
var simplePath = simplePathPattern.exec(rest);
if (simplePath) {
this.path = rest;
this.href = rest;
this.pathname = simplePath[1];
if (simplePath[2]) {
this.search = simplePath[2];
if (parseQueryString) {
this.query = querystring.parse(this.search.substr(1));
} else {
this.query = this.search.substr(1);
}
} else if (parseQueryString) {
this.search = '''';
this.query = {};
}
return this;
}
}
var proto = protocolPattern.exec(rest);
if (proto) {
proto = proto[0];
var lowerProto = proto.toLowerCase();
this.protocol = lowerProto;
rest = rest.substr(proto.length);
}
// figure out if it'' s got a host / / user@server
IS * always * interpreted AS a hostname, AND url / / resolution will treat / / foo / bar AS host = foo, path = bar because that ''s
// how the browser resolves relative URLs.
if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {
var slashes = rest.substr(0, 2) === '' / / '';
if (slashes && !(proto && hostlessProtocol[proto])) {
rest = rest.substr(2);
this.slashes = true;
}
}
if (!hostlessProtocol[proto] &&
(slashes || (proto && !slashedProtocol[proto]))) {
// there'' s a hostname. / / the FIRST instance OF /, ?,;, OR # ends the host. / / / / IF there IS an @ IN the hostname, THEN
non - host chars * are * allowed / / TO the
LEFT OF the LAST @ sign, unless SOME host - ending character / / comes * BEFORE * the @ - sign. / / URLs are obnoxious. / / / / ex: / / http: / / a@b@c / => user:a@b host:c / / http: / / a@b ? @c => user:a host:c path: / ? @c / / v0.12 TODO (isaacs) : This IS NOT quite how Chrome does things. / / Review our test CASE against browsers more comprehensively. / / find the FIRST instance OF ANY hostEndingChars var hostEnd = - 1; FOR (var i = 0; i < hostEndingChars.length; i + +) { var hec = rest.indexOf (hostEndingChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / at this point, either we have an explicit point
WHERE
the / / auth portion cannot go past, OR the LAST @ char IS the decider. var auth, atSign; IF (hostEnd == = - 1) { / / atSign can be anywhere. atSign = rest.lastIndexOf (''@''); }
ELSE
{ / / atSign must be IN auth portion. / / http: / / a@b / c@d => host:b auth:a path: / c@d atSign = rest.lastIndexOf (''@'', hostEnd); } / / Now we have a portion which IS definitely the auth. / / Pull that off. IF (atSign != = - 1) { auth = rest.slice (0, atSign); rest = rest.slice (atSign + 1); this.auth = decodeURIComponent (auth); } / / the host IS the remaining TO the
LEFT OF the FIRST non - host char hostEnd = - 1; FOR (var i = 0; i < nonHostChars.length; i + +) { var hec = rest.indexOf (nonHostChars[i]); IF (hec != = - 1 && (hostEnd == = - 1 || hec < hostEnd)) hostEnd = hec; } / / IF we still have NOT hit it, THEN
the entire thing IS a host. IF (hostEnd == = - 1) hostEnd = rest.length; this.host = rest.slice (0, hostEnd); rest = rest.slice (hostEnd); / / pull out port. this.parseHost (); / / we ''ve indicated that there is a hostname,
// so even if it'' s empty, it has TO be present. this.hostname = this.hostname || ''''; / / IF hostname begins WITH[ AND ends WITH] / / assume that it ''s an IPv6 address.
var ipv6Hostname = this.hostname[0] === ''['' &&
this.hostname[this.hostname.length - 1] === ''] '';
// validate a little.
if (!ipv6Hostname) {
var hostparts = this.hostname.split(/\\\\./);
for (var i = 0, l = hostparts.length; i < l; i++) {
var part = hostparts[i];
if (!part) continue;
if (!part.match(hostnamePartPattern)) {
var newpart = '''';
for (var j = 0, k = part.length; j < k; j++) {
if (part.charCodeAt(j) > 127) {
// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart += '' x '';
} else {
newpart += part[j];
}
}
// we test again with ASCII char only
if (!newpart.match(hostnamePartPattern)) {
var validParts = hostparts.slice(0, i);
var notHost = hostparts.slice(i + 1);
var bit = part.match(hostnamePartStart);
if (bit) {
validParts.push(bit[1]);
notHost.unshift(bit[2]);
}
if (notHost.length) {
rest = '' / '' + notHost.join(''.'') + rest;
}
this.hostname = validParts.join(''.'');
break;
}
}
}
}
if (this.hostname.length > hostnameMaxLen) {
this.hostname = '''';
} else {
// hostnames are always lower case.
this.hostname = this.hostname.toLowerCase();
}
if (!ipv6Hostname) {
// IDNA Support: Returns a punycoded representation of \\"domain\\".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn'' t matter IF / / you CALL it WITH a DOMAIN that already IS ASCII - only. this.hostname = punycode.toASCII (
this.hostname); } var p = this.port ? '':'' + this.port : ''''; var h = this.hostname || ''''; this.host = h + p; this.href + = this.host; / / strip[ AND] FROM the hostname / / the host field still retains them, though IF (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); IF (rest[0] != = ''/'') { rest = ''/'' + rest; } } } / / now rest IS SET TO the post - host stuff. / / chop OFF ANY delim chars. IF (! unsafeProtocol[lowerProto]) { / / FIRST, make 100 % sure that ANY \\"autoEscape\\" chars get / / escaped, even IF encodeURIComponent doesn ''t think they
// need to be.
for (var i = 0, l = autoEscape.length; i < l; i++) {
var ae = autoEscape[i];
if (rest.indexOf(ae) === -1)
continue;
var esc = encodeURIComponent(ae);
if (esc === ae) {
esc = escape(ae);
}
rest = rest.split(ae).join(esc);
}
}
// chop off from the tail first.
var hash = rest.indexOf('' # '');
if (hash !== -1) {
// got a fragment string.
this.hash = rest.substr(hash);
rest = rest.slice(0, hash);
}
var qm = rest.indexOf('' ? '');
if (qm !== -1) {
this.search = rest.substr(qm);
this.query = rest.substr(qm + 1);
if (parseQueryString) {
this.query = querystring.parse(this.query);
}
rest = rest.slice(0, qm);
} else if (parseQueryString) {
// no query string, but parseQueryString still requested
this.search = '''';
this.query = {};
}
if (rest) this.pathname = rest;
if (slashedProtocol[lowerProto] &&
this.hostname && !this.pathname) {
this.pathname = '' / '';
}
//to support http.request
if (this.pathname || this.search) {
var p = this.pathname || '''';
var s = this.search || '''';
this.path = p + s;
}
// finally, reconstruct the href based on what has been validated.
this.href = this.format();
return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
// ensure it'' s an object, AND NOT a string url. / / IF it ''s an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if (util.isString(obj)) obj = urlParse(obj);
if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
return obj.format();
}
Url.prototype.format = function() {
var auth = this.auth || '''';
if (auth) {
auth = encodeURIComponent(auth);
auth = auth.replace(/%3A/i, '' : '');
auth += '' @ '';
}
var protocol = this.protocol || '''',
pathname = this.pathname || '''',
hash = this.hash || '''',
host = false,
query = '''';
if (this.host) {
host = auth + this.host;
} else if (this.hostname) {
host = auth + (this.hostname.indexOf('' : '') === -1 ?
this.hostname :
''['' + this.hostname + ''] '');
if (this.port) {
host += '' : '' + this.port;
}
}
if (this.query &&
util.isObject(this.query) &&
Object.keys(this.query).length) {
query = querystring.stringify(this.query);
}
var search = this.search || (query && ('' ? '' + query)) || '''';
if (protocol && protocol.substr(-1) !== '' :'') protocol += '' : '';
// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if (this.slashes ||
(!protocol || slashedProtocol[protocol]) && host !== false) {
host = '' / / '' + (host || '''');
if (pathname && pathname.charAt(0) !== '' / '') pathname = '' / '' + pathname;
} else if (!host) {
host = '''';
}
if (hash && hash.charAt(0) !== '' # '') hash = '' # '' + hash;
if (search && search.charAt(0) !== '' ? '') search = '' ? '' + search;
pathname = pathname.replace(/[?#]/g, function(match) {
return encodeURIComponent(match);
});
search = search.replace('' # '', '' % 23 '');
return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
if (!source) return relative;
return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
if (util.isString(relative)) {
var rel = new Url();
rel.parse(relative, false, true);
relative = rel;
}
var result = new Url();
var tkeys = Object.keys(this);
for (var tk = 0; tk < tkeys.length; tk++) {
var tkey = tkeys[tk];
result[tkey] = this[tkey];
}
// hash is always overridden, no matter what.
// even href=\\"\\" will remove it.
result.hash = relative.hash;
// if the relative url is empty, then there'' s NOTHING
LEFT TO DO here. IF (relative.href == = '''') { result.href = result.format(); RETURN result; } / / hrefs LIKE / / foo / bar always cut TO the protocol. IF (relative.slashes && ! relative.protocol) { / / take everything
EXCEPT
the protocol FROM relative var rkeys = Object.keys (relative); FOR (var rk = 0; rk < rkeys.length; rk + +) { var rkey = rkeys[rk]; IF (rkey != = ''protocol'') result[rkey] = relative[rkey]; } / / urlParse appends TRAILING / TO urls LIKE http: / / www.example.com IF (slashedProtocol[result.protocol] && result.hostname && ! result.pathname) { result.path = result.pathname = ''/''; } result.href = result.format(); RETURN result; } IF (relative.protocol && relative.protocol != = result.protocol) { / / IF it ''s a known url protocol, then changing
// the protocol does weird things
// first, if it'' s NOT file:, THEN
we MUST have a host, / /
AND IF there was a path / / TO
BEGIN
WITH,
THEN
we MUST have a path. / / IF it IS file:,
THEN
the host IS dropped,
/ / because that ''s known to be hostless.
// anything else is assumed to be absolute.
if (!slashedProtocol[relative.protocol]) {
var keys = Object.keys(relative);
for (var v = 0; v < keys.length; v++) {
var k = keys[v];
result[k] = relative[k];
}
result.href = result.format();
return result;
}
result.protocol = relative.protocol;
if (!relative.host && !hostlessProtocol[relative.protocol]) {
var relPath = (relative.pathname || '''').split('' / '');
while (relPath.length && !(relative.host = relPath.shift()));
if (!relative.host) relative.host = '''';
if (!relative.hostname) relative.hostname = '''';
if (relPath[0] !== '''') relPath.unshift('''');
if (relPath.length < 2) relPath.unshift('''');
result.pathname = relPath.join('' / '');
} else {
result.pathname = relative.pathname;
}
result.search = relative.search;
result.query = relative.query;
result.host = relative.host || '''';
result.auth = relative.auth;
result.hostname = relative.hostname || relative.host;
result.port = relative.port;
// to support http.request
if (result.pathname || result.search) {
var p = result.pathname || '''';
var s = result.search || '''';
result.path = p + s;
}
result.slashes = result.slashes || relative.slashes;
result.href = result.format();
return result;
}
var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '' / ''),
isRelAbs = (
relative.host ||
relative.pathname && relative.pathname.charAt(0) === '' / ''
),
mustEndAbs = (isRelAbs || isSourceAbs ||
(result.host && relative.pathname)),
removeAllDots = mustEndAbs,
srcPath = result.pathname && result.pathname.split('' / '') || [],
relPath = relative.pathname && relative.pathname.split('' / '') || [],
psychotic = result.protocol && !slashedProtocol[result.protocol];
// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if (psychotic) {
result.hostname = '''';
result.port = null;
if (result.host) {
if (srcPath[0] === '''') srcPath[0] = result.host;
else srcPath.unshift(result.host);
}
result.host = '''';
if (relative.protocol) {
relative.hostname = null;
relative.port = null;
if (relative.host) {
if (relPath[0] === '''') relPath[0] = relative.host;
else relPath.unshift(relative.host);
}
relative.host = null;
}
mustEndAbs = mustEndAbs && (relPath[0] === '''' || srcPath[0] === '''');
}
if (isRelAbs) {
// it'' s absolute. result.host = (
relative.host || relative.host == = '''') ? relative.host : result.host; result.hostname = (relative.hostname || relative.hostname == = '''') ? relative.hostname : result.hostname; result.search = relative.search; result.query = relative.query; srcPath = relPath; / / fall through TO the dot - handling below. }
ELSE
IF (relPath.length) { / / it ''s relative
// throw away the existing file, and take the new path instead.
if (!srcPath) srcPath = [];
srcPath.pop();
srcPath = srcPath.concat(relPath);
result.search = relative.search;
result.query = relative.query;
} else if (!util.isNullOrUndefined(relative.search)) {
// just pull out the search.
// like href='' ? foo ''.
// Put this after the other two cases because it simplifies the booleans
if (psychotic) {
result.hostname = result.host = srcPath.shift();
//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('' mailto:local1@domain1 '', '' local2@domain2 '')
var authInHost = result.host && result.host.indexOf('' @ '') > 0 ?
result.host.split('' @ '') : false;
if (authInHost) {
result.auth = authInHost.shift();
result.host = result.hostname = authInHost.shift();
}
}
result.search = relative.search;
result.query = relative.query;
//to support http.request
if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
result.path = (result.pathname ? result.pathname : '''') +
(result.search ? result.search : '''');
}
result.href = result.format();
return result;
}
if (!srcPath.length) {
// no path at all.  easy.
// we'' ve already handled the other stuff above. result.pathname = NULL; / / TO support http.request IF (result.search) { result.path = ''/'' + result.search; }
ELSE
{ result.path = NULL; } result.href = result.format(); RETURN result; } / / IF a url ENDs IN. OR.., THEN
it must get a TRAILING slash. / / however, IF it ends IN anything
ELSE
non - slashy, / / THEN
it must NOT get a TRAILING slash. var LAST = srcPath.slice (- 1)[0]; var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (LAST == = ''.'' || LAST == = ''..'') || LAST == = ''''); / / strip single dots, resolve double dots TO parent dir / / IF the path tries TO go above the root, \`up\` ends up > 0 var up = 0; FOR (var i = srcPath.length; i >= 0; i --) { LAST = srcPath[i]; IF (LAST == = ''.'') { srcPath.splice (i, 1); }
ELSE
IF (LAST == = ''..'') { srcPath.splice (i, 1); up + +; }
ELSE
IF (up) { srcPath.splice (i, 1); up --; } } / / IF the path IS allowed TO go above the root, restore LEADING..s IF (! mustEndAbs && ! removeAllDots) { FOR (;up --; up) { srcPath.unshift (''..''); } } IF (mustEndAbs && srcPath[0] != = '''' && (! srcPath[0] || srcPath[0].charAt (0) != = ''/'')) { srcPath.unshift (''''); } IF (hasTrailingSlash && (srcPath.join (''/'').substr(- 1) != = ''/'')) { srcPath.push (''''); } var isAbsolute = srcPath[0] == = '''' || (srcPath[0] && srcPath[0].charAt (0) == = ''/''); / / put the host back IF (psychotic) { result.hostname = result.host = isAbsolute ? '''' : srcPath.length ? srcPath.shift () : ''''; / / occationaly the auth can get stuck ONLY IN host / / this especially happens IN cases LIKE / / url.resolveObject (''mailto:local1@domain1'', ''local2@domain2'') var authInHost = result.host && result.host.indexOf (''@'') > 0 ? result.host.split (''@'') : FALSE; IF (authInHost) { result.auth = authInHost.shift (); result.host = result.hostname = authInHost.shift (); } } mustEndAbs = mustEndAbs || (result.host && srcPath.length); IF (mustEndAbs && ! isAbsolute) { srcPath.unshift (''''); } IF (! srcPath.length) { result.pathname = NULL; result.path = NULL; }
ELSE
{ result.pathname = srcPath.join (''/''); } / / TO support request.http IF (! util.isNull (result.pathname) || ! util.isNull (result.search)) { result.path = (result.pathname ? result.pathname : '''') + (result.search ? result.search : ''''); } result.auth = relative.auth || result.auth; result.slashes = result.slashes || relative.slashes; result.href = result.format(); RETURN result; }; Url.prototype.parseHost = FUNCTION () { var host = this.host; var port = portPattern.exec (host); IF (port) { port = port[0]; IF (port != = '':'') { this.port = port.substr(1); } host = host.substr(0, host.length - port.length); } IF (host) this.hostname = host; }; }, {\\". / util \\":6,\\" punycode \\":1,\\" querystring \\":4}],6:[function(require,module,exports){
''use strict'';
module.exports = {
isString: function(arg) {
return typeof(arg) === ''string'';
},
isObject: function(arg) {
return typeof(arg) === ''object'' && arg !== null;
},
isNull: function(arg) {
return arg === null;
},
isNullOrUndefined: function(arg) {
return arg == null;
}
};
},{}],7:[function(require,module,exports){
module.exports = require(''ajv'');
},{\\" ajv \\":9}],8:[function(require,module,exports){
''use strict'';
var KEYWORDS = [
''multipleOf'',
''maximum'',
''exclusiveMaximum'',
''minimum'',
''exclusiveMinimum'',
''maxLength'',
''minLength'',
''pattern'',
''additionalItems'',
''maxItems'',
''minItems'',
''uniqueItems'',
''maxProperties'',
''minProperties'',
''required'',
''additionalProperties'',
''enum'',
''format'',
''const''
];
module.exports = function (metaSchema, keywordsJsonPointers) {
for (var i=0; i<keywordsJsonPointers.length; i++) {
metaSchema = JSON.parse(JSON.stringify(metaSchema));
var segments = keywordsJsonPointers[i].split(''/'');
var keywords = metaSchema;
var j;
for (j=1; j<segments.length; j++)
keywords = keywords[segments[j]];
for (j=0; j<KEYWORDS.length; j++) {
var key = KEYWORDS[j];
var schema = keywords[key];
if (schema) {
keywords[key] = {
anyOf: [
schema,
{ $ref: ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
}
}
return metaSchema;
};
},{}],9:[function(require,module,exports){
''use strict'';
var compileSchema = require(''./compile'')
, resolve = require(''./compile/resolve'')
, Cache = require(''./cache'')
, SchemaObject = require(''./compile/schema_obj'')
, stableStringify = require(''json-stable-stringify'')
, formats = require(''./compile/formats'')
, rules = require(''./compile/rules'')
, $dataMetaSchema = require(''./$data'')
, patternGroups = require(''./patternGroups'')
, util = require(''./compile/util'')
, co = require(''co'');
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = require(''./compile/async'');
var customKeyword = require(''./keyword'');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
var errorClasses = require(''./compile/error_classes'');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
var META_IGNORE_OPTIONS = [ ''removeAdditional'', ''useDefaults'', ''coerceTypes'' ];
var META_SUPPORT_DATA = [''/properties''];
/**
* Creates validator instance.
* Usage: \`Ajv(opts)\`
* @param {Object} opts optional options
* @return {Object} ajv instance
*/
function Ajv(opts) {
if (!(this instanceof Ajv)) return new Ajv(opts);
opts = this._opts = util.copy(opts) || {};
this._schemas = {};
this._refs = {};
this._fragments = {};
this._formats = formats(opts.format);
var schemaUriFormat = this._schemaUriFormat = this._formats[''uri-reference''];
this._schemaUriFormatFunc = function (str) { return schemaUriFormat.test(str); };
this._cache = opts.cache || new Cache;
this._loadingSchemas = {};
this._compilations = [];
this.RULES = rules();
this._getId = chooseGetId(opts);
opts.loopRequired = opts.loopRequired || Infinity;
if (opts.errorDataPath == ''property'') opts._errorDataPathProperty = true;
if (opts.serialize === undefined) opts.serialize = stableStringify;
this._metaOpts = getMetaSchemaOptions(this);
if (opts.formats) addInitialFormats(this);
addDraft6MetaSchema(this);
if (typeof opts.meta == ''object'') this.addMetaSchema(opts.meta);
addInitialSchemas(this);
if (opts.patternGroups) patternGroups(this);
}
/**
* Validate data using schema
* Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
* @this   Ajv
* @param  {String|Object} schemaKeyRef key, ref or schema object
* @param  {Any} data to be validated
* @return {Boolean} validation result. Errors from the last validation will be available in \`ajv.errors\` (and also in compiled schema: \`schema.errors\`).
*/
function validate(schemaKeyRef, data) {
var v;
if (typeof schemaKeyRef == ''string'') {
v = this.getSchema(schemaKeyRef);
if (!v) throw new Error(''no schema with key or ref \\" '' + schemaKeyRef + '' \\"'');
} else {
var schemaObj = this._addSchema(schemaKeyRef);
v = schemaObj.validate || this._compile(schemaObj);
}
var valid = v(data);
if (v.$async === true)
return this._opts.async == ''*'' ? co(valid) : valid;
this.errors = v.errors;
return valid;
}
/**
* Create validating function for passed schema.
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
* @return {Function} validating function
*/
function compile(schema, _meta) {
var schemaObj = this._addSchema(schema, undefined, _meta);
return schemaObj.validate || this._compile(schemaObj);
}
/**
* Adds schema to the instance.
* @this   Ajv
* @param {Object|Array} schema schema or array of schemas. If array is passed, \`key\` and other parameters will be ignored.
* @param {String} key Optional schema key. Can be passed to \`validate\` method instead of schema object or id/ref. One schema per instance can have empty \`id\` and \`key\`.
* @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
* @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
*/
function addSchema(schema, key, _skipValidation, _meta) {
if (Array.isArray(schema)){
for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
return;
}
var id = this._getId(schema);
if (id !== undefined && typeof id != ''string'')
throw new Error(''schema id must be string'');
key = resolve.normalizeId(key || id);
checkUnique(this, key);
this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
}
/**
* Add schema that will be used to validate other schemas
* options in META_IGNORE_OPTIONS are alway set to false
* @this   Ajv
* @param {Object} schema schema object
* @param {String} key optional schema key
* @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
*/
function addMetaSchema(schema, key, skipValidation) {
this.addSchema(schema, key, skipValidation, true);
}
/**
* Validate schema
* @this   Ajv
* @param {Object} schema schema to validate
* @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
* @return {Boolean} true if schema is valid
*/
function validateSchema(schema, throwOrLogError) {
var $schema = schema.$schema;
if ($schema !== undefined && typeof $schema != ''string'')
throw new Error(''$schema must be a string'');
$schema = $schema || this._opts.defaultMeta || defaultMeta(this);
if (!$schema) {
console.warn(''meta-schema not available'');
this.errors = null;
return true;
}
var currentUriFormat = this._formats.uri;
this._formats.uri = typeof currentUriFormat == ''function''
? this._schemaUriFormatFunc
: this._schemaUriFormat;
var valid;
try { valid = this.validate($schema, schema); }
finally { this._formats.uri = currentUriFormat; }
if (!valid && throwOrLogError) {
var message = ''schema is invalid: '' + this.errorsText();
if (this._opts.validateSchema == ''log'') console.error(message);
else throw new Error(message);
}
return valid;
}
function defaultMeta(self) {
var meta = self._opts.meta;
self._opts.defaultMeta = typeof meta == ''object''
? self._getId(meta) || meta
: self.getSchema(META_SCHEMA_ID)
? META_SCHEMA_ID
: undefined;
return self._opts.defaultMeta;
}
/**
* Get compiled schema from the instance by \`key\` or \`ref\`.
* @this   Ajv
* @param  {String} keyRef \`key\` that was passed to \`addSchema\` or full schema reference (\`schema.id\` or resolved id).
* @return {Function} schema validating function (with property \`schema\`).
*/
function getSchema(keyRef) {
var schemaObj = _getSchemaObj(this, keyRef);
switch (typeof schemaObj) {
case ''object'': return schemaObj.validate || this._compile(schemaObj);
case ''string'': return this.getSchema(schemaObj);
case ''undefined'': return _getSchemaFragment(this, keyRef);
}
}
function _getSchemaFragment(self, ref) {
var res = resolve.schema.call(self, { schema: {} }, ref);
if (res) {
var schema = res.schema
, root = res.root
, baseId = res.baseId;
var v = compileSchema.call(self, schema, root, undefined, baseId);
self._fragments[ref] = new SchemaObject({
ref: ref,
fragment: true,
schema: schema,
root: root,
baseId: baseId,
validate: v
});
return v;
}
}
function _getSchemaObj(self, keyRef) {
keyRef = resolve.normalizeId(keyRef);
return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
* Remove cached schema(s).
* If no parameter is passed all schemas but meta-schemas are removed.
* If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
* Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
* @this   Ajv
* @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
*/
function removeSchema(schemaKeyRef) {
if (schemaKeyRef instanceof RegExp) {
_removeAllSchemas(this, this._schemas, schemaKeyRef);
_removeAllSchemas(this, this._refs, schemaKeyRef);
return;
}
switch (typeof schemaKeyRef) {
case ''undefined'':
_removeAllSchemas(this, this._schemas);
_removeAllSchemas(this, this._refs);
this._cache.clear();
return;
case ''string'':
var schemaObj = _getSchemaObj(this, schemaKeyRef);
if (schemaObj) this._cache.del(schemaObj.cacheKey);
delete this._schemas[schemaKeyRef];
delete this._refs[schemaKeyRef];
return;
case ''object'':
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
this._cache.del(cacheKey);
var id = this._getId(schemaKeyRef);
if (id) {
id = resolve.normalizeId(id);
delete this._schemas[id];
delete this._refs[id];
}
}
}
function _removeAllSchemas(self, schemas, regex) {
for (var keyRef in schemas) {
var schemaObj = schemas[keyRef];
if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
self._cache.del(schemaObj.cacheKey);
delete schemas[keyRef];
}
}
}
/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
if (typeof schema != ''object'' && typeof schema != ''boolean'')
throw new Error(''schema should be object or boolean'');
var serialize = this._opts.serialize;
var cacheKey = serialize ? serialize(schema) : schema;
var cached = this._cache.get(cacheKey);
if (cached) return cached;
shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
var id = resolve.normalizeId(this._getId(schema));
if (id && shouldAddSchema) checkUnique(this, id);
var willValidate = this._opts.validateSchema !== false && !skipValidation;
var recursiveMeta;
if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
this.validateSchema(schema, true);
var localRefs = resolve.ids.call(this, schema);
var schemaObj = new SchemaObject({
id: id,
schema: schema,
localRefs: localRefs,
cacheKey: cacheKey,
meta: meta
});
if (id[0] != ''#'' && shouldAddSchema) this._refs[id] = schemaObj;
this._cache.put(cacheKey, schemaObj);
if (willValidate && recursiveMeta) this.validateSchema(schema, true);
return schemaObj;
}
/* @this   Ajv */
function _compile(schemaObj, root) {
if (schemaObj.compiling) {
schemaObj.validate = callValidate;
callValidate.schema = schemaObj.schema;
callValidate.errors = null;
callValidate.root = root ? root : callValidate;
if (schemaObj.schema.$async === true)
callValidate.$async = true;
return callValidate;
}
schemaObj.compiling = true;
var currentOpts;
if (schemaObj.meta) {
currentOpts = this._opts;
this._opts = this._metaOpts;
}
var v;
try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
finally {
schemaObj.compiling = false;
if (schemaObj.meta) this._opts = currentOpts;
}
schemaObj.validate = v;
schemaObj.refs = v.refs;
schemaObj.refVal = v.refVal;
schemaObj.root = v.root;
return v;
function callValidate() {
var _validate = schemaObj.validate;
var result = _validate.apply(null, arguments);
callValidate.errors = _validate.errors;
return result;
}
}
function chooseGetId(opts) {
switch (opts.schemaId) {
case ''$id'': return _get$Id;
case ''id'': return _getId;
default: return _get$IdOrId;
}
}
function _getId(schema) {
if (schema.$id) console.warn(''schema $id ignored'', schema.$id);
return schema.id;
}
function _get$Id(schema) {
if (schema.id) console.warn(''schema id ignored'', schema.id);
return schema.$id;
}
function _get$IdOrId(schema) {
if (schema.$id && schema.id && schema.$id != schema.id)
throw new Error(''schema $id is different from id'');
return schema.$id || schema.id;
}
/**
* Convert array of error message objects to string
* @this   Ajv
* @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
* @param  {Object} options optional options with properties \`separator\` and \`dataVar\`.
* @return {String} human readable string with all errors descriptions
*/
function errorsText(errors, options) {
errors = errors || this.errors;
if (!errors) return ''No errors'';
options = options || {};
var separator = options.separator === undefined ? '', '' : options.separator;
var dataVar = options.dataVar === undefined ? ''data'' : options.dataVar;
var text = '''';
for (var i=0; i<errors.length; i++) {
var e = errors[i];
if (e) text += dataVar + e.dataPath + '' '' + e.message + separator;
}
return text.slice(0, -separator.length);
}
/**
* Add custom format
* @this   Ajv
* @param {String} name format name
* @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
*/
function addFormat(name, format) {
if (typeof format == ''string'') format = new RegExp(format);
this._formats[name] = format;
}
function addDraft6MetaSchema(self) {
var $dataSchema;
if (self._opts.$data) {
$dataSchema = require(''./refs/$data.json'');
self.addMetaSchema($dataSchema, $dataSchema.$id, true);
}
if (self._opts.meta === false) return;
var metaSchema = require(''./refs/json-schema-draft-06.json'');
if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
self._refs[''http://json-schema.org/schema''] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
var optsSchemas = self._opts.schemas;
if (!optsSchemas) return;
if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
for (var name in self._opts.formats) {
var format = self._opts.formats[name];
self.addFormat(name, format);
}
}
function checkUnique(self, id) {
if (self._schemas[id] || self._refs[id])
throw new Error(''schema with key or id \\" '' + id + '' \\" already exists'');
}
function getMetaSchemaOptions(self) {
var metaOpts = util.copy(self._opts);
for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
delete metaOpts[META_IGNORE_OPTIONS[i]];
return metaOpts;
}
},{\\"./ $ data \\":8,\\"./
CACHE \\":10,\\"./ compile \\":15,\\"./ compile / async \\":12,\\"./ compile / error_classes \\":13,\\"./ compile / formats \\":14,\\"./ compile / resolve \\":16,\\"./ compile / rules \\":17,\\"./ compile / schema_obj \\":18,\\"./ compile / util \\":20,\\"./ keyword \\":44,\\"./ patternGroups \\":45,\\"./ refs / $ data.json \\":46,\\"./ refs / json - SCHEMA - draft - 06.json \\":47,\\" co \\":48,\\" json - STABLE - stringify \\":51}],10:[function(require,module,exports){
''use strict'';
var Cache = module.exports = function Cache() {
this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
this._cache = {};
};
},{}],11:[function(require,module,exports){
''use strict'';
//all requires must be explicit because browserify won''t work with dynamic requires
module.exports = {
''$ref'': require(''../dotjs/ref''),
allOf: require(''../dotjs/allOf''),
anyOf: require(''../dotjs/anyOf''),
const: require(''../dotjs/const''),
contains: require(''../dotjs/contains''),
dependencies: require(''../dotjs/dependencies''),
''enum'': require(''../dotjs/enum''),
format: require(''../dotjs/format''),
items: require(''../dotjs/items''),
maximum: require(''../dotjs/_limit''),
minimum: require(''../dotjs/_limit''),
maxItems: require(''../dotjs/_limitItems''),
minItems: require(''../dotjs/_limitItems''),
maxLength: require(''../dotjs/_limitLength''),
minLength: require(''../dotjs/_limitLength''),
maxProperties: require(''../dotjs/_limitProperties''),
minProperties: require(''../dotjs/_limitProperties''),
multipleOf: require(''../dotjs/multipleOf''),
not: require(''../dotjs/not''),
oneOf: require(''../dotjs/oneOf''),
pattern: require(''../dotjs/pattern''),
properties: require(''../dotjs/properties''),
propertyNames: require(''../dotjs/propertyNames''),
required: require(''../dotjs/required''),
uniqueItems: require(''../dotjs/uniqueItems''),
validate: require(''../dotjs/validate'')
};
},{\\"../ dotjs / _limit \\":21,\\"../ dotjs / _limitItems \\":22,\\"../ dotjs / _limitLength \\":23,\\"../ dotjs / _limitProperties \\":24,\\"../ dotjs / allOf \\":25,\\"../ dotjs / anyOf \\":26,\\"../ dotjs / const \\":27,\\"../ dotjs / contains \\":28,\\"../ dotjs / dependencies \\":30,\\"../ dotjs / enum \\":31,\\"../ dotjs / format \\":32,\\"../ dotjs / items \\":33,\\"../ dotjs / multipleOf \\":34,\\"../ dotjs / NOT \\":35,\\"../ dotjs / oneOf \\":36,\\"../ dotjs / pattern \\":37,\\"../ dotjs / properties \\":38,\\"../ dotjs / propertyNames \\":39,\\"../ dotjs / ref \\":40,\\"../ dotjs / required \\":41,\\"../ dotjs / uniqueItems \\":42,\\"../ dotjs / validate \\":43}],12:[function(require,module,exports){
''use strict'';
var MissingRefError = require(''./error_classes'').MissingRef;
module.exports = compileAsync;
/**
* Creates validating function for passed schema with asynchronous loading of missing schemas.
* \`loadSchema\` option should be a function that accepts schema uri and returns promise that resolves with the schema.
* @this  Ajv
* @param {Object}   schema schema object
* @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
* @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
* @return {Promise} promise that resolves with a validating function.
*/
function compileAsync(schema, meta, callback) {
/* eslint no-shadow: 0 */
/* global Promise */
/* jshint validthis: true */
var self = this;
if (typeof this._opts.loadSchema != ''function'')
throw new Error(''options.loadSchema should be a function'');
if (typeof meta == ''function'') {
callback = meta;
meta = undefined;
}
var p = loadMetaSchemaOf(schema).then(function () {
var schemaObj = self._addSchema(schema, undefined, meta);
return schemaObj.validate || _compileAsync(schemaObj);
});
if (callback) {
p.then(
function(v) { callback(null, v); },
callback
);
}
return p;
function loadMetaSchemaOf(sch) {
var $schema = sch.$schema;
return $schema && !self.getSchema($schema)
? compileAsync.call(self, { $ref: $schema }, true)
: Promise.resolve();
}
function _compileAsync(schemaObj) {
try { return self._compile(schemaObj); }
catch(e) {
if (e instanceof MissingRefError) return loadMissingSchema(e);
throw e;
}
function loadMissingSchema(e) {
var ref = e.missingSchema;
if (added(ref)) throw new Error(''Schema '' + ref + '' is loaded but '' + e.missingRef + '' cannot be resolved'');
var schemaPromise = self._loadingSchemas[ref];
if (!schemaPromise) {
schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
schemaPromise.then(removePromise, removePromise);
}
return schemaPromise.then(function (sch) {
if (!added(ref)) {
return loadMetaSchemaOf(sch).then(function () {
if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
});
}
}).then(function() {
return _compileAsync(schemaObj);
});
function removePromise() {
delete self._loadingSchemas[ref];
}
function added(ref) {
return self._refs[ref] || self._schemas[ref];
}
}
}
}
},{\\"./ error_classes \\":13}],13:[function(require,module,exports){
''use strict'';
var resolve = require(''./resolve'');
module.exports = {
Validation: errorSubclass(ValidationError),
MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
this.message = ''validation failed'';
this.errors = errors;
this.ajv = this.validation = true;
}
MissingRefError.message = function (baseId, ref) {
return ''can\\\\''t resolve reference '' + ref + '' from id '' + baseId;
};
function MissingRefError(baseId, ref, message) {
this.message = message || MissingRefError.message(baseId, ref);
this.missingRef = resolve.url(baseId, ref);
this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
Subclass.prototype = Object.create(Error.prototype);
Subclass.prototype.constructor = Subclass;
return Subclass;
}
},{\\"./ resolve \\":16}],14:[function(require,module,exports){
''use strict'';
var util = require(''./util'');
var DATE = /^\\\\d\\\\d\\\\d\\\\d-(\\\\d\\\\d)-(\\\\d\\\\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\\\\d\\\\d):(\\\\d\\\\d):(\\\\d\\\\d)(\\\\.\\\\d+)?(z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\\\\-.]*:)(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''()*+,;=]|%[0-9a-f]{2})*)(?::\\\\d*)?(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\\\?(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\\\-._~!$&''()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\\\\-.]*:)?(?:\\\\/?\\\\/(?:(?:[a-z0-9\\\\-._~!$&''()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\\\.[a-z0-9\\\\-._~!$&''()*+,;=:]+)\\\\]|(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)|(?:[a-z0-9\\\\-._~!$&''\\" () * +,; =] | %[0 - 9a - f] {2}) *) (?::d *) ? (? : / (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\\\/(?:(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@] | %[0 - 9a - f] {2}) *) *) ? | (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\\\/(?:[a-z0-9\\\\-._~!$&'' \\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\\\?(?:[a-z0-9\\\\-._~!$&''\\" () * +,; = :@ / ?] | %[0 - 9a - f] {2}) *) ? (? : # (? :[a - z0 - 9 -._ ~ ! $ & ''\\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\\\\x00-\\\\x20\\"'' <> % \\\\\\\\ ^ \`{|}]|%[0-9a-f]{2})|\\\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\\\*)?)*\\\\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\\\\/\\\\/)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!10(?:\\\\.\\\\d{1,3}){3})(?!127(?:\\\\.\\\\d{1,3}){3})(?!169\\\\.254(?:\\\\.\\\\d{1,3}){2})(?!192\\\\.168(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+-?)*[a-z\\\\u{00a1}-\\\\u{ffff}0-9]+)*(?:\\\\.(?:[a-z\\\\u{00a1}-\\\\u{ffff}]{2,})))(?::\\\\d{2,5})?(?:\\\\/[^\\\\s]*)?$/iu;
var URL = /^(?:(?:http[s\\\\u017F]?|ftp):\\\\/\\\\/)(?:(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+(?::(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?@)?(?:(?!10(?:\\\\.[0-9]{1,3}){3})(?!127(?:\\\\.[0-9]{1,3}){3})(?!169\\\\.254(?:\\\\.[0-9]{1,3}){2})(?!192\\\\.168(?:\\\\.[0-9]{1,3}){2})(?!172\\\\.(?:1[6-9]|2[0-9]|3[01])(?:\\\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)(?:\\\\.(?:(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+-?)*(?:[0-9KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])+)*(?:\\\\.(?:(?:[KSa-z\\\\xA1-\\\\uD7FF\\\\uE000-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\\\/(?:[\\\\0-\\\\x08\\\\x0E-\\\\x1F!-\\\\x9F\\\\xA1-\\\\u167F\\\\u1681-\\\\u1FFF\\\\u200B-\\\\u2027\\\\u202A-\\\\u202E\\\\u2030-\\\\u205E\\\\u2060-\\\\u2FFF\\\\u3001-\\\\uD7FF\\\\uE000-\\\\uFEFE\\\\uFF00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF](?![\\\\uDC00-\\\\uDFFF])|(?:[^\\\\uD800-\\\\uDBFF]|^)[\\\\uDC00-\\\\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\\\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\\\/(?:[a-z0-9_\\\\-.!$&''()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\\\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
mode = mode == ''full'' ? ''full'' : ''fast'';
return util.copy(formats[mode]);
}
formats.fast = {
// date: http://tools.ietf.org/html/rfc3339#section-5.6
date: /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d$/,
// date-time: http://tools.ietf.org/html/rfc3339#section-5.6
time: /^[0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)?$/i,
''date-time'': /^\\\\d\\\\d\\\\d\\\\d-[0-1]\\\\d-[0-3]\\\\d[t\\\\s][0-2]\\\\d:[0-5]\\\\d:[0-5]\\\\d(?:\\\\.\\\\d+)?(?:z|[+-]\\\\d\\\\d:\\\\d\\\\d)$/i,
// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\\\\/)\\\\/?[^\\\\s]*$/i,
''uri-reference'': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\\\/\\\\/)?[^\\\\s]*$/i,
''uri-template'': URITEMPLATE,
url: URL,
// email (sources from jsen validator):
// http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
// http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for ''willful violation'')
email: /^[a-z0-9.!#$%&''*+/=?^_\` {|}~ -] + @[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ? (? :.[a - z0 - 9] (? :[a - z0 - 9 -] {0, 61 }[a - z0 - 9]) ?) * $ / i, hostname: HOSTNAME, / / optimized https: / / www.safaribooksonline.com / library / VIEW / regular - expressions - cookbook / 9780596802837 / ch07s16.html ipv4: / ^ (? : (? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?).) {3}(? :25[0 - 5] | 2[0 - 4] d |[01] ? d d ?) $ /, / / optimized http: / / stackoverflow.com / questions / 53497 / regular - expression - that - matches - valid - ipv6 - addresses ipv6: / ^ s * (? : (? : (? :[0 - 9a - f] {1, 4 } :) {7}(? :[0 - 9a - f] {1, 4 }| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {6}(?::[0 - 9a - f] {1, 4 }|(? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {5}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 2 })| : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3})| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {4}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 3 })|(? : (?::[0 - 9a - f] {1, 4 })? : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {3}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 4 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 2 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {2}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 5 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 3 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (? : (? :[0 - 9a - f] {1, 4 } :) {1}(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 6 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 4 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :)) | (?::(? : (? : (?::[0 - 9a - f] {1, 4 }){1, 7 })|(? : (?::[0 - 9a - f] {1, 4 }){0, 5 } : (? : (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d) (? :. (? :25[0 - 5] | 2[0 - 4] d | 1 d d |[1 - 9] ? d)) {3}))| :))) (? : %.+) ? s * $ / i, regex: regex, / / uuid: http: / / tools.ietf.org / html / rfc4122 uuid: uuid, / / json - pointer: https: / / tools.ietf.org / html / rfc6901 / / uri fragment: https: / / tools.ietf.org / html / rfc3986 # appendix - A ''json-pointer'' : JSON_POINTER, / / relative json - pointer: http: / / tools.ietf.org / html / draft - luff - relative - json - pointer - 00 ''relative-json-pointer'' : RELATIVE_JSON_POINTER }; formats.full = { date: date, time: time, ''date-time'' : date_time, uri: uri, ''uri-reference'' : URIREF, ''uri-template'' : URITEMPLATE, url: URL, email: / ^[a - z0 - 9 ! # $ % & ''*+/=?^_\`{|}~-]+(?:\\\\.[a-z0-9!#$%&''''*+/=?^_\`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
hostname: hostname,
ipv4: /^(?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d\\\\d?)$/,
ipv6: /^\\\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:)))(?:%.+)?\\\\s*$/i,
regex: regex,
uuid: UUID,
'' json - pointer '': JSON_POINTER,
'' relative - json - pointer '': RELATIVE_JSON_POINTER
};
function date(str) {
// full-date from http://tools.ietf.org/html/rfc3339#section-5.6
var matches = str.match(DATE);
if (!matches) return false;
var month = +matches[1];
var day = +matches[2];
return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}
function time(str, full) {
var matches = str.match(TIME);
if (!matches) return false;
var hour = matches[1];
var minute = matches[2];
var second = matches[3];
var timeZone = matches[5];
return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\\\\s/i;
function date_time(str) {
// http://tools.ietf.org/html/rfc3339#section-5.6
var dateTime = str.split(DATE_TIME_SEPARATOR);
return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function hostname(str) {
// https://tools.ietf.org/html/rfc1034#section-3.5
// https://tools.ietf.org/html/rfc1123#section-2
return str.length <= 255 && HOSTNAME.test(str);
}
var NOT_URI_FRAGMENT = /\\\\/|:/;
function uri(str) {
// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \\".\\"
return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\\\\\\\]\\\\\\\\Z/;
function regex(str) {
if (Z_ANCHOR.test(str)) return false;
try {
new RegExp(str);
return true;
} catch(e) {
return false;
}
}
},{\\"./util\\":20}],15:[function(require,module,exports){
'' use STRICT '';
var resolve = require(''./ resolve '')
, util = require(''./ util '')
, errorClasses = require(''./ error_classes '')
, stableStringify = require('' json - STABLE - stringify '');
var validateGenerator = require(''../ dotjs / validate '');
/**
* Functions below are used inside compiled validations function
*/
var co = require('' co '');
var ucs2length = util.ucs2length;
var equal = require('' fast - deep - equal '');
// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;
/**
* Compiles schema to validation function
* @this   Ajv
* @param  {Object} schema schema object
* @param  {Object} root object with information about the root schema for this schema
* @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
* @param  {String} baseId base ID for IDs in the schema
* @return {Function} validation function
*/
function compile(schema, root, localRefs, baseId) {
/* jshint validthis: true, evil: true */
/* eslint no-shadow: 0 */
var self = this
, opts = this._opts
, refVal = [ undefined ]
, refs = {}
, patterns = []
, patternsHash = {}
, defaults = []
, defaultsHash = {}
, customRules = [];
root = root || { schema: schema, refVal: refVal, refs: refs };
var c = checkCompiling.call(this, schema, root, baseId);
var compilation = this._compilations[c.index];
if (c.compiling) return (compilation.callValidate = callValidate);
var formats = this._formats;
var RULES = this.RULES;
try {
var v = localCompile(schema, root, localRefs, baseId);
compilation.validate = v;
var cv = compilation.callValidate;
if (cv) {
cv.schema = v.schema;
cv.errors = null;
cv.refs = v.refs;
cv.refVal = v.refVal;
cv.root = v.root;
cv.$async = v.$async;
if (opts.sourceCode) cv.source = v.source;
}
return v;
} finally {
endCompiling.call(this, schema, root, baseId);
}
function callValidate() {
var validate = compilation.validate;
var result = validate.apply(null, arguments);
callValidate.errors = validate.errors;
return result;
}
function localCompile(_schema, _root, localRefs, baseId) {
var isRoot = !_root || (_root && _root.schema == _schema);
if (_root.schema != root.schema)
return compile.call(self, _schema, _root, localRefs, baseId);
var $async = _schema.$async === true;
var sourceCode = validateGenerator({
isTop: true,
schema: _schema,
isRoot: isRoot,
baseId: baseId,
root: _root,
schemaPath: '''',
errSchemaPath: '' # '',
errorPath: '' \\"\\" '',
MissingRefError: errorClasses.MissingRef,
RULES: RULES,
validate: validateGenerator,
util: util,
resolve: resolve,
resolveRef: resolveRef,
usePattern: usePattern,
useDefault: useDefault,
useCustomRule: useCustomRule,
opts: opts,
formats: formats,
self: self
});
sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
+ vars(defaults, defaultCode) + vars(customRules, customRuleCode)
+ sourceCode;
if (opts.processCode) sourceCode = opts.processCode(sourceCode);
// console.log('' n n n * * * n '', JSON.stringify(sourceCode));
var validate;
try {
var makeValidate = new Function(
'' self '',
'' RULES '',
'' formats '',
'' root '',
'' refVal '',
'' defaults '',
'' customRules '',
'' co '',
'' equal '',
'' ucs2length '',
'' ValidationError '',
sourceCode
);
validate = makeValidate(
self,
RULES,
formats,
root,
refVal,
defaults,
customRules,
co,
equal,
ucs2length,
ValidationError
);
refVal[0] = validate;
} catch(e) {
console.error('' Error compiling SCHEMA, FUNCTION code: '', sourceCode);
throw e;
}
validate.schema = _schema;
validate.errors = null;
validate.refs = refs;
validate.refVal = refVal;
validate.root = isRoot ? validate : _root;
if ($async) validate.$async = true;
if (opts.sourceCode === true) {
validate.source = {
code: sourceCode,
patterns: patterns,
defaults: defaults
};
}
return validate;
}
function resolveRef(baseId, ref, isRoot) {
ref = resolve.url(baseId, ref);
var refIndex = refs[ref];
var _refVal, refCode;
if (refIndex !== undefined) {
_refVal = refVal[refIndex];
refCode = '' refVal['' + refIndex + ''] '';
return resolvedRef(_refVal, refCode);
}
if (!isRoot && root.refs) {
var rootRefId = root.refs[ref];
if (rootRefId !== undefined) {
_refVal = root.refVal[rootRefId];
refCode = addLocalRef(ref, _refVal);
return resolvedRef(_refVal, refCode);
}
}
refCode = addLocalRef(ref);
var v = resolve.call(self, localCompile, root, ref);
if (v === undefined) {
var localSchema = localRefs && localRefs[ref];
if (localSchema) {
v = resolve.inlineRef(localSchema, opts.inlineRefs)
? localSchema
: compile.call(self, localSchema, root, localRefs, baseId);
}
}
if (v === undefined) {
removeLocalRef(ref);
} else {
replaceLocalRef(ref, v);
return resolvedRef(v, refCode);
}
}
function addLocalRef(ref, v) {
var refId = refVal.length;
refVal[refId] = v;
refs[ref] = refId;
return '' refVal '' + refId;
}
function removeLocalRef(ref) {
delete refs[ref];
}
function replaceLocalRef(ref, v) {
var refId = refs[ref];
refVal[refId] = v;
}
function resolvedRef(refVal, code) {
return typeof refVal == '' object '' || typeof refVal == '' boolean ''
? { code: code, schema: refVal, inline: true }
: { code: code, $async: refVal && refVal.$async };
}
function usePattern(regexStr) {
var index = patternsHash[regexStr];
if (index === undefined) {
index = patternsHash[regexStr] = patterns.length;
patterns[index] = regexStr;
}
return '' pattern '' + index;
}
function useDefault(value) {
switch (typeof value) {
case '' boolean '':
case '' number '':
return '''' + value;
case '' string '':
return util.toQuotedString(value);
case '' object '':
if (value === null) return '' NULL '';
var valueStr = stableStringify(value);
var index = defaultsHash[valueStr];
if (index === undefined) {
index = defaultsHash[valueStr] = defaults.length;
defaults[index] = value;
}
return '' DEFAULT '' + index;
}
}
function useCustomRule(rule, schema, parentSchema, it) {
var validateSchema = rule.definition.validateSchema;
if (validateSchema && self._opts.validateSchema !== false) {
var valid = validateSchema(schema);
if (!valid) {
var message = '' keyword SCHEMA IS invalid: '' + self.errorsText(validateSchema.errors);
if (self._opts.validateSchema == '' log '') console.error(message);
else throw new Error(message);
}
}
var compile = rule.definition.compile
, inline = rule.definition.inline
, macro = rule.definition.macro;
var validate;
if (compile) {
validate = compile.call(self, schema, parentSchema, it);
} else if (macro) {
validate = macro.call(self, schema, parentSchema, it);
if (opts.validateSchema !== false) self.validateSchema(validate, true);
} else if (inline) {
validate = inline.call(self, it, rule.keyword, schema, parentSchema);
} else {
validate = rule.definition.validate;
if (!validate) return;
}
if (validate === undefined)
throw new Error('' custom keyword \\"'' + rule.keyword + ''\\" failed TO compile '');
var index = customRules.length;
customRules[index] = validate;
return {
code: '' customRule '' + index,
validate: validate
};
}
}
/**
* Checks if the schema is currently compiled
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Object} object with properties \\"index\\" (compilation index) and \\"compiling\\" (boolean)
*/
function checkCompiling(schema, root, baseId) {
/* jshint validthis: true */
var index = compIndex.call(this, schema, root, baseId);
if (index >= 0) return { index: index, compiling: true };
index = this._compilations.length;
this._compilations[index] = {
schema: schema,
root: root,
baseId: baseId
};
return { index: index, compiling: false };
}
/**
* Removes the schema from the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
*/
function endCompiling(schema, root, baseId) {
/* jshint validthis: true */
var i = compIndex.call(this, schema, root, baseId);
if (i >= 0) this._compilations.splice(i, 1);
}
/**
* Index of schema compilation in the currently compiled list
* @this   Ajv
* @param  {Object} schema schema to compile
* @param  {Object} root root object
* @param  {String} baseId base schema ID
* @return {Integer} compilation index
*/
function compIndex(schema, root, baseId) {
/* jshint validthis: true */
for (var i=0; i<this._compilations.length; i++) {
var c = this._compilations[i];
if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
}
return -1;
}
function patternCode(i, patterns) {
return '' var pattern '' + i + '' = new RegExp ('' + util.toQuotedString(patterns[i]) + ''); '';
}
function defaultCode(i) {
return '' var DEFAULT '' + i + '' = defaults['' + i + '']; '';
}
function refValCode(i, refVal) {
return refVal[i] === undefined ? '''' : '' var refVal '' + i + '' = refVal['' + i + '']; '';
}
function customRuleCode(i) {
return '' var customRule '' + i + '' = customRules['' + i + '']; '';
}
function vars(arr, statement) {
if (!arr.length) return '''';
var code = '''';
for (var i=0; i<arr.length; i++)
code += statement(i, arr);
return code;
}
},{\\"../dotjs/validate\\":43,\\"./error_classes\\":13,\\"./resolve\\":16,\\"./util\\":20,\\"co\\":48,\\"fast-deep-equal\\":49,\\"json-stable-stringify\\":51}],16:[function(require,module,exports){
'' use STRICT '';
var url = require('' url '')
, equal = require('' fast - deep - equal '')
, util = require(''./ util '')
, SchemaObject = require(''./ schema_obj '')
, traverse = require('' json - SCHEMA - traverse '');
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
* [resolve and compile the references ($ref)]
* @this   Ajv
* @param  {Function} compile reference to schema compilation funciton (localCompile)
* @param  {Object} root object with information about the root schema for the current schema
* @param  {String} ref reference to resolve
* @return {Object|Function} schema object (if the schema can be inlined) or validation function
*/
function resolve(compile, root, ref) {
/* jshint validthis: true */
var refVal = this._refs[ref];
if (typeof refVal == '' string '') {
if (this._refs[refVal]) refVal = this._refs[refVal];
else return resolve.call(this, compile, root, refVal);
}
refVal = refVal || this._schemas[ref];
if (refVal instanceof SchemaObject) {
return inlineRef(refVal.schema, this._opts.inlineRefs)
? refVal.schema
: refVal.validate || this._compile(refVal);
}
var res = resolveSchema.call(this, root, ref);
var schema, v, baseId;
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
if (schema instanceof SchemaObject) {
v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
} else if (schema !== undefined) {
v = inlineRef(schema, this._opts.inlineRefs)
? schema
: compile.call(this, schema, root, undefined, baseId);
}
return v;
}
/**
* Resolve schema, its root and baseId
* @this Ajv
* @param  {Object} root root object with properties schema, refVal, refs
* @param  {String} ref  reference to resolve
* @return {Object} object with properties schema, root, baseId
*/
function resolveSchema(root, ref) {
/* jshint validthis: true */
var p = url.parse(ref, false, true)
, refPath = _getFullPath(p)
, baseId = getFullPath(this._getId(root.schema));
if (refPath !== baseId) {
var id = normalizeId(refPath);
var refVal = this._refs[id];
if (typeof refVal == '' string '') {
return resolveRecursive.call(this, root, refVal, p);
} else if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
root = refVal;
} else {
refVal = this._schemas[id];
if (refVal instanceof SchemaObject) {
if (!refVal.validate) this._compile(refVal);
if (id == normalizeId(ref))
return { schema: refVal, root: root, baseId: baseId };
root = refVal;
} else {
return;
}
}
if (!root.schema) return;
baseId = getFullPath(this._getId(root.schema));
}
return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
/* jshint validthis: true */
var res = resolveSchema.call(this, root, ref);
if (res) {
var schema = res.schema;
var baseId = res.baseId;
root = res.root;
var id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
return getJsonPointer.call(this, parsedRef, baseId, schema, root);
}
}
var PREVENT_SCOPE_CHANGE = util.toHash(['' properties '', '' patternProperties '', '' enum '', '' dependencies '', '' definitions '']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
/* jshint validthis: true */
parsedRef.hash = parsedRef.hash || '''';
if (parsedRef.hash.slice(0,2) != '' # / '') return;
var parts = parsedRef.hash.split('' / '');
for (var i = 1; i < parts.length; i++) {
var part = parts[i];
if (part) {
part = util.unescapeFragment(part);
schema = schema[part];
if (schema === undefined) break;
var id;
if (!PREVENT_SCOPE_CHANGE[part]) {
id = this._getId(schema);
if (id) baseId = resolveUrl(baseId, id);
if (schema.$ref) {
var $ref = resolveUrl(baseId, schema.$ref);
var res = resolveSchema.call(this, root, $ref);
if (res) {
schema = res.schema;
root = res.root;
baseId = res.baseId;
}
}
}
}
}
if (schema !== undefined && schema !== root.schema)
return { schema: schema, root: root, baseId: baseId };
}
var SIMPLE_INLINED = util.toHash([
'' TYPE '', '' format '', '' pattern '',
'' maxLength '', '' minLength '',
'' maxProperties '', '' minProperties '',
'' maxItems '', '' minItems '',
'' maximum '', '' minimum '',
'' uniqueItems '', '' multipleOf '',
'' required '', '' enum ''
]);
function inlineRef(schema, limit) {
if (limit === false) return false;
if (limit === undefined || limit === true) return checkNoRef(schema);
else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
var item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return false;
item = schema[key];
if (typeof item == '' object '' && !checkNoRef(item)) return false;
}
}
return true;
}
function countKeys(schema) {
var count = 0, item;
if (Array.isArray(schema)) {
for (var i=0; i<schema.length; i++) {
item = schema[i];
if (typeof item == '' object '') count += countKeys(item);
if (count == Infinity) return Infinity;
}
} else {
for (var key in schema) {
if (key == '' $ ref '') return Infinity;
if (SIMPLE_INLINED[key]) {
count++;
} else {
item = schema[key];
if (typeof item == '' object '') count += countKeys(item) + 1;
if (count == Infinity) return Infinity;
}
}
}
return count;
}
function getFullPath(id, normalize) {
if (normalize !== false) id = normalizeId(id);
var p = url.parse(id, false, true);
return _getFullPath(p);
}
function _getFullPath(p) {
var protocolSeparator = p.protocol || p.href.slice(0,2) == '' / / '' ? '' / / '' : '''';
return (p.protocol||'''') + protocolSeparator + (p.host||'''') + (p.path||'''')  + '' # '';
}
var TRAILING_SLASH_HASH = /#\\\\/?$/;
function normalizeId(id) {
return id ? id.replace(TRAILING_SLASH_HASH, '''') : '''';
}
function resolveUrl(baseId, id) {
id = normalizeId(id);
return url.resolve(baseId, id);
}
/* @this Ajv */
function resolveIds(schema) {
var schemaId = normalizeId(this._getId(schema));
var baseIds = {'''': schemaId};
var fullPaths = {'''': getFullPath(schemaId, false)};
var localRefs = {};
var self = this;
traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (jsonPtr === '''') return;
var id = self._getId(sch);
var baseId = baseIds[parentJsonPtr];
var fullPath = fullPaths[parentJsonPtr] + '' / '' + parentKeyword;
if (keyIndex !== undefined)
fullPath += '' / '' + (typeof keyIndex == '' number '' ? keyIndex : util.escapeFragment(keyIndex));
if (typeof id == '' string '') {
id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);
var refVal = self._refs[id];
if (typeof refVal == '' string '') refVal = self._refs[refVal];
if (refVal && refVal.schema) {
if (!equal(sch, refVal.schema))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
} else if (id != normalizeId(fullPath)) {
if (id[0] == '' # '') {
if (localRefs[id] && !equal(sch, localRefs[id]))
throw new Error('' id \\"'' + id + ''\\" resolves TO more than one SCHEMA '');
localRefs[id] = sch;
} else {
self._refs[id] = fullPath;
}
}
}
baseIds[jsonPtr] = baseId;
fullPaths[jsonPtr] = fullPath;
});
return localRefs;
}
},{\\"./schema_obj\\":18,\\"./util\\":20,\\"fast-deep-equal\\":49,\\"json-schema-traverse\\":50,\\"url\\":5}],17:[function(require,module,exports){
'' use STRICT '';
var ruleModules = require(''./ _rules '')
, toHash = require(''./ util '').toHash;
module.exports = function rules() {
var RULES = [
{ type: '' number '',
rules: [ { '' maximum '': ['' exclusiveMaximum ''] },
{ '' minimum '': ['' exclusiveMinimum ''] }, '' multipleOf '', '' format ''] },
{ type: '' string '',
rules: [ '' maxLength '', '' minLength '', '' pattern '', '' format '' ] },
{ type: '' ARRAY '',
rules: [ '' maxItems '', '' minItems '', '' uniqueItems '', '' contains '', '' items '' ] },
{ type: '' object '',
rules: [ '' maxProperties '', '' minProperties '', '' required '', '' dependencies '', '' propertyNames '',
{ '' properties '': ['' additionalProperties '', '' patternProperties ''] } ] },
{ rules: [ '' $ ref '', '' const '', '' enum '', '' NOT '', '' anyOf '', '' oneOf '', '' allOf '' ] }
];
var ALL = [ '' TYPE '' ];
var KEYWORDS = [
'' additionalItems '', '' $ SCHEMA '', '' id '', '' title '',
'' description '', '' DEFAULT '', '' definitions ''
];
var TYPES = [ '' number '', '' integer '', '' string '', '' ARRAY '', '' object '', '' boolean '', '' NULL '' ];
RULES.all = toHash(ALL);
RULES.types = toHash(TYPES);
RULES.forEach(function (group) {
group.rules = group.rules.map(function (keyword) {
var implKeywords;
if (typeof keyword == '' object '') {
var key = Object.keys(keyword)[0];
implKeywords = keyword[key];
keyword = key;
implKeywords.forEach(function (k) {
ALL.push(k);
RULES.all[k] = true;
});
}
ALL.push(keyword);
var rule = RULES.all[keyword] = {
keyword: keyword,
code: ruleModules[keyword],
implements: implKeywords
};
return rule;
});
if (group.type) RULES.types[group.type] = group;
});
RULES.keywords = toHash(ALL.concat(KEYWORDS));
RULES.custom = {};
return RULES;
};
},{\\"./_rules\\":11,\\"./util\\":20}],18:[function(require,module,exports){
'' use STRICT '';
var util = require(''./ util '');
module.exports = SchemaObject;
function SchemaObject(obj) {
util.copy(obj, this);
}
},{\\"./util\\":20}],19:[function(require,module,exports){
'' use STRICT '';
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
var length = 0
, len = str.length
, pos = 0
, value;
while (pos < len) {
length++;
value = str.charCodeAt(pos++);
if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
// high surrogate, and there is a next character
value = str.charCodeAt(pos);
if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
}
}
return length;
};
},{}],20:[function(require,module,exports){
'' use STRICT '';
module.exports = {
copy: copy,
checkDataType: checkDataType,
checkDataTypes: checkDataTypes,
coerceToTypes: coerceToTypes,
toHash: toHash,
getProperty: getProperty,
escapeQuotes: escapeQuotes,
equal: require('' fast - deep - equal ''),
ucs2length: require(''./ ucs2length ''),
varOccurences: varOccurences,
varReplace: varReplace,
cleanUpCode: cleanUpCode,
finalCleanUpCode: finalCleanUpCode,
schemaHasRules: schemaHasRules,
schemaHasRulesExcept: schemaHasRulesExcept,
toQuotedString: toQuotedString,
getPathExpr: getPathExpr,
getPath: getPath,
getData: getData,
unescapeFragment: unescapeFragment,
unescapeJsonPointer: unescapeJsonPointer,
escapeFragment: escapeFragment,
escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
to = to || {};
for (var key in o) to[key] = o[key];
return to;
}
function checkDataType(dataType, data, negate) {
var EQUAL = negate ? '' != = '' : '' == = ''
, AND = negate ? '' || '' : '' && ''
, OK = negate ? '' ! '' : ''''
, NOT = negate ? '''' : '' ! '';
switch (dataType) {
case '' NULL '': return data + EQUAL + '' NULL '';
case '' ARRAY '': return OK + '' Array.isArray ('' + data + '') '';
case '' object '': return '' ('' + OK + data + AND +
'' typeof '' + data + EQUAL + '' \\"object\\" '' + AND +
NOT + '' Array.isArray ('' + data + '')) '';
case '' integer '': return '' (typeof '' + data + EQUAL + '' \\"number\\" '' + AND +
NOT + '' ('' + data + '' % 1) '' +
AND + data + EQUAL + data + '') '';
default: return '' typeof '' + data + EQUAL + '' \\"'' + dataType + ''\\" '';
}
}
function checkDataTypes(dataTypes, data) {
switch (dataTypes.length) {
case 1: return checkDataType(dataTypes[0], data, true);
default:
var code = '''';
var types = toHash(dataTypes);
if (types.array && types.object) {
code = types.null ? '' ('': '' (! '' + data + '' || '';
code += '' typeof '' + data + '' != = \\"object\\") '';
delete types.null;
delete types.array;
delete types.object;
}
if (types.number) delete types.integer;
for (var t in types)
code += (code ? '' && '' : '''' ) + checkDataType(t, data, true);
return code;
}
}
var COERCE_TO_TYPES = toHash([ '' string '', '' number '', '' integer '', '' boolean '', '' NULL '' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
if (Array.isArray(dataTypes)) {
var types = [];
for (var i=0; i<dataTypes.length; i++) {
var t = dataTypes[i];
if (COERCE_TO_TYPES[t]) types[types.length] = t;
else if (optionCoerceTypes === '' ARRAY '' && t === '' ARRAY '') types[types.length] = t;
}
if (types.length) return types;
} else if (COERCE_TO_TYPES[dataTypes]) {
return [dataTypes];
} else if (optionCoerceTypes === '' ARRAY '' && dataTypes === '' ARRAY '') {
return ['' ARRAY ''];
}
}
function toHash(arr) {
var hash = {};
for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'' | \\\\\\\\ / g; FUNCTION getProperty (KEY) { RETURN typeof KEY == ''number'' ? ''['' + KEY + '']'' : IDENTIFIER.test (KEY) ? ''.'' + KEY :\\"[''\\" + escapeQuotes (KEY) + \\"'']\\"; } FUNCTION escapeQuotes (str) { RETURN str.replace(SINGLE_QUOTE, ''\\\\\\\\$&'').replace(/ n / g, ''\\\\\\\\n'').replace(/ r / g, ''\\\\\\\\r'').replace(/ f / g, ''\\\\\\\\f'').replace(/ t / g, ''\\\\\\\\t''); } FUNCTION varOccurences (str, dataVar) { dataVar + = ''[^0-9]''; var matches = str.match (new RegExp (dataVar, ''g'')); RETURN matches ? matches.length : 0; } FUNCTION varReplace (str, dataVar, expr) { dataVar + = ''([^0-9])''; expr = expr.replace(/ $ / g, ''$$$$''); RETURN str.replace(new RegExp (dataVar, ''g''), expr + ''$1''); } var EMPTY_ELSE = /
ELSE
s * { s * } / g, EMPTY_IF_NO_ELSE = / IF s * ([^)] +) s * { s * }(?! s *
ELSE
) / g, EMPTY_IF_WITH_ELSE = / IF s * (([^)] +)) s * { s * } s *
ELSE
(? ! s * IF) / g; FUNCTION cleanUpCode (out) { RETURN out.replace(EMPTY_ELSE, '''').replace(EMPTY_IF_NO_ELSE, '''').replace(EMPTY_IF_WITH_ELSE, ''if (!($1))''); } var ERRORS_REGEXP = /[^ v.] errors / g, REMOVE_ERRORS = / var errors = 0; | var vErrors = NULL; | validate.errors = vErrors; / g, REMOVE_ERRORS_ASYNC = / var errors = 0; | var vErrors = NULL; / g, RETURN_VALID = ''return errors === 0;'', RETURN_TRUE = ''validate.errors = null; return true;'', RETURN_ASYNC = / IF (errors == = 0)
RETURN data; s *
ELSE
throw new ValidationError (vErrors); /, RETURN_DATA_ASYNC = ''return data;'', ROOTDATA_REGEXP = /[^ A - Za - z_$] rootData[^ A - Za - z0 - 9_$] / g, REMOVE_ROOTDATA = / IF (rootData == = undefined) rootData = data; /; FUNCTION finalCleanUpCode (out, async) { var matches = out.match (ERRORS_REGEXP); IF (matches && matches.length == 2) { out = async ? out.replace(REMOVE_ERRORS_ASYNC, '''').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '''').replace(RETURN_VALID, RETURN_TRUE); } matches = out.match (ROOTDATA_REGEXP); IF (! matches || matches.length != = 3)
RETURN out; RETURN out.replace(REMOVE_ROOTDATA, ''''); } FUNCTION schemaHasRules (SCHEMA, rules) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA; FOR (var KEY IN SCHEMA)
IF (rules[KEY])
RETURN TRUE; } FUNCTION schemaHasRulesExcept (SCHEMA, rules, exceptKeyword) { IF (typeof SCHEMA == ''boolean'')
RETURN ! SCHEMA && exceptKeyword != ''not''; FOR (var KEY IN SCHEMA)
IF (KEY != exceptKeyword && rules[KEY])
RETURN TRUE; } FUNCTION toQuotedString (str) { RETURN ''\\\\'''' + escapeQuotes (str) + ''\\\\''''; } FUNCTION getPathExpr (currentPath, expr, jsonPointers, isNumber) { var path = jsonPointers / / FALSE BY DEFAULT ? ''\\\\''/\\\\'' + '' + expr + (isNumber ? '''' :''.replace(/~/g, \\\\''~0\\\\'').replace(/\\\\\\\\//g, \\\\''~1\\\\'')'') : (isNumber ? ''\\\\''[\\\\'' + '' + expr + '' + \\\\'']\\\\'''' :''\\\\''[\\\\\\\\\\\\''\\\\'' + '' + expr + '' + \\\\''\\\\\\\\\\\\'']\\\\''''); RETURN joinPaths (currentPath, path); } FUNCTION getPath (currentPath, prop, jsonPointers) { var path = jsonPointers / / FALSE BY DEFAULT ? toQuotedString (''/'' + escapeJsonPointer (prop)) : toQuotedString (getProperty (prop)); RETURN joinPaths (currentPath, path); } var JSON_POINTER = / ^ / (? :[^ ~] | ~ 0 | ~ 1) * $ /; var RELATIVE_JSON_POINTER = / ^ ([0 - 9] +) (# | / (? :[^ ~] | ~ 0 | ~ 1) *) ? $ /; FUNCTION getData ($ data, lvl, paths) { var up, jsonPointer, data, matches; IF ($ data == = '''')
RETURN ''rootData''; IF ($ data[0] == ''/'') { IF (! JSON_POINTER.test ($ data)) throw new Error (''Invalid JSON-pointer: '' + $ data); jsonPointer = $ data; data = ''rootData''; }
ELSE
{ matches = $ data.match (RELATIVE_JSON_POINTER); IF (! matches) throw new Error (''Invalid JSON-pointer: '' + $ data); up = + matches[1]; jsonPointer = matches[2]; IF (jsonPointer == ''#'') { IF (up >= lvl) throw new Error (''Cannot access property/index '' + up + '' levels up, current level is '' + lvl); RETURN paths[lvl - up]; } IF (up > lvl) throw new Error (''Cannot access data '' + up + '' levels up, current level is '' + lvl); data = ''data'' + ((lvl - up) || ''''); IF (! jsonPointer)
RETURN data; } var expr = data; var segments = jsonPointer.split (''/''); FOR (var i = 0; i < segments.length; i + +) { var segment = segments[i]; IF (segment) { data + = getProperty (unescapeJsonPointer (segment)); expr + = '' && '' + data; } } RETURN expr; } FUNCTION joinPaths (a, b) { IF (a == ''\\"\\"'')
RETURN b; RETURN (a + '' + '' + b).replace(/ '' \\\\+ '' / g, ''''); } FUNCTION unescapeFragment (str) { RETURN unescapeJsonPointer (decodeURIComponent (str)); } FUNCTION escapeFragment (str) { RETURN encodeURIComponent (escapeJsonPointer (str)); } FUNCTION escapeJsonPointer (str) { RETURN str.replace(/ ~ / g, ''~0'').replace(/ / / g, ''~1''); } FUNCTION unescapeJsonPointer (str) { RETURN str.replace(/ ~ 1 / g, ''/'').replace(/ ~ 0 / g, ''~''); } }, {\\". / ucs2length \\":19,\\" fast - deep - equal \\":49}],21:[function(require,module,exports){
''use strict'';
module.exports = function generate__limit(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $isMax = $keyword == ''maximum'',
$exclusiveKeyword = $isMax ? ''exclusiveMaximum'' : ''exclusiveMinimum'',
$schemaExcl = it.schema[$exclusiveKeyword],
$isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
$op = $isMax ? ''<'' : ''>'',
$notOp = $isMax ? ''>'' : ''<'',
$errorKeyword = undefined;
if ($isDataExcl) {
var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
$exclusive = ''exclusive'' + $lvl,
$exclType = ''exclType'' + $lvl,
$exclIsNumber = ''exclIsNumber'' + $lvl,
$opExpr = ''op'' + $lvl,
$opStr = ''\\\\'' + '' + $opExpr + '' + \\\\'''';
out += '' var schemaExcl'' + ($lvl) + '' = '' + ($schemaValueExcl) + ''; '';
$schemaValueExcl = ''schemaExcl'' + $lvl;
out += '' var '' + ($exclusive) + ''; var '' + ($exclType) + '' = typeof '' + ($schemaValueExcl) + ''; if ('' + ($exclType) + '' != \\\\''boolean\\\\'' && '' + ($exclType) + '' != \\\\''undefined\\\\'' && '' + ($exclType) + '' != \\\\''number\\\\'') { '';
var $errorKeyword = $exclusiveKeyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_exclusiveLimit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''' + ($exclusiveKeyword) + '' should be boolean\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($exclType) + '' == \\\\''number\\\\'' ? (('' + ($exclusive) + '' = '' + ($schemaValue) + '' === undefined || '' + ($schemaValueExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '') ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValueExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) : (('' + ($exclusive) + '' = '' + ($schemaValueExcl) + '' === true) ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaValue) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { var op'' + ($lvl) + '' = '' + ($exclusive) + '' ? \\\\'''' + ($op) + ''\\\\'' : \\\\'''' + ($op) + ''=\\\\'';'';
} else {
var $exclIsNumber = typeof $schemaExcl == ''number'',
$opStr = $op;
if ($exclIsNumber && $isData) {
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' ( '' + ($schemaValue) + '' === undefined || '' + ($schemaExcl) + '' '' + ($op) + ''= '' + ($schemaValue) + '' ? '' + ($data) + '' '' + ($notOp) + ''= '' + ($schemaExcl) + '' : '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' ) || '' + ($data) + '' !== '' + ($data) + '') { '';
} else {
if ($exclIsNumber && $schema === undefined) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$schemaValue = $schemaExcl;
$notOp += ''='';
} else {
if ($exclIsNumber) $schemaValue = Math[$isMax ? ''min'' : ''max'']($schemaExcl, $schema);
if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
$exclusive = true;
$errorKeyword = $exclusiveKeyword;
$errSchemaPath = it.errSchemaPath + ''/'' + $exclusiveKeyword;
$notOp += ''='';
} else {
$exclusive = false;
$opStr += ''='';
}
}
var $opExpr = ''\\\\'''' + $opStr + ''\\\\'''';
out += '' if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + '' '' + ($notOp) + '' '' + ($schemaValue) + '' || '' + ($data) + '' !== '' + ($data) + '') { '';
}
}
$errorKeyword = $errorKeyword || $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limit'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { comparison: '' + ($opExpr) + '', limit: '' + ($schemaValue) + '', exclusive: '' + ($exclusive) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '' + ($opStr) + '' '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],22:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxItems'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' '' + ($data) + ''.length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxItems'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],23:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitLength(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxLength'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
if (it.opts.unicode === false) {
out += '' '' + ($data) + ''.length '';
} else {
out += '' ucs2length('' + ($data) + '') '';
}
out += '' '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitLength'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be '';
if ($keyword == ''maxLength'') {
out += ''longer'';
} else {
out += ''shorter'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' characters\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],24:[function(require,module,exports){
''use strict'';
module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $op = $keyword == ''maxProperties'' ? ''>'' : ''<'';
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''number\\\\'') || '';
}
out += '' Object.keys('' + ($data) + '').length '' + ($op) + '' '' + ($schemaValue) + '') { '';
var $errorKeyword = $keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''_limitProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '';
if ($keyword == ''maxProperties'') {
out += ''more'';
} else {
out += ''less'';
}
out += '' than '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue) + '' + \\\\'''';
} else {
out += '''' + ($schema);
}
out += '' properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],25:[function(require,module,exports){
''use strict'';
module.exports = function generate_allOf(it, $keyword, $ruleType) {
var out = '' '';
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $currentBaseId = $it.baseId,
$allSchemasEmpty = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$allSchemasEmpty = false;
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($breakOnError) {
if ($allSchemasEmpty) {
out += '' if (true) { '';
} else {
out += '' '' + ($closingBraces.slice(0, -1)) + '' '';
}
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],26:[function(require,module,exports){
''use strict'';
module.exports = function generate_anyOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $noEmptySchema = $schema.every(function($sch) {
return it.util.schemaHasRules($sch, it.RULES.all);
});
if ($noEmptySchema) {
var $currentBaseId = $it.baseId;
out += '' var '' + ($errs) + '' = errors; var '' + ($valid) + '' = false;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' '' + ($valid) + '' = '' + ($valid) + '' || '' + ($nextValid) + ''; if (!'' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''anyOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match some schema in anyOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],27:[function(require,module,exports){
''use strict'';
module.exports = function generate_const(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (!$isData) {
out += '' var schema'' + ($lvl) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '' = equal('' + ($data) + '', schema'' + ($lvl) + ''); if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''const'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to constant\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],28:[function(require,module,exports){
''use strict'';
module.exports = function generate_contains(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId,
$nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($nonEmptySchema) {
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($nextValid) + '' = false; for (var '' + ($idx) + '' = 0; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if ('' + ($nextValid) + '') break; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($closingBraces) + '' if (!'' + ($nextValid) + '') {'';
} else {
out += '' if ('' + ($data) + ''.length == 0) {'';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''contains'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should contain a valid item\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
if ($nonEmptySchema) {
out += ''  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
}
if (it.opts.allErrors) {
out += '' } '';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],29:[function(require,module,exports){
''use strict'';
module.exports = function generate_custom(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $rule = this,
$definition = ''definition'' + $lvl,
$rDef = $rule.definition,
$closingBraces = '''';
var $compile, $inline, $macro, $ruleValidate, $validateCode;
if ($isData && $rDef.$data) {
$validateCode = ''keywordValidate'' + $lvl;
var $validateSchema = $rDef.validateSchema;
out += '' var '' + ($definition) + '' = RULES.custom[\\\\'''' + ($keyword) + ''\\\\''].definition; var '' + ($validateCode) + '' = '' + ($definition) + ''.validate;'';
} else {
$ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
if (!$ruleValidate) return;
$schemaValue = ''validate.schema'' + $schemaPath;
$validateCode = $ruleValidate.code;
$compile = $rDef.compile;
$inline = $rDef.inline;
$macro = $rDef.macro;
}
var $ruleErrs = $validateCode + ''.errors'',
$i = ''i'' + $lvl,
$ruleErr = ''ruleErr'' + $lvl,
$asyncKeyword = $rDef.async;
if ($asyncKeyword && !it.async) throw new Error(''async keyword in sync schema'');
if (!($inline || $macro)) {
out += '''' + ($ruleErrs) + '' = null;'';
}
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if ($isData && $rDef.$data) {
$closingBraces += ''}'';
out += '' if ('' + ($schemaValue) + '' === undefined) { '' + ($valid) + '' = true; } else { '';
if ($validateSchema) {
$closingBraces += ''}'';
out += '' '' + ($valid) + '' = '' + ($definition) + ''.validateSchema('' + ($schemaValue) + ''); if ('' + ($valid) + '') { '';
}
}
if ($inline) {
if ($rDef.statements) {
out += '' '' + ($ruleValidate.validate) + '' '';
} else {
out += '' '' + ($valid) + '' = '' + ($ruleValidate.validate) + ''; '';
}
} else if ($macro) {
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $ruleValidate.validate;
$it.schemaPath = '''';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $validateCode);
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' '' + ($code);
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
out += ''  '' + ($validateCode) + ''.call( '';
if (it.opts.passContext) {
out += ''this'';
} else {
out += ''self'';
}
if ($compile || $rDef.schema === false) {
out += '' , '' + ($data) + '' '';
} else {
out += '' , '' + ($schemaValue) + '' , '' + ($data) + '' , validate.schema'' + (it.schemaPath) + '' '';
}
out += '' , (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '' , rootData )  '';
var def_callRuleValidate = out;
out = $$outStack.pop();
if ($rDef.errors === false) {
out += '' '' + ($valid) + '' = '';
if ($asyncKeyword) {
out += '''' + (it.yieldAwait);
}
out += '''' + (def_callRuleValidate) + ''; '';
} else {
if ($asyncKeyword) {
$ruleErrs = ''customErrors'' + $lvl;
out += '' var '' + ($ruleErrs) + '' = null; try { '' + ($valid) + '' = '' + (it.yieldAwait) + (def_callRuleValidate) + ''; } catch (e) { '' + ($valid) + '' = false; if (e instanceof ValidationError) '' + ($ruleErrs) + '' = e.errors; else throw e; } '';
} else {
out += '' '' + ($ruleErrs) + '' = null; '' + ($valid) + '' = '' + (def_callRuleValidate) + ''; '';
}
}
}
if ($rDef.modifying) {
out += '' if ('' + ($parentData) + '') '' + ($data) + '' = '' + ($parentData) + ''['' + ($parentDataProperty) + ''];'';
}
out += '''' + ($closingBraces);
if ($rDef.valid) {
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
out += '' if ( '';
if ($rDef.valid === undefined) {
out += '' !'';
if ($macro) {
out += '''' + ($nextValid);
} else {
out += '''' + ($valid);
}
} else {
out += '' '' + (!$rDef.valid) + '' '';
}
out += '') { '';
$errorKeyword = $rule.keyword;
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
var def_customError = out;
out = $$outStack.pop();
if ($inline) {
if ($rDef.errors) {
if ($rDef.errors != ''full'') {
out += ''  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } '';
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if ('' + ($errs) + '' == errors) { '' + (def_customError) + '' } else {  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + ''; if ('' + ($ruleErr) + ''.schemaPath === undefined) { '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\"; } '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } '';
}
}
} else if ($macro) {
out += ''   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''custom'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { keyword: \\\\'''' + ($rule.keyword) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should pass \\" '' + ($rule.keyword) + '' \\" keyword validation\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
} else {
if ($rDef.errors === false) {
out += '' '' + (def_customError) + '' '';
} else {
out += '' if (Array.isArray('' + ($ruleErrs) + '')) { if (vErrors === null) vErrors = '' + ($ruleErrs) + ''; else vErrors = vErrors.concat('' + ($ruleErrs) + ''); errors = vErrors.length;  for (var '' + ($i) + ''='' + ($errs) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { var '' + ($ruleErr) + '' = vErrors['' + ($i) + '']; if ('' + ($ruleErr) + ''.dataPath === undefined) '' + ($ruleErr) + ''.dataPath = (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '';  '' + ($ruleErr) + ''.schemaPath = \\" '' + ($errSchemaPath) + '' \\";  '';
if (it.opts.verbose) {
out += '' '' + ($ruleErr) + ''.schema = '' + ($schemaValue) + ''; '' + ($ruleErr) + ''.data = '' + ($data) + ''; '';
}
out += '' } } else { '' + (def_customError) + '' } '';
}
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
}
return out;
}
},{}],30:[function(require,module,exports){
''use strict'';
module.exports = function generate_dependencies(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $schemaDeps = {},
$propertyDeps = {},
$ownProperties = it.opts.ownProperties;
for ($property in $schema) {
var $sch = $schema[$property];
var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
$deps[$property] = $sch;
}
out += ''var '' + ($errs) + '' = errors;'';
var $currentErrorPath = it.errorPath;
out += ''var missing'' + ($lvl) + '';'';
for (var $property in $propertyDeps) {
$deps = $propertyDeps[$property];
if ($deps.length) {
out += '' if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
if ($breakOnError) {
out += '' && ( '';
var arr1 = $deps;
if (arr1) {
var $propertyKey, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$propertyKey = arr1[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '')) {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
out += '' ) { '';
var arr2 = $deps;
if (arr2) {
var $propertyKey, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$propertyKey = arr2[i2 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''dependencies'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { property: \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'', missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'', depsCount: '' + ($deps.length) + '', deps: \\\\'''' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\\", \\"))) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should have '';
if ($deps.length == 1) {
out += ''property '' + (it.util.escapeQuotes($deps[0]));
} else {
out += ''properties '' + (it.util.escapeQuotes($deps.join(\\", \\")));
}
out += '' when property '' + (it.util.escapeQuotes($property)) + '' is present\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
out += '' }   '';
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
}
it.errorPath = $currentErrorPath;
var $currentBaseId = $it.baseId;
for (var $property in $schemaDeps) {
var $sch = $schemaDeps[$property];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ( '' + ($data) + (it.util.getProperty($property)) + '' !== undefined '';
if ($ownProperties) {
out += '' && Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($property)) + ''\\\\'') '';
}
out += '') { '';
$it.schema = $sch;
$it.schemaPath = $schemaPath + it.util.getProperty($property);
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($property);
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
if ($breakOnError) {
out += ''   '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],31:[function(require,module,exports){
''use strict'';
module.exports = function generate_enum(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $i = ''i'' + $lvl,
$vSchema = ''schema'' + $lvl;
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + '';'';
}
out += ''var '' + ($valid) + '';'';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '''' + ($valid) + '' = false;for (var '' + ($i) + ''=0; '' + ($i) + ''<'' + ($vSchema) + ''.length; '' + ($i) + ''++) if (equal('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + ''])) { '' + ($valid) + '' = true; break; }'';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''enum'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { allowedValues: schema'' + ($lvl) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be equal to one of the allowed values\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' }'';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],32:[function(require,module,exports){
''use strict'';
module.exports = function generate_format(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
if (it.opts.format === false) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $unknownFormats = it.opts.unknownFormats,
$allowUnknown = Array.isArray($unknownFormats);
if ($isData) {
var $format = ''format'' + $lvl,
$isObject = ''isObject'' + $lvl,
$formatType = ''formatType'' + $lvl;
out += '' var '' + ($format) + '' = formats['' + ($schemaValue) + '']; var '' + ($isObject) + '' = typeof '' + ($format) + '' == \\\\''object\\\\'' && !('' + ($format) + '' instanceof RegExp) && '' + ($format) + ''.validate; var '' + ($formatType) + '' = '' + ($isObject) + '' && '' + ($format) + ''.type || \\\\''string\\\\''; if ('' + ($isObject) + '') { '';
if (it.async) {
out += '' var async'' + ($lvl) + '' = '' + ($format) + ''.async; '';
}
out += '' '' + ($format) + '' = '' + ($format) + ''.validate; } if (  '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' ('';
if ($unknownFormats != ''ignore'') {
out += '' ('' + ($schemaValue) + '' && !'' + ($format) + '' '';
if ($allowUnknown) {
out += '' && self._opts.unknownFormats.indexOf('' + ($schemaValue) + '') == -1 '';
}
out += '') || '';
}
out += '' ('' + ($format) + '' && '' + ($formatType) + '' == \\\\'''' + ($ruleType) + ''\\\\'' && !(typeof '' + ($format) + '' == \\\\''function\\\\'' ? '';
if (it.async) {
out += '' (async'' + ($lvl) + '' ? '' + (it.yieldAwait) + '' '' + ($format) + ''('' + ($data) + '') : '' + ($format) + ''('' + ($data) + '')) '';
} else {
out += '' '' + ($format) + ''('' + ($data) + '') '';
}
out += '' : '' + ($format) + ''.test('' + ($data) + ''))))) {'';
} else {
var $format = it.formats[$schema];
if (!$format) {
if ($unknownFormats == ''ignore'') {
console.warn(''unknown format \\" '' + $schema + '' \\" ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
} else {
throw new Error(''unknown format \\" '' + $schema + '' \\" is used in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
var $isObject = typeof $format == ''object'' && !($format instanceof RegExp) && $format.validate;
var $formatType = $isObject && $format.type || ''string'';
if ($isObject) {
var $async = $format.async === true;
$format = $format.validate;
}
if ($formatType != $ruleType) {
if ($breakOnError) {
out += '' if (true) { '';
}
return out;
}
if ($async) {
if (!it.async) throw new Error(''async format in sync schema'');
var $formatRef = ''formats'' + it.util.getProperty($schema) + ''.validate'';
out += '' if (!('' + (it.yieldAwait) + '' '' + ($formatRef) + ''('' + ($data) + ''))) { '';
} else {
out += '' if (! '';
var $formatRef = ''formats'' + it.util.getProperty($schema);
if ($isObject) $formatRef += ''.validate'';
if (typeof $format == ''function'') {
out += '' '' + ($formatRef) + ''('' + ($data) + '') '';
} else {
out += '' '' + ($formatRef) + ''.test('' + ($data) + '') '';
}
out += '') { '';
}
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''format'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { format:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match format \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],33:[function(require,module,exports){
''use strict'';
module.exports = function generate_items(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $idx = ''i'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$currentBaseId = it.baseId;
out += ''var '' + ($errs) + '' = errors;var '' + ($valid) + '';'';
if (Array.isArray($schema)) {
var $additionalItems = it.schema.additionalItems;
if ($additionalItems === false) {
out += '' '' + ($valid) + '' = '' + ($data) + ''.length <= '' + ($schema.length) + ''; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { limit: '' + ($schema.length) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have more than '' + ($schema.length) + '' items\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
$closingBraces += ''}'';
out += '' else { '';
}
}
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($i) + '') { '';
var $passData = $data + ''['' + $i + '']'';
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
$it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
$it.dataPathArr[$dataNxt] = $i;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if (typeof $additionalItems == ''object'' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
$it.schema = $additionalItems;
$it.schemaPath = it.schemaPath + ''.additionalItems'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalItems'';
out += '' '' + ($nextValid) + '' = true; if ('' + ($data) + ''.length > '' + ($schema.length) + '') {  for (var '' + ($idx) + '' = '' + ($schema.length) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
} else if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += ''  for (var '' + ($idx) + '' = '' + (0) + ''; '' + ($idx) + '' < '' + ($data) + ''.length; '' + ($idx) + ''++) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
var $passData = $data + ''['' + $idx + '']'';
$it.dataPathArr[$dataNxt] = $idx;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],34:[function(require,module,exports){
''use strict'';
module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
out += ''var division'' + ($lvl) + '';if ('';
if ($isData) {
out += '' '' + ($schemaValue) + '' !== undefined && ( typeof '' + ($schemaValue) + '' != \\\\''number\\\\'' || '';
}
out += '' (division'' + ($lvl) + '' = '' + ($data) + '' / '' + ($schemaValue) + '', '';
if (it.opts.multipleOfPrecision) {
out += '' Math.abs(Math.round(division'' + ($lvl) + '') - division'' + ($lvl) + '') > 1e-'' + (it.opts.multipleOfPrecision) + '' '';
} else {
out += '' division'' + ($lvl) + '' !== parseInt(division'' + ($lvl) + '') '';
}
out += '' ) '';
if ($isData) {
out += ''  )  '';
}
out += '' ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''multipleOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { multipleOf: '' + ($schemaValue) + '' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be multiple of '';
if ($isData) {
out += ''\\\\'' + '' + ($schemaValue);
} else {
out += '''' + ($schemaValue) + ''\\\\'''';
}
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],35:[function(require,module,exports){
''use strict'';
module.exports = function generate_not(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.createErrors = false;
var $allErrorsOption;
if ($it.opts.allErrors) {
$allErrorsOption = $it.opts.allErrors;
$it.opts.allErrors = false;
}
out += '' '' + (it.validate($it)) + '' '';
$it.createErrors = true;
if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if ('' + ($nextValid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; } '';
if (it.opts.allErrors) {
out += '' } '';
}
} else {
out += ''  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''not'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT be valid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if ($breakOnError) {
out += '' if (false) { '';
}
}
return out;
}
},{}],36:[function(require,module,exports){
''use strict'';
module.exports = function generate_oneOf(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
out += ''var '' + ($errs) + '' = errors;var prevValid'' + ($lvl) + '' = false;var '' + ($valid) + '' = false;'';
var $currentBaseId = $it.baseId;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var arr1 = $schema;
if (arr1) {
var $sch, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$sch = arr1[$i += 1];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = $schemaPath + ''['' + $i + '']'';
$it.errSchemaPath = $errSchemaPath + ''/'' + $i;
out += ''  '' + (it.validate($it)) + '' '';
$it.baseId = $currentBaseId;
} else {
out += '' var '' + ($nextValid) + '' = true; '';
}
if ($i) {
out += '' if ('' + ($nextValid) + '' && prevValid'' + ($lvl) + '') '' + ($valid) + '' = false; else { '';
$closingBraces += ''}'';
}
out += '' if ('' + ($nextValid) + '') '' + ($valid) + '' = prevValid'' + ($lvl) + '' = true;'';
}
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '''' + ($closingBraces) + ''if (!'' + ($valid) + '') {   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''oneOf'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match exactly one schema in oneOf\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
out += ''} else {  errors = '' + ($errs) + ''; if (vErrors !== null) { if ('' + ($errs) + '') vErrors.length = '' + ($errs) + ''; else vErrors = null; }'';
if (it.opts.allErrors) {
out += '' } '';
}
return out;
}
},{}],37:[function(require,module,exports){
''use strict'';
module.exports = function generate_pattern(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $regexp = $isData ? ''(new RegExp('' + $schemaValue + ''))'' : it.usePattern($schema);
out += ''if ( '';
if ($isData) {
out += '' ('' + ($schemaValue) + '' !== undefined && typeof '' + ($schemaValue) + '' != \\\\''string\\\\'') || '';
}
out += '' !'' + ($regexp) + ''.test('' + ($data) + '') ) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''pattern'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { pattern:  '';
if ($isData) {
out += '''' + ($schemaValue);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''  } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should match pattern \\" '';
if ($isData) {
out += '' \\\\'' + '' + ($schemaValue) + '' + \\\\'' '';
} else {
out += '''' + (it.util.escapeQuotes($schema));
}
out += '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + (it.util.toQuotedString($schema));
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += ''} '';
if ($breakOnError) {
out += '' else { '';
}
return out;
}
},{}],38:[function(require,module,exports){
''use strict'';
module.exports = function generate_properties(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl;
var $schemaKeys = Object.keys($schema || {}),
$pProperties = it.schema.patternProperties || {},
$pPropertyKeys = Object.keys($pProperties),
$aProperties = it.schema.additionalProperties,
$someProperties = $schemaKeys.length || $pPropertyKeys.length,
$noAdditional = $aProperties === false,
$additionalIsSchema = typeof $aProperties == ''object'' && Object.keys($aProperties).length,
$removeAdditional = it.opts.removeAdditional,
$checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
var $required = it.schema.required;
if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
if (it.opts.patternGroups) {
var $pgProperties = it.schema.patternGroups || {},
$pgPropertyKeys = Object.keys($pgProperties);
}
out += ''var '' + ($errs) + '' = errors;var '' + ($nextValid) + '' = true;'';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined;'';
}
if ($checkAdditional) {
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
if ($someProperties) {
out += '' var isAdditional'' + ($lvl) + '' = !(false '';
if ($schemaKeys.length) {
if ($schemaKeys.length > 5) {
out += '' || validate.schema'' + ($schemaPath) + ''['' + ($key) + ''] '';
} else {
var arr1 = $schemaKeys;
if (arr1) {
var $propertyKey, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$propertyKey = arr1[i1 += 1];
out += '' || '' + ($key) + '' == '' + (it.util.toQuotedString($propertyKey)) + '' '';
}
}
}
}
if ($pPropertyKeys.length) {
var arr2 = $pPropertyKeys;
if (arr2) {
var $pProperty, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$pProperty = arr2[$i += 1];
out += '' || '' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '') '';
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr3 = $pgPropertyKeys;
if (arr3) {
var $pgProperty, $i = -1,
l3 = arr3.length - 1;
while ($i < l3) {
$pgProperty = arr3[$i += 1];
out += '' || '' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '') '';
}
}
}
out += '' ); if (isAdditional'' + ($lvl) + '') { '';
}
if ($removeAdditional == ''all'') {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
var $currentErrorPath = it.errorPath;
var $additionalProperty = ''\\\\'' + '' + $key + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
}
if ($noAdditional) {
if ($removeAdditional) {
out += '' delete '' + ($data) + ''['' + ($key) + '']; '';
} else {
out += '' '' + ($nextValid) + '' = false; '';
var $currErrSchemaPath = $errSchemaPath;
$errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''additionalProperties'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { additionalProperty: \\\\'''' + ($additionalProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have additional properties\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' break; '';
}
}
} else if ($additionalIsSchema) {
if ($removeAdditional == ''failing'') {
out += '' var '' + ($errs) + '' = errors;  '';
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
out += '' if (!'' + ($nextValid) + '') { errors = '' + ($errs) + ''; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete '' + ($data) + ''['' + ($key) + '']; }  '';
it.compositeRule = $it.compositeRule = $wasComposite;
} else {
$it.schema = $aProperties;
$it.schemaPath = it.schemaPath + ''.additionalProperties'';
$it.errSchemaPath = it.errSchemaPath + ''/additionalProperties'';
$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
}
}
it.errorPath = $currentErrorPath;
}
if ($someProperties) {
out += '' } '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
var $useDefaults = it.opts.useDefaults && !it.compositeRule;
if ($schemaKeys.length) {
var arr4 = $schemaKeys;
if (arr4) {
var $propertyKey, i4 = -1,
l4 = arr4.length - 1;
while (i4 < l4) {
$propertyKey = arr4[i4 += 1];
var $sch = $schema[$propertyKey];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
var $prop = it.util.getProperty($propertyKey),
$passData = $data + $prop,
$hasDefault = $useDefaults && $sch.default !== undefined;
$it.schema = $sch;
$it.schemaPath = $schemaPath + $prop;
$it.errSchemaPath = $errSchemaPath + ''/'' + it.util.escapeFragment($propertyKey);
$it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
$it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
$code = it.util.varReplace($code, $nextData, $passData);
var $useData = $passData;
} else {
var $useData = $nextData;
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '';
}
if ($hasDefault) {
out += '' '' + ($code) + '' '';
} else {
if ($requiredHash && $requiredHash[$propertyKey]) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = false; '';
var $currentErrorPath = it.errorPath,
$currErrSchemaPath = $errSchemaPath,
$missingProperty = it.util.escapeQuotes($propertyKey);
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
$errSchemaPath = it.errSchemaPath + ''/required'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
$errSchemaPath = $currErrSchemaPath;
it.errorPath = $currentErrorPath;
out += '' } else { '';
} else {
if ($breakOnError) {
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') { '' + ($nextValid) + '' = true; } else { '';
} else {
out += '' if ('' + ($useData) + '' !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '' ) { '';
}
}
out += '' '' + ($code) + '' } '';
}
}
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
if ($pPropertyKeys.length) {
var arr5 = $pPropertyKeys;
if (arr5) {
var $pProperty, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$pProperty = arr5[i5 += 1];
var $sch = $pProperties[$pProperty];
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternProperties'' + it.util.getProperty($pProperty);
$it.errSchemaPath = it.errSchemaPath + ''/patternProperties/'' + it.util.escapeFragment($pProperty);
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pProperty)) + ''.test('' + ($key) + '')) { '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
if (it.opts.patternGroups && $pgPropertyKeys.length) {
var arr6 = $pgPropertyKeys;
if (arr6) {
var $pgProperty, i6 = -1,
l6 = arr6.length - 1;
while (i6 < l6) {
$pgProperty = arr6[i6 += 1];
var $pgSchema = $pgProperties[$pgProperty],
$sch = $pgSchema.schema;
if (it.util.schemaHasRules($sch, it.RULES.all)) {
$it.schema = $sch;
$it.schemaPath = it.schemaPath + ''.patternGroups'' + it.util.getProperty($pgProperty) + ''.schema'';
$it.errSchemaPath = it.errSchemaPath + ''/patternGroups/'' + it.util.escapeFragment($pgProperty) + ''/schema'';
out += '' var pgPropCount'' + ($lvl) + '' = 0;  '';
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' if ('' + (it.usePattern($pgProperty)) + ''.test('' + ($key) + '')) { pgPropCount'' + ($lvl) + ''++; '';
$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
var $passData = $data + ''['' + $key + '']'';
$it.dataPathArr[$dataNxt] = $key;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
if ($breakOnError) {
out += '' if (!'' + ($nextValid) + '') break; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else '' + ($nextValid) + '' = true; '';
}
out += '' }  '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
$closingBraces += ''}'';
}
var $pgMin = $pgSchema.minimum,
$pgMax = $pgSchema.maximum;
if ($pgMin !== undefined || $pgMax !== undefined) {
out += '' var '' + ($valid) + '' = true; '';
var $currErrSchemaPath = $errSchemaPath;
if ($pgMin !== undefined) {
var $limit = $pgMin,
$reason = ''minimum'',
$moreOrLess = ''less'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' >= '' + ($pgMin) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/minimum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($pgMax !== undefined) {
out += '' else '';
}
}
if ($pgMax !== undefined) {
var $limit = $pgMax,
$reason = ''maximum'',
$moreOrLess = ''more'';
out += '' '' + ($valid) + '' = pgPropCount'' + ($lvl) + '' <= '' + ($pgMax) + ''; '';
$errSchemaPath = it.errSchemaPath + ''/patternGroups/maximum'';
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''patternGroups'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { reason: \\\\'''' + ($reason) + ''\\\\'', limit: '' + ($limit) + '', pattern: \\\\'''' + (it.util.escapeQuotes($pgProperty)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have '' + ($moreOrLess) + '' than '' + ($limit) + '' properties matching pattern \\" '' + (it.util.escapeQuotes($pgProperty)) + '' \\"\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
$errSchemaPath = $currErrSchemaPath;
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
$closingBraces += ''}'';
}
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],39:[function(require,module,exports){
''use strict'';
module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $errs = ''errs__'' + $lvl;
var $it = it.util.copy(it);
var $closingBraces = '''';
$it.level++;
var $nextValid = ''valid'' + $it.level;
if (it.util.schemaHasRules($schema, it.RULES.all)) {
$it.schema = $schema;
$it.schemaPath = $schemaPath;
$it.errSchemaPath = $errSchemaPath;
var $key = ''key'' + $lvl,
$idx = ''idx'' + $lvl,
$i = ''i'' + $lvl,
$invalidName = ''\\\\'' + '' + $key + '' + \\\\'''',
$dataNxt = $it.dataLevel = it.dataLevel + 1,
$nextData = ''data'' + $dataNxt,
$dataProperties = ''dataProperties'' + $lvl,
$ownProperties = it.opts.ownProperties,
$currentBaseId = it.baseId;
out += '' var '' + ($errs) + '' = errors; '';
if ($ownProperties) {
out += '' var '' + ($dataProperties) + '' = undefined; '';
}
if ($ownProperties) {
out += '' '' + ($dataProperties) + '' = '' + ($dataProperties) + '' || Object.keys('' + ($data) + ''); for (var '' + ($idx) + ''=0; '' + ($idx) + ''<'' + ($dataProperties) + ''.length; '' + ($idx) + ''++) { var '' + ($key) + '' = '' + ($dataProperties) + ''['' + ($idx) + '']; '';
} else {
out += '' for (var '' + ($key) + '' in '' + ($data) + '') { '';
}
out += '' var startErrs'' + ($lvl) + '' = errors; '';
var $passData = $key;
var $wasComposite = it.compositeRule;
it.compositeRule = $it.compositeRule = true;
var $code = it.validate($it);
$it.baseId = $currentBaseId;
if (it.util.varOccurences($code, $nextData) < 2) {
out += '' '' + (it.util.varReplace($code, $nextData, $passData)) + '' '';
} else {
out += '' var '' + ($nextData) + '' = '' + ($passData) + ''; '' + ($code) + '' '';
}
it.compositeRule = $it.compositeRule = $wasComposite;
out += '' if (!'' + ($nextValid) + '') { for (var '' + ($i) + ''=startErrs'' + ($lvl) + ''; '' + ($i) + ''<errors; '' + ($i) + ''++) { vErrors['' + ($i) + ''].propertyName = '' + ($key) + ''; }   var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''propertyNames'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { propertyName: \\\\'''' + ($invalidName) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''property name \\\\\\\\\\\\'''' + ($invalidName) + ''\\\\\\\\\\\\'' is invalid\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; return false; '';
}
}
if ($breakOnError) {
out += '' break; '';
}
out += '' } }'';
}
if ($breakOnError) {
out += '' '' + ($closingBraces) + '' if ('' + ($errs) + '' == errors) {'';
}
out = it.util.cleanUpCode(out);
return out;
}
},{}],40:[function(require,module,exports){
''use strict'';
module.exports = function generate_ref(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $async, $refCode;
if ($schema == ''#'' || $schema == ''#/'') {
if (it.isRoot) {
$async = it.async;
$refCode = ''validate'';
} else {
$async = it.root.schema.$async === true;
$refCode = ''root.refVal[0]'';
}
} else {
var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
if ($refVal === undefined) {
var $message = it.MissingRefError.message(it.baseId, $schema);
if (it.opts.missingRefs == ''fail'') {
console.error($message);
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''$ref'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { ref: \\\\'''' + (it.util.escapeQuotes($schema)) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''can\\\\\\\\\\\\''t resolve reference '' + (it.util.escapeQuotes($schema)) + ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: '' + (it.util.toQuotedString($schema)) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
if ($breakOnError) {
out += '' if (false) { '';
}
} else if (it.opts.missingRefs == ''ignore'') {
console.warn($message);
if ($breakOnError) {
out += '' if (true) { '';
}
} else {
throw new it.MissingRefError(it.baseId, $schema, $message);
}
} else if ($refVal.inline) {
var $it = it.util.copy(it);
$it.level++;
var $nextValid = ''valid'' + $it.level;
$it.schema = $refVal.schema;
$it.schemaPath = '''';
$it.errSchemaPath = $schema;
var $code = it.validate($it).replace(/validate\\\\.schema/g, $refVal.code);
out += '' '' + ($code) + '' '';
if ($breakOnError) {
out += '' if ('' + ($nextValid) + '') { '';
}
} else {
$async = $refVal.$async === true;
$refCode = $refVal.code;
}
}
if ($refCode) {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = '''';
if (it.opts.passContext) {
out += '' '' + ($refCode) + ''.call(this, '';
} else {
out += '' '' + ($refCode) + ''( '';
}
out += '' '' + ($data) + '', (dataPath || \\\\''\\\\'')'';
if (it.errorPath != ''\\"\\"'') {
out += '' + '' + (it.errorPath);
}
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' , '' + ($parentData) + '' , '' + ($parentDataProperty) + '', rootData)  '';
var __callValidate = out;
out = $$outStack.pop();
if ($async) {
if (!it.async) throw new Error(''async schema referenced by sync schema'');
if ($breakOnError) {
out += '' var '' + ($valid) + ''; '';
}
out += '' try { '' + (it.yieldAwait) + '' '' + (__callValidate) + ''; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = true; '';
}
out += '' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; '';
if ($breakOnError) {
out += '' '' + ($valid) + '' = false; '';
}
out += '' } '';
if ($breakOnError) {
out += '' if ('' + ($valid) + '') { '';
}
} else {
out += '' if (!'' + (__callValidate) + '') { if (vErrors === null) vErrors = '' + ($refCode) + ''.errors; else vErrors = vErrors.concat('' + ($refCode) + ''.errors); errors = vErrors.length; } '';
if ($breakOnError) {
out += '' else { '';
}
}
}
return out;
}
},{}],41:[function(require,module,exports){
''use strict'';
module.exports = function generate_required(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
var $vSchema = ''schema'' + $lvl;
if (!$isData) {
if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
var $required = [];
var arr1 = $schema;
if (arr1) {
var $property, i1 = -1,
l1 = arr1.length - 1;
while (i1 < l1) {
$property = arr1[i1 += 1];
var $propertySch = it.schema.properties[$property];
if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
$required[$required.length] = $property;
}
}
}
} else {
var $required = $schema;
}
}
if ($isData || $required.length) {
var $currentErrorPath = it.errorPath,
$loopRequired = $isData || $required.length >= it.opts.loopRequired,
$ownProperties = it.opts.ownProperties;
if ($breakOnError) {
out += '' var missing'' + ($lvl) + ''; '';
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
out += '' var '' + ($valid) + '' = true; '';
if ($isData) {
out += '' if (schema'' + ($lvl) + '' === undefined) '' + ($valid) + '' = true; else if (!Array.isArray(schema'' + ($lvl) + '')) '' + ($valid) + '' = false; else {'';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { '' + ($valid) + '' = '' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] !== undefined '';
if ($ownProperties) {
out += '' &&   Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += ''; if (!'' + ($valid) + '') break; } '';
if ($isData) {
out += ''  }  '';
}
out += ''  if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
} else {
out += '' if ( '';
var arr2 = $required;
if (arr2) {
var $propertyKey, $i = -1,
l2 = arr2.length - 1;
while ($i < l2) {
$propertyKey = arr2[$i += 1];
if ($i) {
out += '' || '';
}
var $prop = it.util.getProperty($propertyKey),
$useData = $data + $prop;
out += '' (( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') && (missing'' + ($lvl) + '' = '' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + '') ) '';
}
}
out += '') {  '';
var $propertyPath = ''missing'' + $lvl,
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + '' + '' + $propertyPath;
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else { '';
}
} else {
if ($loopRequired) {
if (!$isData) {
out += '' var '' + ($vSchema) + '' = validate.schema'' + ($schemaPath) + ''; '';
}
var $i = ''i'' + $lvl,
$propertyPath = ''schema'' + $lvl + ''['' + $i + '']'',
$missingProperty = ''\\\\'' + '' + $propertyPath + '' + \\\\'''';
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
}
if ($isData) {
out += '' if ('' + ($vSchema) + '' && !Array.isArray('' + ($vSchema) + '')) {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ('' + ($vSchema) + '' !== undefined) { '';
}
out += '' for (var '' + ($i) + '' = 0; '' + ($i) + '' < '' + ($vSchema) + ''.length; '' + ($i) + ''++) { if ('' + ($data) + ''['' + ($vSchema) + ''['' + ($i) + '']] === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', '' + ($vSchema) + ''['' + ($i) + '']) '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } '';
if ($isData) {
out += ''  }  '';
}
} else {
var arr3 = $required;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $prop = it.util.getProperty($propertyKey),
$missingProperty = it.util.escapeQuotes($propertyKey),
$useData = $data + $prop;
if (it.opts._errorDataPathProperty) {
it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
}
out += '' if ( '' + ($useData) + '' === undefined '';
if ($ownProperties) {
out += '' || ! Object.prototype.hasOwnProperty.call('' + ($data) + '', \\\\'''' + (it.util.escapeQuotes($propertyKey)) + ''\\\\'') '';
}
out += '') {  var err =   ''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''required'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { missingProperty: \\\\'''' + ($missingProperty) + ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\'''';
if (it.opts._errorDataPathProperty) {
out += ''is a required property'';
} else {
out += ''should have required property \\\\\\\\\\\\'''' + ($missingProperty) + ''\\\\\\\\\\\\'''';
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
out += '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } '';
}
}
}
}
it.errorPath = $currentErrorPath;
} else if ($breakOnError) {
out += '' if (true) {'';
}
return out;
}
},{}],42:[function(require,module,exports){
''use strict'';
module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
var out = '' '';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
var $isData = it.opts.$data && $schema && $schema.$data,
$schemaValue;
if ($isData) {
out += '' var schema'' + ($lvl) + '' = '' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + ''; '';
$schemaValue = ''schema'' + $lvl;
} else {
$schemaValue = $schema;
}
if (($schema || $isData) && it.opts.uniqueItems !== false) {
if ($isData) {
out += '' var '' + ($valid) + ''; if ('' + ($schemaValue) + '' === false || '' + ($schemaValue) + '' === undefined) '' + ($valid) + '' = true; else if (typeof '' + ($schemaValue) + '' != \\\\''boolean\\\\'') '' + ($valid) + '' = false; else { '';
}
out += '' var '' + ($valid) + '' = true; if ('' + ($data) + ''.length > 1) { var i = '' + ($data) + ''.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal('' + ($data) + ''[i], '' + ($data) + ''[j])) { '' + ($valid) + '' = false; break outer; } } } } '';
if ($isData) {
out += ''  }  '';
}
out += '' if (!'' + ($valid) + '') {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + (''uniqueItems'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { i: i, j: j } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should NOT have duplicate items (items ## \\\\'' + j + \\\\'' and \\\\'' + i + \\\\'' are identical)\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema:  '';
if ($isData) {
out += ''validate.schema'' + ($schemaPath);
} else {
out += '''' + ($schema);
}
out += ''         , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
if ($breakOnError) {
out += '' else { '';
}
} else {
if ($breakOnError) {
out += '' if (true) { '';
}
}
return out;
}
},{}],43:[function(require,module,exports){
''use strict'';
module.exports = function generate_validate(it, $keyword, $ruleType) {
var out = '''';
var $async = it.schema.$async === true,
$refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, ''$ref''),
$id = it.self._getId(it.schema);
if (it.isTop) {
if ($async) {
it.async = true;
var $es7 = it.opts.async == ''es7'';
it.yieldAwait = $es7 ? ''await'' : ''yield'';
}
out += '' var validate = '';
if ($async) {
if ($es7) {
out += '' (async function '';
} else {
if (it.opts.async != ''*'') {
out += ''co.wrap'';
}
out += ''(function* '';
}
} else {
out += '' (function '';
}
out += '' (data, dataPath, parentData, parentDataProperty, rootData) { \\\\''use strict\\\\''; '';
if ($id && (it.opts.sourceCode || it.opts.processCode)) {
out += '' '' + (''/\\\\*# sourceURL='' + $id + '' */'') + '' '';
}
}
if (typeof it.schema == ''boolean'' || !($refKeywords || it.schema.$ref)) {
var $keyword = ''false schema'';
var $lvl = it.level;
var $dataLvl = it.dataLevel;
var $schema = it.schema[$keyword];
var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
var $errSchemaPath = it.errSchemaPath + ''/'' + $keyword;
var $breakOnError = !it.opts.allErrors;
var $errorKeyword;
var $data = ''data'' + ($dataLvl || '''');
var $valid = ''valid'' + $lvl;
if (it.schema === false) {
if (it.isTop) {
$breakOnError = true;
} else {
out += '' var '' + ($valid) + '' = false; '';
}
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''false schema'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: {} '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''boolean schema is false\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: false , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
} else {
if (it.isTop) {
if ($async) {
out += '' return data; '';
} else {
out += '' validate.errors = null; return true; '';
}
} else {
out += '' var '' + ($valid) + '' = true; '';
}
}
if (it.isTop) {
out += '' }); return validate; '';
}
return out;
}
if (it.isTop) {
var $top = it.isTop,
$lvl = it.level = 0,
$dataLvl = it.dataLevel = 0,
$data = ''data'';
it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
it.baseId = it.baseId || it.rootId;
delete it.isTop;
it.dataPathArr = [undefined];
out += '' var vErrors = null; '';
out += '' var errors = 0;     '';
out += '' if (rootData === undefined) rootData = data; '';
} else {
var $lvl = it.level,
$dataLvl = it.dataLevel,
$data = ''data'' + ($dataLvl || '''');
if ($id) it.baseId = it.resolve.url(it.baseId, $id);
if ($async && !it.async) throw new Error(''async schema in sync schema'');
out += '' var errs_'' + ($lvl) + '' = errors;'';
}
var $valid = ''valid'' + $lvl,
$breakOnError = !it.opts.allErrors,
$closingBraces1 = '''',
$closingBraces2 = '''';
var $errorKeyword;
var $typeSchema = it.schema.type,
$typeIsArray = Array.isArray($typeSchema);
if ($typeIsArray && $typeSchema.length == 1) {
$typeSchema = $typeSchema[0];
$typeIsArray = false;
}
if (it.schema.$ref && $refKeywords) {
if (it.opts.extendRefs == ''fail'') {
throw new Error(''$ref: validation keywords used in schema at path \\" '' + it.errSchemaPath + '' \\" (see option extendRefs)'');
} else if (it.opts.extendRefs !== true) {
$refKeywords = false;
console.warn(''$ref: keywords ignored in schema at path \\" '' + it.errSchemaPath + '' \\"'');
}
}
if ($typeSchema) {
if (it.opts.coerceTypes) {
var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
}
var $rulesGroup = it.RULES.types[$typeSchema];
if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'',
$method = $typeIsArray ? ''checkDataTypes'' : ''checkDataType'';
out += '' if ('' + (it.util[$method]($typeSchema, $data, true)) + '') { '';
if ($coerceToTypes) {
var $dataType = ''dataType'' + $lvl,
$coerced = ''coerced'' + $lvl;
out += '' var '' + ($dataType) + '' = typeof '' + ($data) + ''; '';
if (it.opts.coerceTypes == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''object\\\\'' && Array.isArray('' + ($data) + '')) '' + ($dataType) + '' = \\\\''array\\\\''; '';
}
out += '' var '' + ($coerced) + '' = undefined; '';
var $bracesCoercion = '''';
var arr1 = $coerceToTypes;
if (arr1) {
var $type, $i = -1,
l1 = arr1.length - 1;
while ($i < l1) {
$type = arr1[$i += 1];
if ($i) {
out += '' if ('' + ($coerced) + '' === undefined) { '';
$bracesCoercion += ''}'';
}
if (it.opts.coerceTypes == ''array'' && $type != ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''array\\\\'' && '' + ($data) + ''.length == 1) { '' + ($coerced) + '' = '' + ($data) + '' = '' + ($data) + ''[0]; '' + ($dataType) + '' = typeof '' + ($data) + '';  } '';
}
if ($type == ''string'') {
out += '' if ('' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'') '' + ($coerced) + '' = \\\\''\\\\'' + '' + ($data) + ''; else if ('' + ($data) + '' === null) '' + ($coerced) + '' = \\\\''\\\\''; '';
} else if ($type == ''number'' || $type == ''integer'') {
out += '' if ('' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' === null || ('' + ($dataType) + '' == \\\\''string\\\\'' && '' + ($data) + '' && '' + ($data) + '' == +'' + ($data) + '' '';
if ($type == ''integer'') {
out += '' && !('' + ($data) + '' % 1)'';
}
out += '')) '' + ($coerced) + '' = +'' + ($data) + ''; '';
} else if ($type == ''boolean'') {
out += '' if ('' + ($data) + '' === \\\\''false\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === null) '' + ($coerced) + '' = false; else if ('' + ($data) + '' === \\\\''true\\\\'' || '' + ($data) + '' === 1) '' + ($coerced) + '' = true; '';
} else if ($type == ''null'') {
out += '' if ('' + ($data) + '' === \\\\''\\\\'' || '' + ($data) + '' === 0 || '' + ($data) + '' === false) '' + ($coerced) + '' = null; '';
} else if (it.opts.coerceTypes == ''array'' && $type == ''array'') {
out += '' if ('' + ($dataType) + '' == \\\\''string\\\\'' || '' + ($dataType) + '' == \\\\''number\\\\'' || '' + ($dataType) + '' == \\\\''boolean\\\\'' || '' + ($data) + '' == null) '' + ($coerced) + '' = ['' + ($data) + '']; '';
}
}
}
out += '' '' + ($bracesCoercion) + '' if ('' + ($coerced) + '' === undefined) {   '';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } else {  '';
var $parentData = $dataLvl ? ''data'' + (($dataLvl - 1) || '''') : ''parentData'',
$parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : ''parentDataProperty'';
out += '' '' + ($data) + '' = '' + ($coerced) + ''; '';
if (!$dataLvl) {
out += ''if ('' + ($parentData) + '' !== undefined)'';
}
out += '' '' + ($parentData) + ''['' + ($parentDataProperty) + ''] = '' + ($coerced) + ''; } '';
} else {
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
}
out += '' } '';
}
}
if (it.schema.$ref && !$refKeywords) {
out += '' '' + (it.RULES.all.$ref.code(it, ''$ref'')) + '' '';
if ($breakOnError) {
out += '' } if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
} else {
if (it.opts.v5 && it.schema.patternGroups) {
console.warn(''keyword \\" patternGroups \\" is deprecated and disabled. Use option patternGroups: true to enable.'');
}
var arr2 = it.RULES;
if (arr2) {
var $rulesGroup, i2 = -1,
l2 = arr2.length - 1;
while (i2 < l2) {
$rulesGroup = arr2[i2 += 1];
if ($shouldUseGroup($rulesGroup)) {
if ($rulesGroup.type) {
out += '' if ('' + (it.util.checkDataType($rulesGroup.type, $data)) + '') { '';
}
if (it.opts.useDefaults && !it.compositeRule) {
if ($rulesGroup.type == ''object'' && it.schema.properties) {
var $schema = it.schema.properties,
$schemaKeys = Object.keys($schema);
var arr3 = $schemaKeys;
if (arr3) {
var $propertyKey, i3 = -1,
l3 = arr3.length - 1;
while (i3 < l3) {
$propertyKey = arr3[i3 += 1];
var $sch = $schema[$propertyKey];
if ($sch.default !== undefined) {
var $passData = $data + it.util.getProperty($propertyKey);
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
} else if ($rulesGroup.type == ''array'' && Array.isArray(it.schema.items)) {
var arr4 = it.schema.items;
if (arr4) {
var $sch, $i = -1,
l4 = arr4.length - 1;
while ($i < l4) {
$sch = arr4[$i += 1];
if ($sch.default !== undefined) {
var $passData = $data + ''['' + $i + '']'';
out += ''  if ('' + ($passData) + '' === undefined) '' + ($passData) + '' = '';
if (it.opts.useDefaults == ''shared'') {
out += '' '' + (it.useDefault($sch.default)) + '' '';
} else {
out += '' '' + (JSON.stringify($sch.default)) + '' '';
}
out += ''; '';
}
}
}
}
}
var arr5 = $rulesGroup.rules;
if (arr5) {
var $rule, i5 = -1,
l5 = arr5.length - 1;
while (i5 < l5) {
$rule = arr5[i5 += 1];
if ($shouldUseRule($rule)) {
var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
if ($code) {
out += '' '' + ($code) + '' '';
if ($breakOnError) {
$closingBraces1 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces1) + '' '';
$closingBraces1 = '''';
}
if ($rulesGroup.type) {
out += '' } '';
if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
out += '' else { '';
var $schemaPath = it.schemaPath + ''.type'',
$errSchemaPath = it.errSchemaPath + ''/type'';
var $$outStack = $$outStack || [];
$$outStack.push(out);
out = ''''; /* istanbul ignore else */
if (it.createErrors !== false) {
out += '' { keyword: \\\\'''' + ($errorKeyword || ''type'') + ''\\\\'' , dataPath: (dataPath || \\\\''\\\\'') + '' + (it.errorPath) + '' , schemaPath: '' + (it.util.toQuotedString($errSchemaPath)) + '' , params: { type: \\\\'''';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' } '';
if (it.opts.messages !== false) {
out += '' , message: \\\\''should be '';
if ($typeIsArray) {
out += '''' + ($typeSchema.join(\\", \\"));
} else {
out += '''' + ($typeSchema);
}
out += ''\\\\'' '';
}
if (it.opts.verbose) {
out += '' , schema: validate.schema'' + ($schemaPath) + '' , parentSchema: validate.schema'' + (it.schemaPath) + '' , data: '' + ($data) + '' '';
}
out += '' } '';
} else {
out += '' {} '';
}
var __err = out;
out = $$outStack.pop();
if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
if (it.async) {
out += '' throw new ValidationError(['' + (__err) + '']); '';
} else {
out += '' validate.errors = ['' + (__err) + '']; return false; '';
}
} else {
out += '' var err = '' + (__err) + '';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; '';
}
out += '' } '';
}
}
if ($breakOnError) {
out += '' if (errors === '';
if ($top) {
out += ''0'';
} else {
out += ''errs_'' + ($lvl);
}
out += '') { '';
$closingBraces2 += ''}'';
}
}
}
}
}
if ($breakOnError) {
out += '' '' + ($closingBraces2) + '' '';
}
if ($top) {
if ($async) {
out += '' if (errors === 0) return data;           '';
out += '' else throw new ValidationError(vErrors); '';
} else {
out += '' validate.errors = vErrors; '';
out += '' return errors === 0;       '';
}
out += '' }); return validate;'';
} else {
out += '' var '' + ($valid) + '' = errors === errs_'' + ($lvl) + '';'';
}
out = it.util.cleanUpCode(out);
if ($top) {
out = it.util.finalCleanUpCode(out, $async);
}
function $shouldUseGroup($rulesGroup) {
var rules = $rulesGroup.rules;
for (var i = 0; i < rules.length; i++)
if ($shouldUseRule(rules[i])) return true;
}
function $shouldUseRule($rule) {
return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImlementsSomeKeyword($rule));
}
function $ruleImlementsSomeKeyword($rule) {
var impl = $rule.implements;
for (var i = 0; i < impl.length; i++)
if (it.schema[impl[i]] !== undefined) return true;
}
return out;
}
},{}],44:[function(require,module,exports){
''use strict'';
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = require(''./dotjs/custom'');
module.exports = {
add: addKeyword,
get: getKeyword,
remove: removeKeyword
};
/**
* Define custom keyword
* @this  Ajv
* @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
* @param {Object} definition keyword definition object with properties \`type\` (type(s) which the keyword applies to), \`validate\` or \`compile\`.
*/
function addKeyword(keyword, definition) {
/* jshint validthis: true */
/* eslint no-shadow: 0 */
var RULES = this.RULES;
if (RULES.keywords[keyword])
throw new Error(''Keyword '' + keyword + '' is already defined'');
if (!IDENTIFIER.test(keyword))
throw new Error(''Keyword '' + keyword + '' is not a valid identifier'');
if (definition) {
if (definition.macro && definition.valid !== undefined)
throw new Error(''\\" valid \\" option cannot be used with macro keywords'');
var dataType = definition.type;
if (Array.isArray(dataType)) {
var i, len = dataType.length;
for (i=0; i<len; i++) checkDataType(dataType[i]);
for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
} else {
if (dataType) checkDataType(dataType);
_addRule(keyword, dataType, definition);
}
var $data = definition.$data === true && this._opts.$data;
if ($data && !definition.validate)
throw new Error(''$data support: \\" validate \\" function is not defined'');
var metaSchema = definition.metaSchema;
if (metaSchema) {
if ($data) {
metaSchema = {
anyOf: [
metaSchema,
{ ''$ref'': ''https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'' }
]
};
}
definition.validateSchema = this.compile(metaSchema, true);
}
}
RULES.keywords[keyword] = RULES.all[keyword] = true;
function _addRule(keyword, dataType, definition) {
var ruleGroup;
for (var i=0; i<RULES.length; i++) {
var rg = RULES[i];
if (rg.type == dataType) {
ruleGroup = rg;
break;
}
}
if (!ruleGroup) {
ruleGroup = { type: dataType, rules: [] };
RULES.push(ruleGroup);
}
var rule = {
keyword: keyword,
definition: definition,
custom: true,
code: customRuleCode,
implements: definition.implements
};
ruleGroup.rules.push(rule);
RULES.custom[keyword] = rule;
}
function checkDataType(dataType) {
if (!RULES.types[dataType]) throw new Error(''Unknown type '' + dataType);
}
}
/**
* Get keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
* @return {Object|Boolean} custom keyword definition, \`true\` if it is a predefined keyword, \`false\` otherwise.
*/
function getKeyword(keyword) {
/* jshint validthis: true */
var rule = this.RULES.custom[keyword];
return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
* Remove keyword
* @this  Ajv
* @param {String} keyword pre-defined or custom keyword.
*/
function removeKeyword(keyword) {
/* jshint validthis: true */
var RULES = this.RULES;
delete RULES.keywords[keyword];
delete RULES.all[keyword];
delete RULES.custom[keyword];
for (var i=0; i<RULES.length; i++) {
var rules = RULES[i].rules;
for (var j=0; j<rules.length; j++) {
if (rules[j].keyword == keyword) {
rules.splice(j, 1);
break;
}
}
}
}
},{\\"./ dotjs / custom \\":29}],45:[function(require,module,exports){
''use strict'';
var META_SCHEMA_ID = ''http://json-schema.org/draft-06/schema'';
module.exports = function (ajv) {
var defaultMeta = ajv._opts.defaultMeta;
var metaSchemaRef = typeof defaultMeta == ''string''
? { $ref: defaultMeta }
: ajv.getSchema(META_SCHEMA_ID)
? { $ref: META_SCHEMA_ID }
: {};
ajv.addKeyword(''patternGroups'', {
// implemented in properties.jst
metaSchema: {
type: ''object'',
additionalProperties: {
type: ''object'',
required: [ ''schema'' ],
properties: {
maximum: {
type: ''integer'',
minimum: 0
},
minimum: {
type: ''integer'',
minimum: 0
},
schema: metaSchemaRef
},
additionalProperties: false
}
}
});
ajv.RULES.all.properties.implements.push(''patternGroups'');
};
},{}],46:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" https: / / raw.githubusercontent.com / epoberezkin / ajv / master / lib / refs / $ data.json # \\",
\\" description \\": \\" Meta - SCHEMA FOR $ data reference (json - SCHEMA EXTENSION proposal) \\",
\\" TYPE \\": \\" object \\",
\\" required \\": [ \\" $ data \\" ],
\\" properties \\": {
\\" $ data \\": {
\\" TYPE \\": \\" string \\",
\\" anyOf \\": [
{ \\" format \\": \\" relative - json - pointer \\" },
{ \\" format \\": \\" json - pointer \\" }
]
}
},
\\" additionalProperties \\": false
}
},{}],47:[function(require,module,exports){
module.exports={
\\" $ SCHEMA \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" $ id \\": \\" http: / / json - schema.org / draft - 06 / SCHEMA # \\",
\\" title \\": \\" Core SCHEMA meta - SCHEMA \\",
\\" definitions \\": {
\\" schemaArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" items \\": { \\" $ ref \\": \\" # \\" }
},
\\" nonNegativeInteger \\": {
\\" TYPE \\": \\" integer \\",
\\" minimum \\": 0
},
\\" nonNegativeIntegerDefault0 \\": {
\\" allOf \\": [
{ \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
{ \\" DEFAULT \\": 0 }
]
},
\\" simpleTypes \\": {
\\" enum \\": [
\\" ARRAY \\",
\\" boolean \\",
\\" integer \\",
\\" NULL \\",
\\" number \\",
\\" object \\",
\\" string \\"
]
},
\\" stringArray \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" TYPE \\": \\" string \\" },
\\" uniqueItems \\": true,
\\" DEFAULT \\": []
}
},
\\" TYPE \\": [\\" object \\", \\" boolean \\"],
\\" properties \\": {
\\" $ id \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" $ SCHEMA \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri \\"
},
\\" $ ref \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" uri - reference \\"
},
\\" title \\": {
\\" TYPE \\": \\" string \\"
},
\\" description \\": {
\\" TYPE \\": \\" string \\"
},
\\" DEFAULT \\": {},
\\" multipleOf \\": {
\\" TYPE \\": \\" number \\",
\\" exclusiveMinimum \\": 0
},
\\" maximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMaximum \\": {
\\" TYPE \\": \\" number \\"
},
\\" minimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" exclusiveMinimum \\": {
\\" TYPE \\": \\" number \\"
},
\\" maxLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minLength \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" pattern \\": {
\\" TYPE \\": \\" string \\",
\\" format \\": \\" regex \\"
},
\\" additionalItems \\": { \\" $ ref \\": \\" # \\" },
\\" items \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / schemaArray \\" }
],
\\" DEFAULT \\": {}
},
\\" maxItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minItems \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" uniqueItems \\": {
\\" TYPE \\": \\" boolean \\",
\\" DEFAULT \\": false
},
\\" contains \\": { \\" $ ref \\": \\" # \\" },
\\" maxProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeInteger \\" },
\\" minProperties \\": { \\" $ ref \\": \\" # / definitions / nonNegativeIntegerDefault0 \\" },
\\" required \\": { \\" $ ref \\": \\" # / definitions / stringArray \\" },
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" definitions \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" properties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" patternProperties \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": { \\" $ ref \\": \\" # \\" },
\\" DEFAULT \\": {}
},
\\" dependencies \\": {
\\" TYPE \\": \\" object \\",
\\" additionalProperties \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # \\" },
{ \\" $ ref \\": \\" # / definitions / stringArray \\" }
]
}
},
\\" propertyNames \\": { \\" $ ref \\": \\" # \\" },
\\" const \\": {},
\\" enum \\": {
\\" TYPE \\": \\" ARRAY \\",
\\" minItems \\": 1,
\\" uniqueItems \\": true
},
\\" TYPE \\": {
\\" anyOf \\": [
{ \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
{
\\" TYPE \\": \\" ARRAY \\",
\\" items \\": { \\" $ ref \\": \\" # / definitions / simpleTypes \\" },
\\" minItems \\": 1,
\\" uniqueItems \\": true
}
]
},
\\" format \\": { \\" TYPE \\": \\" string \\" },
\\" allOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" anyOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" oneOf \\": { \\" $ ref \\": \\" # / definitions / schemaArray \\" },
\\" NOT \\": { \\" $ ref \\": \\" # \\" }
},
\\" DEFAULT \\": {}
}
},{}],48:[function(require,module,exports){
/**
* slice() reference.
*/
var slice = Array.prototype.slice;
/**
* Expose \`co\`.
*/
module.exports = co[''default''] = co.co = co;
/**
* Wrap the given generator \`fn\` into a
* function that returns a promise.
* This is a separate function so that
* every \`co()\` call doesn''t create a new,
* unnecessary closure.
*
* @param {GeneratorFunction} fn
* @return {Function}
* @api public
*/
co.wrap = function (fn) {
createPromise.__generatorFunction__ = fn;
return createPromise;
function createPromise() {
return co.call(this, fn.apply(this, arguments));
}
};
/**
* Execute the generator function or a generator
* and return a promise.
*
* @param {Function} fn
* @return {Promise}
* @api public
*/
function co(gen) {
var ctx = this;
var args = slice.call(arguments, 1)
// we wrap everything in a promise to avoid promise chaining,
// which leads to memory leak errors.
// see https://github.com/tj/co/issues/180
return new Promise(function(resolve, reject) {
if (typeof gen === ''function'') gen = gen.apply(ctx, args);
if (!gen || typeof gen.next !== ''function'') return resolve(gen);
onFulfilled();
/**
* @param {Mixed} res
* @return {Promise}
* @api private
*/
function onFulfilled(res) {
var ret;
try {
ret = gen.next(res);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* @param {Error} err
* @return {Promise}
* @api private
*/
function onRejected(err) {
var ret;
try {
ret = gen.throw(err);
} catch (e) {
return reject(e);
}
next(ret);
}
/**
* Get the next value in the generator,
* return a promise.
*
* @param {Object} ret
* @return {Promise}
* @api private
*/
function next(ret) {
if (ret.done) return resolve(ret.value);
var value = toPromise.call(ctx, ret.value);
if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
return onRejected(new TypeError(''You may only yield a function, promise, generator, array, or object, ''
+ ''but the following object was passed: \\" '' + String(ret.value) + '' \\"''));
}
});
}
/**
* Convert a \`yield\`ed value into a promise.
*
* @param {Mixed} obj
* @return {Promise}
* @api private
*/
function toPromise(obj) {
if (!obj) return obj;
if (isPromise(obj)) return obj;
if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
if (''function'' == typeof obj) return thunkToPromise.call(this, obj);
if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
if (isObject(obj)) return objectToPromise.call(this, obj);
return obj;
}
/**
* Convert a thunk to a promise.
*
* @param {Function}
* @return {Promise}
* @api private
*/
function thunkToPromise(fn) {
var ctx = this;
return new Promise(function (resolve, reject) {
fn.call(ctx, function (err, res) {
if (err) return reject(err);
if (arguments.length > 2) res = slice.call(arguments, 1);
resolve(res);
});
});
}
/**
* Convert an array of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Array} obj
* @return {Promise}
* @api private
*/
function arrayToPromise(obj) {
return Promise.all(obj.map(toPromise, this));
}
/**
* Convert an object of \\" yieldables \\" to a promise.
* Uses \`Promise.all()\` internally.
*
* @param {Object} obj
* @return {Promise}
* @api private
*/
function objectToPromise(obj){
var results = new obj.constructor();
var keys = Object.keys(obj);
var promises = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var promise = toPromise.call(this, obj[key]);
if (promise && isPromise(promise)) defer(promise, key);
else results[key] = obj[key];
}
return Promise.all(promises).then(function () {
return results;
});
function defer(promise, key) {
// predefine the key in the result
results[key] = undefined;
promises.push(promise.then(function (res) {
results[key] = res;
}));
}
}
/**
* Check if \`obj\` is a promise.
*
* @param {Object} obj
* @return {Boolean}
* @api private
*/
function isPromise(obj) {
return ''function'' == typeof obj.then;
}
/**
* Check if \`obj\` is a generator.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGenerator(obj) {
return ''function'' == typeof obj.next && ''function'' == typeof obj.throw;
}
/**
* Check if \`obj\` is a generator function.
*
* @param {Mixed} obj
* @return {Boolean}
* @api private
*/
function isGeneratorFunction(obj) {
var constructor = obj.constructor;
if (!constructor) return false;
if (''GeneratorFunction'' === constructor.name || ''GeneratorFunction'' === constructor.displayName) return true;
return isGenerator(constructor.prototype);
}
/**
* Check for plain object.
*
* @param {Mixed} val
* @return {Boolean}
* @api private
*/
function isObject(val) {
return Object == val.constructor;
}
},{}],49:[function(require,module,exports){
''use strict'';
module.exports = function equal(a, b) {
if (a === b) return true;
var arrA = Array.isArray(a)
, arrB = Array.isArray(b)
, i;
if (arrA && arrB) {
if (a.length != b.length) return false;
for (i = 0; i < a.length; i++)
if (!equal(a[i], b[i])) return false;
return true;
}
if (arrA != arrB) return false;
if (a && b && typeof a === ''object'' && typeof b === ''object'') {
var keys = Object.keys(a);
if (keys.length !== Object.keys(b).length) return false;
var dateA = a instanceof Date
, dateB = b instanceof Date;
if (dateA && dateB) return a.getTime() == b.getTime();
if (dateA != dateB) return false;
var regexpA = a instanceof RegExp
, regexpB = b instanceof RegExp;
if (regexpA && regexpB) return a.toString() == b.toString();
if (regexpA != regexpB) return false;
for (i = 0; i < keys.length; i++)
if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
for (i = 0; i < keys.length; i++)
if(!equal(a[keys[i]], b[keys[i]])) return false;
return true;
}
return false;
};
},{}],50:[function(require,module,exports){
''use strict'';
var traverse = module.exports = function (schema, opts, cb) {
if (typeof opts == ''function'') {
cb = opts;
opts = {};
}
_traverse(opts, cb, schema, '''', schema);
};
traverse.keywords = {
additionalItems: true,
items: true,
contains: true,
additionalProperties: true,
propertyNames: true,
not: true
};
traverse.arrayKeywords = {
items: true,
allOf: true,
anyOf: true,
oneOf: true
};
traverse.propsKeywords = {
definitions: true,
properties: true,
patternProperties: true,
dependencies: true
};
traverse.skipKeywords = {
enum: true,
const: true,
required: true,
maximum: true,
minimum: true,
exclusiveMaximum: true,
exclusiveMinimum: true,
multipleOf: true,
maxLength: true,
minLength: true,
pattern: true,
format: true,
maxItems: true,
minItems: true,
uniqueItems: true,
maxProperties: true,
minProperties: true
};
function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
if (schema && typeof schema == ''object'' && !Array.isArray(schema)) {
cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
for (var key in schema) {
var sch = schema[key];
if (Array.isArray(sch)) {
if (key in traverse.arrayKeywords) {
for (var i=0; i<sch.length; i++)
_traverse(opts, cb, sch[i], jsonPtr + ''/'' + key + ''/'' + i, rootSchema, jsonPtr, key, schema, i);
}
} else if (key in traverse.propsKeywords) {
if (sch && typeof sch == ''object'') {
for (var prop in sch)
_traverse(opts, cb, sch[prop], jsonPtr + ''/'' + key + ''/'' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
}
} else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
_traverse(opts, cb, sch, jsonPtr + ''/'' + key, rootSchema, jsonPtr, key, schema);
}
}
}
}
function escapeJsonPtr(str) {
return str.replace(/~/g, ''~0'').replace(/\\\\//g, ''~1'');
}
},{}],51:[function(require,module,exports){
var json = typeof JSON !== ''undefined'' ? JSON : require(''jsonify'');
module.exports = function (obj, opts) {
if (!opts) opts = {};
if (typeof opts === ''function'') opts = { cmp: opts };
var space = opts.space || '''';
if (typeof space === ''number'') space = Array(space+1).join('' '');
var cycles = (typeof opts.cycles === ''boolean'') ? opts.cycles : false;
var replacer = opts.replacer || function(key, value) { return value; };
var cmp = opts.cmp && (function (f) {
return function (node) {
return function (a, b) {
var aobj = { key: a, value: node[a] };
var bobj = { key: b, value: node[b] };
return f(aobj, bobj);
};
};
})(opts.cmp);
var seen = [];
return (function stringify (parent, key, node, level) {
var indent = space ? (''\\\\n'' + new Array(level + 1).join(space)) : '''';
var colonSeparator = space ? '': '' : '':'';
if (node && node.toJSON && typeof node.toJSON === ''function'') {
node = node.toJSON();
}
node = replacer.call(parent, key, node);
if (node === undefined) {
return;
}
if (typeof node !== ''object'' || node === null) {
return json.stringify(node);
}
if (isArray(node)) {
var out = [];
for (var i = 0; i < node.length; i++) {
var item = stringify(node, i, node[i], level+1) || json.stringify(null);
out.push(indent + space + item);
}
return ''['' + out.join('','') + indent + '']'';
}
else {
if (seen.indexOf(node) !== -1) {
if (cycles) return json.stringify(''__cycle__'');
throw new TypeError(''Converting circular structure to JSON'');
}
else seen.push(node);
var keys = objectKeys(node).sort(cmp && cmp(node));
var out = [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var value = stringify(node, key, node[key], level+1);
if(!value) continue;
var keyValue = json.stringify(key)
+ colonSeparator
+ value;
;
out.push(indent + space + keyValue);
}
seen.splice(seen.indexOf(node), 1);
return ''{'' + out.join('','') + indent + ''}'';
}
})({ '''': obj }, '''', obj, 0);
};
var isArray = Array.isArray || function (x) {
return {}.toString.call(x) === ''[object Array]'';
};
var objectKeys = Object.keys || function (obj) {
var has = Object.prototype.hasOwnProperty || function () { return true };
var keys = [];
for (var key in obj) {
if (has.call(obj, key)) keys.push(key);
}
return keys;
};
},{\\" jsonify \\":52}],52:[function(require,module,exports){
exports.parse = require(''./lib/parse'');
exports.stringify = require(''./lib/stringify'');
},{\\"./ lib / parse \\":53,\\"./ lib / stringify \\":54}],53:[function(require,module,exports){
var at, // The index of the current character
ch, // The current character
escapee = {
''\\" '':  '' \\"'',
''\\\\\\\\'': ''\\\\\\\\'',
''/'':  ''/'',
b:    ''\\\\b'',
f:    ''\\\\f'',
n:    ''\\\\n'',
r:    ''\\\\r'',
t:    ''\\\\t''
},
text,
error = function (m) {
// Call error when something is wrong.
throw {
name:    ''SyntaxError'',
message: m,
at:      at,
text:    text
};
},
next = function (c) {
// If a c parameter is provided, verify that it matches the current character.
if (c && c !== ch) {
error(\\" Expected ''\\" + c + \\"'' INSTEAD OF ''\\" + ch + \\"'' \\");
}
// Get the next character. When there are no more characters,
// return the empty string.
ch = text.charAt(at);
at += 1;
return ch;
},
number = function () {
// Parse a number value.
var number,
string = '''';
if (ch === ''-'') {
string = ''-'';
next(''-'');
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
if (ch === ''.'') {
string += ''.'';
while (next() && ch >= ''0'' && ch <= ''9'') {
string += ch;
}
}
if (ch === ''e'' || ch === ''E'') {
string += ch;
next();
if (ch === ''-'' || ch === ''+'') {
string += ch;
next();
}
while (ch >= ''0'' && ch <= ''9'') {
string += ch;
next();
}
}
number = +string;
if (!isFinite(number)) {
error(\\" Bad number \\");
} else {
return number;
}
},
string = function () {
// Parse a string value.
var hex,
i,
string = '''',
uffff;
// When parsing for string values, we must look for \\" AND characters. IF (ch == = ''\\"'') { while (NEXT ()) { IF (ch == = ''\\"'') { NEXT (); RETURN string; }
ELSE
IF (ch == = ''\\\\\\\\'') { NEXT (); IF (ch == = ''u'') { uffff = 0; FOR (i = 0; i < 4; i + = 1) { hex = parseInt (NEXT (), 16); IF (! isFinite(hex)) { break; } uffff = uffff * 16 + hex; } string + = String.fromCharCode (uffff); }
ELSE
IF (typeof escapee[ch] == = ''string'') { string + = escapee[ch]; }
ELSE
{ break; } }
ELSE
{ string + = ch; } } } error (\\"Bad string\\"); }, white = FUNCTION () { / / SKIP whitespace. while (ch && ch <= '' '') { NEXT (); } }, word = FUNCTION () { / / TRUE, FALSE, OR null. switch (ch) { CASE ''t'' : NEXT (''t''); NEXT (''r''); NEXT (''u''); NEXT (''e''); RETURN TRUE; CASE ''f'' : NEXT (''f''); NEXT (''a''); NEXT (''l''); NEXT (''s''); NEXT (''e''); RETURN FALSE; CASE ''n'' : NEXT (''n''); NEXT (''u''); NEXT (''l''); NEXT (''l''); RETURN NULL; } error (\\"Unexpected ''\\" + ch + \\"''\\"); }, value, / / Place holder FOR the value function. ARRAY = FUNCTION () { / / Parse an ARRAY value. var ARRAY =[]; IF (ch == = ''['') { NEXT (''[''); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; / / empty ARRAY } while (ch) { array.push (value ()); white (); IF (ch == = '']'') { NEXT ('']''); RETURN ARRAY; } NEXT ('',''); white (); } } error (\\"Bad array\\"); }, object = FUNCTION () { / / Parse an object value. var KEY, object = {}; IF (ch == = ''{'') { NEXT (''{''); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; / / empty object } while (ch) { KEY = string (); white (); NEXT ('':''); IF (Object.hasOwnProperty.call (object, KEY)) { error (''Duplicate key \\"'' + KEY + ''\\"''); } object[KEY] = value (); white (); IF (ch == = ''}'') { NEXT (''}''); RETURN object; } NEXT ('',''); white (); } } error (\\"Bad object\\"); }; value = FUNCTION () { / / Parse a json value. It could be an object, an ARRAY, a string, a number, / / OR a word. white (); switch (ch) { CASE ''{'' : RETURN object (); CASE ''['' : RETURN ARRAY (); CASE ''\\"'' : RETURN string (); CASE ''-'' : RETURN number (); default: RETURN ch >= ''0'' && ch <= ''9'' ? number () : word (); } }; / / RETURN the json_parse function. It will have access TO ALL OF the above / / functions AND variables. module.exports = FUNCTION (source, reviver) { var result; text = source; at = 0; ch = '' ''; result = value (); white (); IF (ch) { error (\\"Syntax error\\"); } / / IF there IS a reviver FUNCTION, we recursively walk the new structure, / / passing EACH name / value pair TO the reviver FUNCTION FOR possible / / transformation, starting WITH a TEMPORARY root object that holds the result / / IN an empty key. IF there IS NOT a reviver FUNCTION, we simply RETURN the / / result. RETURN typeof reviver == = ''function'' ? (
FUNCTION walk (
holder, KEY
) { var k, v, value = holder[KEY]; IF (
value && typeof value == = ''object''
) { FOR (
k IN value
) { IF (
Object.prototype.hasOwnProperty.call (
value, k
)
) { v = walk (
value, k
); IF (
v != = undefined
) { value[k] = v; }
ELSE
{ DELETE value[k]; } } } } RETURN reviver.call (
holder, KEY, value
); }({'''' : result }, '''')) : result; }; }, {}], 54:[FUNCTION (require, module, exports) { var cx = /[u0000 u00ad u0600 - u0604 u070f u17b4 u17b5 u200c - u200f u2028 - u202f u2060 - u206f ufeff ufff0 - uffff] / g, escapable = /[\\\\\\\\ \\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f\\\\u00ad\\\\u0600-\\\\u0604\\\\u070f\\\\u17b4\\\\u17b5\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufeff\\\\ufff0-\\\\uffff]/g,
gap,
indent,
meta = {    // table of character substitutions
''\\\\b'': ''\\\\\\\\b'',
''\\\\t'': ''\\\\\\\\t'',
''\\\\n'': ''\\\\\\\\n'',
''\\\\f'': ''\\\\\\\\f'',
''\\\\r'': ''\\\\\\\\r'',
''\\" '' : '' \\\\\\\\ \\"'',
''\\\\\\\\'': ''\\\\\\\\\\\\\\\\''
},
rep;
function quote(string) {
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
escapable.lastIndex = 0;
return escapable.test(string) ? ''\\" '' + string.replace(escapable, function (a) {
var c = meta[a];
return typeof c === '' string '' ? c :
'' \\\\\\\\u '' + ('' 0000 '' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '' \\"'' : ''\\" '' + string + '' \\"''; } FUNCTION str (KEY, holder) { / / Produce a string FROM holder[KEY].var i, / / The LOOP
counter. k, / / The member key. v, / / The member value. length, mind = gap, partial, value = holder[KEY]; / / IF the value has a toJSON method, CALL it TO obtain a replacement value. IF (value && typeof value == = ''object'' && typeof value.toJSON == = ''function'') { value = value.toJSON (KEY); } / / IF we were called WITH a replacer FUNCTION, THEN
CALL the replacer TO / / obtain a replacement value. IF (
typeof rep == = ''function'') { value = rep.call (holder, KEY, value); } / / What happens NEXT depends ON the value ''s type.
switch (typeof value) {
case '' string '':
return quote(value);
case '' number '':
// JSON numbers must be finite. Encode non-finite numbers as null.
return isFinite(value) ? String(value) : '' NULL '';
case '' boolean '':
case '' NULL '':
// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce '' NULL ''. The case is included here in
// the remote chance that this gets fixed someday.
return String(value);
case '' object '':
if (!value) return '' NULL '';
gap += indent;
partial = [];
// Array.isArray
if (Object.prototype.toString.apply(value) === ''[object ARRAY] '') {
length = value.length;
for (i = 0; i < length; i += 1) {
partial[i] = str(i, value) || '' NULL '';
}
// Join all of the elements together, separated with commas, and
// wrap them in brackets.
v = partial.length === 0 ? ''[] '' : gap ?
''[n '' + gap + partial.join('', n '' + gap) + '' n '' + mind + ''] '' :
''['' + partial.join('', '') + ''] '';
gap = mind;
return v;
}
// If the replacer is an array, use it to select the members to be
// stringified.
if (rep && typeof rep === '' object '') {
length = rep.length;
for (i = 0; i < length; i += 1) {
k = rep[i];
if (typeof k === '' string '') {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
else {
// Otherwise, iterate through all of the keys in the object.
for (k in value) {
if (Object.prototype.hasOwnProperty.call(value, k)) {
v = str(k, value);
if (v) {
partial.push(quote(k) + (gap ? '' :'' : '' : '') + v);
}
}
}
}
// Join all of the member texts together, separated with commas,
// and wrap them in braces.
v = partial.length === 0 ? '' {}'' : gap ? ''{\\\\n'' + gap + partial.join ('',\\\\n'' + gap) + ''\\\\n'' + mind + ''}'' :''{'' + partial.join ('','') + ''}''; gap = mind; RETURN v; } } module.exports = FUNCTION (value, replacer, space) { var i; gap = ''''; indent = ''''; / / IF the space parameter IS a number, make an indent string containing that / / many spaces. IF (typeof space == = ''number'') { FOR (i = 0; i < space; i + = 1) { indent + = '' ''; } } / / IF the space parameter IS a string, it will be used AS the
indent string.
ELSE
IF (typeof space == = ''string'') { indent = space; } / / IF there IS a replacer, it must be a FUNCTION OR an array. / / Otherwise, throw an error. rep = replacer; IF (replacer && typeof replacer != = ''function'' && (typeof replacer != = ''object'' || typeof replacer.length != = ''number'')) { throw new Error (''JSON.stringify''); } / / Make a fake root object containing our value under
the KEY OF ''''. / / RETURN the result OF stringifying the value. RETURN str ('''', {'''' : value }); }; }, {}]}, {},[7]) (7) });
/* plv8 bundle ends */
RETURN module; })(); ');"
`;

exports[`kitchen sink policies 1`] = `
"CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC USING ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( id = current_setting('user.id')::uuid );
CREATE POLICY select_user ON users.\\"user\\" FOR SELECT TO PUBLIC USING ( 't'::boolean );
CREATE POLICY delete_own ON myschema.mytable FOR DELETE TO PUBLIC USING ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY insert_own ON myschema.mytable FOR ALL TO PUBLIC WITH CHECK ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY select_any ON myschema.mytable FOR SELECT TO PUBLIC USING ( 't'::boolean );
CREATE POLICY update_own ON myschema.mytable FOR UPDATE TO PUBLIC USING ( group_id = ANY( otherschema.my_policy_fn() ) );
CREATE POLICY delete_pol_permissive ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );
CREATE POLICY delete_pol_restrictive ON users.\\"user\\" AS RESTRICTIVE FOR DELETE TO PUBLIC WITH CHECK ( id = current_setting('user.id')::uuid );"
`;

exports[`kitchen sink policies 2`] = `
"CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( ((id) = (current_setting('user.id')::uuid)) );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC USING ( ((id) = (current_setting('user.id')::uuid)) );
CREATE POLICY delete_user_no_to ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( ((id) = (current_setting('user.id')::uuid)) );
CREATE POLICY delete_user ON users.\\"user\\" FOR DELETE TO authenticated USING ( ((id) = (current_setting('user.id')::uuid)) );
CREATE POLICY select_user ON users.\\"user\\" FOR SELECT TO PUBLIC USING ( (TRUE) );
CREATE POLICY delete_own ON myschema.mytable FOR DELETE TO PUBLIC USING ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY insert_own ON myschema.mytable FOR ALL TO PUBLIC WITH CHECK ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY select_any ON myschema.mytable FOR SELECT TO PUBLIC USING ( (TRUE) );
CREATE POLICY update_own ON myschema.mytable FOR UPDATE TO PUBLIC USING ( group_id = ANY (otherschema.my_policy_fn()) );
CREATE POLICY delete_pol_permissive ON users.\\"user\\" FOR DELETE TO PUBLIC WITH CHECK ( ((id) = (current_setting('user.id')::uuid)) );
CREATE POLICY delete_pol_restrictive ON users.\\"user\\" AS RESTRICTIVE FOR DELETE TO PUBLIC WITH CHECK ( ((id) = (current_setting('user.id')::uuid)) );"
`;

exports[`kitchen sink roles create 1`] = `
"CREATE ROLE app_anonymous;
CREATE ROLE app_authenticated;
CREATE ROLE app_user WITH LOGIN PASSWORD 'xyz';
CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
CREATE ROLE admin1 WITH LOGIN PASSWORD 'jw8s0F4' CREATEDB CREATEROLE INHERIT;
CREATE ROLE admin2 WITH NOLOGIN NOCREATEDB NOCREATEROLE;
CREATE ROLE authy WITH ADMIN app_authenticated;"
`;

exports[`kitchen sink roles create 2`] = `
"CREATE ROLE \\"app_anonymous\\";
CREATE ROLE \\"app_authenticated\\";
CREATE ROLE \\"app_user\\" WITH LOGIN PASSWORD 'xyz';
CREATE ROLE \\"miriam\\" WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
CREATE ROLE \\"admin1\\" WITH LOGIN PASSWORD 'jw8s0F4' CREATEDB CREATEROLE INHERIT;
CREATE ROLE \\"admin2\\" WITH NOLOGIN NOCREATEDB NOCREATEROLE;
CREATE ROLE \\"authy\\" WITH ADMIN app_authenticated;"
`;

exports[`kitchen sink roles grants 1`] = `
"GRANT APP_AUTHENTICATED TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user, super_app_user;"
`;

exports[`kitchen sink roles grants 2`] = `
"GRANT APP_AUTHENTICATED TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user;
GRANT APP_AUTHENTICATED, APP_ANONYMOUS TO app_user, super_app_user;"
`;

exports[`kitchen sink rules create 1`] = `
"CREATE RULE collections_ins_protect AS ON INSERT TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_upd_protect AS ON UPDATE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_del_protect AS ON DELETE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD DELETE FROM shoelace_data WHERE sl_name = old.sl_name;
CREATE RULE \\"_RETURN\\" AS ON SELECT TO t2 DO INSTEAD SELECT * FROM t1;
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE new.sl_avail <> old.sl_avail DO INSERT INTO shoelace_log VALUES (new.sl_name, new.sl_avail, CURRENT_USER, CURRENT_TIMESTAMP);
CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);"
`;

exports[`kitchen sink rules create 2`] = `
"CREATE RULE collections_ins_protect AS ON INSERT TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_upd_protect AS ON UPDATE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE collections_del_protect AS ON DELETE TO dbs.collections DO INSTEAD NOTHING;
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name,sl_avail = new.sl_avail,sl_color = new.sl_color,sl_len = new.sl_len,sl_unit = new.sl_unit WHERE ((sl_name) = (old.sl_name));
CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data WHERE ((sl_name) = (old.sl_name));
CREATE RULE \\"_RETURN\\" AS ON SELECT TO t2 DO INSTEAD SELECT * FROM t1;
CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE ((new.sl_avail) <> (old.sl_avail)) DO INSERT INTO shoelace_log VALUES (new.sl_name, new.sl_avail, CURRENT_USER, CURRENT_TIMESTAMP);
CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);"
`;

exports[`kitchen sink sequences 1`] = `
"CREATE SEQUENCE foo.bar;
CREATE SEQUENCE mysequence increment 5 start 100;
CREATE SEQUENCE three increment -1 minvalue 1 maxvalue 3 start 3 CYCLE;
CREATE SEQUENCE three3 increment -1 minvalue 1 maxvalue 3 start 3 NO CYCLE;
CREATE SEQUENCE app_jobs.jobs_id_seq start 1 increment 1 NO MINVALUE NO MAXVALUE cache 1;"
`;

exports[`kitchen sink sequences 2`] = `
"CREATE SEQUENCE foo.bar;
CREATE SEQUENCE mysequence increment 5 start 100;
CREATE SEQUENCE three increment -1 minvalue 1 maxvalue 3 start 3 CYCLE;
CREATE SEQUENCE three3 increment -1 minvalue 1 maxvalue 3 start 3 NO CYCLE;
CREATE SEQUENCE app_jobs.jobs_id_seq start 1 increment 1 NO MINVALUE NO MAXVALUE cache 1;"
`;

exports[`kitchen sink set 1`] = `
"SET var FROM CURRENT;
RESET client_min_messages;
SET search_path = 'alt_nsp1', 'public';
SET session_authorization = 'regtest_alter_user1';
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
RESET session_authorization;"
`;

exports[`kitchen sink set 2`] = `
"SET var FROM CURRENT;
RESET client_min_messages;
SET search_path = 'alt_nsp1', 'public';
SET session_authorization = 'regtest_alter_user1';
SET client_encoding = 'UNICODE';
SET client_encoding = 'UNICODE';
SET client_min_messages = 'notice';
RESET session_authorization;"
`;

exports[`kitchen sink tables check 1`] = `
"CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CONSTRAINT positive_price CHECK (price > 0)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0),
discounted_price numeric CHECK (discounted_price > 0),
CHECK (price > discounted_price)
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK (price > 0),
discounted_price numeric CONSTRAINT check_price CHECK (discounted_price > 0),
CHECK (price > discounted_price)
);
CREATE TABLE boomin (
d date,
CHECK ('f'::boolean) NO INHERIT NOT VALID
);
CREATE TABLE boomin (
d date,
CHECK ('t'::boolean) NO INHERIT NOT VALID
);
ALTER TABLE checkitout ADD CHECK (d BETWEEN '2010-01-01'::date AND '2010-12-31'::date) NOT VALID;
ALTER TABLE checkitout2 ADD CHECK (d NOT BETWEEN '2010-01-01'::date AND '2010-12-31'::date) NOT VALID;
CREATE TABLE atacc3 (
test3 int
) INHERITS (atacc1, atacc2);"
`;

exports[`kitchen sink tables check 2`] = `
"CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( ((price) > (0)) )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CONSTRAINT positive_price CHECK ( ((price) > (0)) )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( ((price) > (0)) ),
discounted_price numeric CHECK ( ((discounted_price) > (0)) ),
CHECK ( ((price) > (discounted_price)) )
);
CREATE TABLE products (
product_no int,
name text,
price numeric CHECK ( ((price) > (0)) ),
discounted_price numeric CONSTRAINT check_price CHECK ( ((discounted_price) > (0)) ),
CHECK ( ((price) > (discounted_price)) )
);
CREATE TABLE boomin (
d date,
CHECK ( (FALSE) ) NO INHERIT NOT VALID
);
CREATE TABLE boomin (
d date,
CHECK ( (TRUE) ) NO INHERIT NOT VALID
);
ALTER TABLE checkitout ADD CHECK ( d BETWEEN '2010-01-01'::date AND '2010-12-31'::date ) NOT VALID;
ALTER TABLE checkitout2 ADD CHECK ( d NOT BETWEEN '2010-01-01'::date AND '2010-12-31'::date ) NOT VALID;
CREATE TABLE atacc3 (
test3 int
) INHERITS ( atacc1, atacc2 );"
`;

exports[`kitchen sink tables custom 1`] = `
"ALTER TABLE myschema.role ADD CONSTRAINT fk_myschema_role_actor_id FOREIGN KEY (actor_id) REFERENCES actors.actor (id) ON DELETE CASCADE ;
CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE actors_private.actor_info (
actor_id uuid PRIMARY KEY REFERENCES actors.actor (id) ON DELETE CASCADE ,
email text NOT NULL UNIQUE CHECK (email ~* '^.+@.+\\\\..+$'),
password_hash text NOT NULL
);
CREATE TABLE foo (
a int,
b int,
PRIMARY KEY (a, b)
);
CREATE TABLE t_full (
a int,
b int,
FOREIGN KEY (a, b) REFERENCES foo   MATCH FULL
);
CREATE TABLE t_simple (
a int,
b int,
FOREIGN KEY (a, b) REFERENCES foo
);"
`;

exports[`kitchen sink tables custom 2`] = `
"ALTER TABLE myschema.role ADD CONSTRAINT fk_myschema_role_actor_id FOREIGN KEY ( actor_id ) REFERENCES actors.actor ( id ) ON DELETE CASCADE;
CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE actors_private.actor_info (
actor_id uuid PRIMARY KEY REFERENCES actors.actor ( id ) ON DELETE CASCADE,
email text NOT NULL UNIQUE CHECK ( ((email) ~* ('^.+@.+\\\\..+$')) ),
password_hash text NOT NULL
);
CREATE TABLE foo (
a int,
b int,
PRIMARY KEY ( a, b )
);
CREATE TABLE t_full (
a int,
b int,
FOREIGN KEY ( a, b ) REFERENCES foo MATCH FULL
);
CREATE TABLE t_simple (
a int,
b int,
FOREIGN KEY ( a, b ) REFERENCES foo
);"
`;

exports[`kitchen sink tables defaults 1`] = `
"CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ('[-infinity,infinity]')
)"
`;

exports[`kitchen sink tables defaults 2`] = `
"CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ( '[-infinity,infinity]' )
)"
`;

exports[`kitchen sink tables exclude 1`] = `
"CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ('[-infinity,infinity]'),
EXCLUDE USING gist ( lower(name) WITH =, effective WITH && )
)"
`;

exports[`kitchen sink tables exclude 2`] = `
"CREATE TABLE circles (
c circle,
EXCLUDE USING gist ( c WITH && )
);
CREATE TABLE customer_product_categories (
id serial PRIMARY KEY,
name text NOT NULL,
effective tstzrange DEFAULT ( '[-infinity,infinity]' ),
EXCLUDE USING gist ( lower(name) WITH =, effective WITH && )
)"
`;

exports[`kitchen sink tables foreign 1`] = `
"CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products (product_no)  ,
quantity int
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products  ,
quantity int
);
CREATE TABLE t1 (
a int PRIMARY KEY,
b int,
c int,
FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
CREATE TABLE products (
product_no int PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
shipping_address text
);
CREATE TABLE order_items (
product_no int REFERENCES products  ,
order_id int REFERENCES orders  ,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables foreign 2`] = `
"CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products ( product_no ),
quantity int
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
product_no int REFERENCES products,
quantity int
);
CREATE TABLE t1 (
a int PRIMARY KEY,
b int,
c int,
FOREIGN KEY ( b, c ) REFERENCES other_table ( c1, c2 )
);
CREATE TABLE products (
product_no int PRIMARY KEY,
name text,
price numeric
);
CREATE TABLE orders (
order_id int PRIMARY KEY,
shipping_address text
);
CREATE TABLE order_items (
product_no int REFERENCES products,
order_id int REFERENCES orders,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables match 1`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables match 2`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables nulls 1`] = `
"CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric
);
CREATE TABLE products (
product_no int NULL,
name text NULL,
price numeric NULL
);
CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK (price > 0)
);"
`;

exports[`kitchen sink tables nulls 2`] = `
"CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric
);
CREATE TABLE products (
product_no int NULL,
name text NULL,
price numeric NULL
);
CREATE TABLE products (
product_no int NOT NULL,
name text NOT NULL,
price numeric NOT NULL CHECK ( ((price) > (0)) )
);"
`;

exports[`kitchen sink tables on_delete 1`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON DELETE RESTRICT ,
order_id int REFERENCES orders ON DELETE CASCADE ,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables on_delete 2`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON DELETE RESTRICT,
order_id int REFERENCES orders ON DELETE CASCADE,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables on_update 1`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products  ON UPDATE RESTRICT,
order_id int REFERENCES orders  ON UPDATE CASCADE,
quantity int,
PRIMARY KEY (product_no, order_id)
);"
`;

exports[`kitchen sink tables on_update 2`] = `
"CREATE TABLE order_items (
product_no int REFERENCES products ON UPDATE RESTRICT,
order_id int REFERENCES orders ON UPDATE CASCADE,
quantity int,
PRIMARY KEY ( product_no, order_id )
);"
`;

exports[`kitchen sink tables temp 1`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TEMPORARY TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TEMPORARY TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TEMPORARY TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables temp 2`] = `
"DROP TABLE IF EXISTS users CASCADE;
CREATE TEMPORARY TABLE users (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS post_type CASCADE;
CREATE TEMPORARY TABLE post_type (
id int NOT NULL PRIMARY KEY
);
DROP TABLE IF EXISTS assembly_seat CASCADE;
CREATE TEMPORARY TABLE assembly_seat (
id int NOT NULL PRIMARY KEY
);"
`;

exports[`kitchen sink tables unique 1`] = `
"CREATE TABLE products (
product_no int UNIQUE,
name text,
price numeric
);
CREATE TABLE products (
product_no int,
name text,
price numeric,
UNIQUE (product_no)
);
CREATE TABLE example (
a int,
b int,
c int,
UNIQUE (a, c)
);
CREATE TABLE products (
product_no int CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);"
`;

exports[`kitchen sink tables unique 2`] = `
"CREATE TABLE products (
product_no int UNIQUE,
name text,
price numeric
);
CREATE TABLE products (
product_no int,
name text,
price numeric,
UNIQUE ( product_no )
);
CREATE TABLE example (
a int,
b int,
c int,
UNIQUE ( a, c )
);
CREATE TABLE products (
product_no int CONSTRAINT must_be_different UNIQUE,
name text,
price numeric
);"
`;

exports[`kitchen sink transactions begin_commit 1`] = `
"BEGIN;
CREATE TABLE products (
product_no int,
name text
);
COMMIT;"
`;

exports[`kitchen sink transactions begin_commit 2`] = `
"BEGIN;
CREATE TABLE products (
product_no int,
name text
);
COMMIT;"
`;

exports[`kitchen sink triggers create 1`] = `
"CREATE TRIGGER _100_timestamps
BEFORE INSERT OR UPDATE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.update_timestamps ( );
CREATE TRIGGER _500_increase_job_queue_count
AFTER INSERT ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.jobs__increase_job_queue_count ( );
CREATE TRIGGER _500_decrease_job_queue_count
BEFORE DELETE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs.jobs__decrease_job_queue_count ( );
CREATE TRIGGER _900_notify_worker
AFTER INSERT ON app_jobs.jobs
FOR EACH STATEMENT
EXECUTE PROCEDURE app_jobs.do_notify ( 'jobs:insert' );
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
EXECUTE PROCEDURE check_account_update ( );
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN (OLD.* IS DISTINCT FROM NEW.*)
EXECUTE PROCEDURE log_account_update ( );
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE PROCEDURE view_insert_row ( );
CREATE TRIGGER transfer_insert
AFTER INSERT ON transfer
REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT
EXECUTE PROCEDURE check_transfer_balances_to_zero ( );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs ( );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING OLD TABLE AS oldtab NEW TABLE AS newtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs ( );"
`;

exports[`kitchen sink triggers create 2`] = `
"CREATE TRIGGER _100_timestamps
BEFORE INSERT OR UPDATE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. update_timestamps (  );
CREATE TRIGGER _500_increase_job_queue_count
AFTER INSERT ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. jobs__increase_job_queue_count (  );
CREATE TRIGGER _500_decrease_job_queue_count
BEFORE DELETE ON app_jobs.jobs
FOR EACH ROW
EXECUTE PROCEDURE app_jobs. jobs__decrease_job_queue_count (  );
CREATE TRIGGER _900_notify_worker
AFTER INSERT ON app_jobs.jobs
FOR EACH STATEMENT
EXECUTE PROCEDURE app_jobs. do_notify ( 'jobs:insert' );
CREATE TRIGGER check_update
BEFORE UPDATE OF balance ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER check_update
BEFORE UPDATE ON accounts
FOR EACH ROW
WHEN ( OLD.balance IS DISTINCT FROM NEW.balance )
EXECUTE PROCEDURE check_account_update (  );
CREATE TRIGGER log_update
AFTER UPDATE ON accounts
FOR EACH ROW
WHEN ( OLD.* IS DISTINCT FROM NEW.* )
EXECUTE PROCEDURE log_account_update (  );
CREATE TRIGGER view_insert
INSTEAD OF INSERT ON my_view
FOR EACH ROW
EXECUTE PROCEDURE view_insert_row (  );
CREATE TRIGGER transfer_insert
AFTER INSERT ON transfer
REFERENCING NEW TABLE AS inserted FOR EACH STATEMENT
EXECUTE PROCEDURE check_transfer_balances_to_zero (  );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs (  );
CREATE TRIGGER paired_items_update
AFTER UPDATE ON paired_items
REFERENCING OLD TABLE AS oldtab NEW TABLE AS newtab FOR EACH ROW
EXECUTE PROCEDURE check_matching_pairs (  );"
`;

exports[`kitchen sink triggers custom 1`] = `
"DROP SCHEMA IF EXISTS fb;
DROP SCHEMA IF EXISTS fb CASCADE;
CREATE SCHEMA fb;
SET search_path = 'fb', '$user', 'public';
CREATE EXTENSION \\"uuid-ossp\\";
CREATE TABLE \\"user\\" (
id uuid PRIMARY KEY DEFAULT (uuid_generate_v4()),
created timestamptz NOT NULL DEFAULT (now()),
full_name text NOT NULL DEFAULT ('')
);
CREATE TABLE post (
id uuid PRIMARY KEY DEFAULT (uuid_generate_v4()),
created timestamptz NOT NULL DEFAULT (now()),
content text NOT NULL DEFAULT (''),
\\"user\\" uuid REFERENCES \\"user\\"   NOT NULL
);
CREATE TABLE friendship (
first uuid REFERENCES \\"user\\"   NOT NULL,
second uuid REFERENCES \\"user\\"   NOT NULL,
created timestamptz NOT NULL DEFAULT (now()),
UNIQUE (first, second)
);
CREATE FUNCTION check_friendship_symmetry ( ) RETURNS TRIGGER AS $LQLCODEZ$
DECLARE
link friendship;
BEGIN
SELECT * INTO link FROM friendship
WHERE second = NEW.first AND first = NEW.second;
IF NOT FOUND THEN
RAISE EXCEPTION 'Friendships must be INSERTed as pairs.';
END IF;
RETURN NEW;
END
$LQLCODEZ$ LANGUAGE plpgsql IMMUTABLE SET search_path FROM CURRENT;
CREATE CONSTRAINT TRIGGER friendship_symmetry
AFTER INSERT ON friendship
DEFERRABLE INITIALLY DEFERRED FOR EACH ROW
EXECUTE PROCEDURE check_friendship_symmetry ( );
CREATE TRIGGER _500_increase_job_queue_count_update
AFTER UPDATE OF queue_name ON app.jobs
FOR EACH ROW
EXECUTE PROCEDURE app.jobs__increase_job_queue_count ( );"
`;

exports[`kitchen sink triggers custom 2`] = `
"DROP SCHEMA IF EXISTS fb;
DROP SCHEMA IF EXISTS fb CASCADE;
CREATE SCHEMA fb;
SET search_path = 'fb', '$user', 'public';
CREATE EXTENSION \\"uuid-ossp\\";
CREATE TABLE \\"user\\" (
id uuid PRIMARY KEY DEFAULT ( uuid_generate_v4() ),
created timestamptz NOT NULL DEFAULT ( now() ),
full_name text NOT NULL DEFAULT ( '' )
);
CREATE TABLE post (
id uuid PRIMARY KEY DEFAULT ( uuid_generate_v4() ),
created timestamptz NOT NULL DEFAULT ( now() ),
content text NOT NULL DEFAULT ( '' ),
\\"user\\" uuid REFERENCES \\"user\\" NOT NULL
);
CREATE TABLE friendship (
first uuid REFERENCES \\"user\\" NOT NULL,
second uuid REFERENCES \\"user\\" NOT NULL,
created timestamptz NOT NULL DEFAULT ( now() ),
UNIQUE ( first, second )
);
CREATE FUNCTION check_friendship_symmetry (  ) RETURNS trigger AS $EOFCODE$DECLARE
link friendship;
BEGIN
SELECT * INTO link FROM friendship
WHERE second = NEW.first AND first = NEW.second;
IF NOT FOUND THEN
RAISE EXCEPTION 'Friendships must be INSERTed as pairs.';
END IF;
RETURN NEW;
END$EOFCODE$ LANGUAGE plpgsql IMMUTABLE SET search_path FROM CURRENT;
CREATE CONSTRAINT TRIGGER friendship_symmetry
AFTER INSERT ON friendship
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW
EXECUTE PROCEDURE check_friendship_symmetry (  );
CREATE TRIGGER _500_increase_job_queue_count_update
AFTER UPDATE OF queue_name ON app.jobs
FOR EACH ROW
EXECUTE PROCEDURE app. jobs__increase_job_queue_count (  );"
`;

exports[`kitchen sink types 1`] = `"CREATE TYPE myschema.mycustomtype AS (id uuid,verify_code text,verify_code_expires_on timestamptz,actor_id uuid);"`;

exports[`kitchen sink types 2`] = `
"CREATE TYPE myschema.mycustomtype AS ( 	id uuid,
verify_code text,
verify_code_expires_on timestamptz,
actor_id uuid );"
`;

exports[`kitchen sink update 1`] = `
"UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';
UPDATE update_test SET (b, a) = (SELECT a + 1,
b FROM update_test WHERE a = 1000) WHERE a = 11;
UPDATE something SET (b, a) = (1, 2) WHERE a = 11;
UPDATE update_test SET (c, b, a) = ('bugle', b + 11, DEFAULT) WHERE c = 'foo';
UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE sl_name = old.sl_name;
UPDATE something SET a = 1 RETURNING a;
UPDATE something SET a = 1 RETURNING a AS b, c;
UPDATE something SET a = 1 FROM b;
UPDATE something SET a = 1, b = 'b' FROM c INNER JOIN d ON x = d.y, (SELECT * FROM e) AS f WHERE something.x = d.x AND LEAST(something.y, 0) = f.z + 1;
UPDATE something SET a = 1 RETURNING b AS \\"b#1\\";
UPDATE something SET a = 1 FROM b WHERE c RETURNING *;
UPDATE foo SET f2 = lower(f2), f3 = DEFAULT RETURNING foo.*, f1 + f3 AS sum13;"
`;

exports[`kitchen sink update 2`] = `
"UPDATE update_test SET c = repeat('x', 10000) WHERE ((c) = ('car'));
UPDATE update_test SET ( b,a ) = (SELECT ((a) + (1)),
b FROM update_test WHERE ((a) = (1000))) WHERE ((a) = (11));
UPDATE something SET ( b,a ) = (1, 2) WHERE ((a) = (11));
UPDATE update_test SET ( c,b,a ) = ('bugle', ((b) + (11)), DEFAULT) WHERE ((c) = ('foo'));
UPDATE shoelace_data SET sl_name = new.sl_name,sl_avail = new.sl_avail,sl_color = new.sl_color,sl_len = new.sl_len,sl_unit = new.sl_unit WHERE ((sl_name) = (old.sl_name));
UPDATE something SET a = 1 RETURNING a;
UPDATE something SET a = 1 RETURNING a AS b,c;
UPDATE something SET a = 1 FROM b;
UPDATE something SET a = 1,b = 'b' FROM c INNER JOIN d ON ((x) = (d.y)), (SELECT * FROM e) AS f WHERE (((something.x) = (d.x)) AND ((LEAST(something.y, 0)) = (((f.z) + (1)))));
UPDATE something SET a = 1 RETURNING b AS \\"b#1\\";
UPDATE something SET a = 1 FROM b WHERE c RETURNING *;
UPDATE foo SET f2 = lower(f2),f3 = DEFAULT RETURNING foo.*,((f1) + (f3)) AS sum13;"
`;

exports[`kitchen sink views create 1`] = `
"CREATE VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE MATERIALIZED VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname NOT IN ( 'pg_catalog', 'information_schema', 'pg_toast' ) AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON t.oid = a.atttypid INNER JOIN pg_class AS c ON c.oid = a.attrelid INNER JOIN pg_namespace AS n ON n.oid = c.relnamespace WHERE n.nspname IN ( 'pg_catalog', 'information_schema', 'pg_toast' ) AND attnum > 0 AND NOT (attisdropped) ORDER BY attnum;"
`;

exports[`kitchen sink views create 2`] = `
"CREATE VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE MATERIALIZED VIEW collaboration_public.direct_project_permits AS SELECT * FROM permits;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON ((t.oid) = (a.atttypid)) INNER JOIN pg_class AS c ON ((c.oid) = (a.attrelid)) INNER JOIN pg_namespace AS n ON ((n.oid) = (c.relnamespace)) WHERE (n.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast') AND ((attnum) > (0)) AND NOT (attisdropped)) ORDER BY attnum;
CREATE VIEW superschema.app_columns AS SELECT attname AS name,
t.typname AS type,
c.relname AS table_name,
n.nspname AS schema_name FROM pg_attribute AS a INNER JOIN pg_type AS t ON ((t.oid) = (a.atttypid)) INNER JOIN pg_class AS c ON ((c.oid) = (a.attrelid)) INNER JOIN pg_namespace AS n ON ((n.oid) = (c.relnamespace)) WHERE (n.nspname IN ('pg_catalog', 'information_schema', 'pg_toast') AND ((attnum) > (0)) AND NOT (attisdropped)) ORDER BY attnum;"
`;

exports[`parens 1`] = `
"SELECT node->'relation'->'RangeVar' IS NOT NULL FROM my_json_store;
SELECT node->'relation'->'RangeVar' IS NOT NULL AND node->'relation'->'RangeVar'->>'inh' IS NULL FROM my_json_store;
SELECT (a IS NOT NULL AND b IS NULL) OR (c IS NOT NULL AND (a->'inh')::bool IS FALSE) FROM my_json_store;
SELECT (node->'relation'->'RangeVar' IS NOT NULL AND node->'relation'->'RangeVar'->'inh' IS NULL) OR (node->'relation'->'RangeVar'->'inh' IS NOT NULL AND (node->'relation'->'RangeVar'->'inh')::bool IS FALSE) FROM my_json_store;
SELECT (a AND b AND c) OR d FROM t;
SELECT (a AND b AND c) OR d OR ((e AND f) OR g) FROM t;
SELECT (a AND b AND c::bool IS TRUE) OR d OR ((e AND f) OR g) FROM t;
SELECT (NOT ((a AND b)) AND c) OR NOT (d) FROM t;
SELECT NOT ((a AND b)) AND c FROM t;
SELECT NOT ((a AND b)) AND c FROM t;"
`;

exports[`parens 2`] = `
"SELECT ((((node) -> ('relation'))) -> ('RangeVar')) IS NOT NULL FROM my_json_store;
SELECT (((((node) -> ('relation'))) -> ('RangeVar')) IS NOT NULL AND ((((((node) -> ('relation'))) -> ('RangeVar'))) ->> ('inh')) IS NULL) FROM my_json_store;
SELECT ((a IS NOT NULL AND b IS NULL) OR (c IS NOT NULL AND ((a) -> ('inh'))::bool IS FALSE)) FROM my_json_store;
SELECT ((((((node) -> ('relation'))) -> ('RangeVar')) IS NOT NULL AND ((((((node) -> ('relation'))) -> ('RangeVar'))) -> ('inh')) IS NULL) OR (((((((node) -> ('relation'))) -> ('RangeVar'))) -> ('inh')) IS NOT NULL AND ((((((node) -> ('relation'))) -> ('RangeVar'))) -> ('inh'))::bool IS FALSE)) FROM my_json_store;
SELECT ((a AND b AND c) OR d) FROM t;
SELECT ((a AND b AND c) OR d OR ((e AND f) OR g)) FROM t;
SELECT ((a AND b AND c::bool IS TRUE) OR d OR ((e AND f) OR g)) FROM t;
SELECT ((NOT ((a AND b)) AND c) OR NOT (d)) FROM t;
SELECT (NOT ((a AND b)) AND c) FROM t;
SELECT (NOT ((a AND b)) AND c) FROM t;"
`;
